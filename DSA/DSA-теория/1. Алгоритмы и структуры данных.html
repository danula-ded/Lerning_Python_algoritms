<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Алгоритмы и структуры данных</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(249, 228, 188, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="0b86ba2e-f460-4a52-bc91-37c655b29632" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">🗂️</span></div><h1 class="page-title">Алгоритмы и структуры данных</h1><p class="page-description"></p></header><div class="page-body"><ul id="7b5f2891-0b88-4346-8306-0e1f432cdbac" class="toggle"><li><details open=""><summary>1. Алгоритм. Память и время как ресурсы.</summary><p id="b7b5a630-a909-4e87-be9c-3a6174d3ecc3" class=""><strong>Алгоритм</strong> – это набор шагов или инструкций, необходимых для выполнения задач.<br/><br/><strong>Алгоритм</strong> – это набор конечного числа правил, задающих последовательность выполнения операций компьютерной программой для решения задач определенного типа.<br/>Свойства алгоритма:<br/>•  <br/><strong>Конечность:</strong> Алгоритм всегда должен заканчиваться после выполнения определенного количества шагов.<br/>•  <br/><strong>Определенность: </strong>Действия, которые нужно выполнить, должны быть строго и недвусмысленно определены для каждого возможного случая.<br/>•  <br/><strong>Ввод:</strong> Алгоритм имеет некоторое(возможно равное нулю) число входных данных.<br/>•  <br/><strong>Вывод:</strong> У алгоритма есть одно или несколько выходных данных, т.е. величин, имеющих вполне определенную связь с входными данными.<br/>•  <br/><strong>Эффективность:</strong> Алгоритм считается эффективным, если все его операторы достаточно просты для того, чтобы их можно было точно выполнить в течение конечного промежутка времени с помощью карандаша и бумаги.<br/> <br/>Обычно у алгоритма две сложности:<br/>•  Временная сложность – как количество операций, которые выполняются при работе алгоритма, связано с объемом входных данных.<br/>•  Сложность по памяти – как количество памяти, которое нужно алгоритму, связано с размером входных данных.<br/><br/><strong>Память</strong><br/>Память – это объем оперативной памяти, который потребуется алгоритму для работы. Например, одна переменная – одна ячейка памяти, а массив – это больше ячеек памяти.                                          Для анализа алгоритма обычно используется анализ пространственной сложности алгоритма, чтобы оценить необходимую память времени исполнения как функцию от размера входа. Результат обычно выражается в терминах “О” большое.<br/>Существует 4 аспекта использования памяти:<br/>•  Количество памяти, необходимое для хранения кода алгоритма.<br/>•  Количество памяти, необходимое для входных данных.<br/>•  Количество памяти, необходимое для любых выходных данных(но некоторые алгоритмы, такие как сортировка, часто переставляют входные данные и не требуют памяти для выходных)<br/>•  Количество памяти, необходимое для вычислительного процесса во время вычислений. (именованные переменные, любое стековое пространство, необходимое для вызова подпрограмм, которое может быть существенным при использовании рекурсии)<br/><br/><strong>Время</strong><br/>Время – это … время, которое нужно алгоритму для обработки данных. Время считают не в  секундах и минутах, а в количестве операций, которые алгоритм совершит.                                                               Для анализа алгоритма обычно используется анализ временной сложности алгоритма, чтобы оценить время работы как функцию от размера входных данных. Результат обычно выражается в терминах “О” большое.<br/></p></details></li></ul><ul id="cdedf191-8a57-4da7-ac9a-25a95bcfd54a" class="toggle"><li><details open=""><summary>2. O-символика как инструмент оценки ресурсов, различные асимптотики (логарифм, полином, экспонента).</summary><p id="dd8edc06-0e07-4683-a596-6ff5189e013b" class="">O-символика, или асимптотическая запись, - это система символов, позволяющая оценить время выполнения алгоритма, устанавливая зависимость времени выполнения от увеличения объёма входных данных[1]. Она также известна как оценка сложности алгоритмов.</p><p id="f8e7cef4-858c-48d2-b6f4-c6543ab01f18" class="">Существует несколько видов асимптотической нотации, которые используются для оценки сложности алгоритмов:</p><ol type="1" id="1c721576-f9ae-4ef5-8be2-95284218acea" class="numbered-list" start="1"><li><strong>Константа</strong>: O(1)</li></ol><ol type="1" id="be99f987-ece4-443c-b7ff-3194983a3022" class="numbered-list" start="2"><li><strong>Логарифмическая функция</strong>: O(log n)</li></ol><ol type="1" id="ab8a105a-5975-4077-8efc-c3e334ab4922" class="numbered-list" start="3"><li><strong>Линейная функция</strong>: O(n)</li></ol><ol type="1" id="303c55f7-441d-42a5-83c0-7ba3a88b45da" class="numbered-list" start="4"><li><strong>Корневая функция</strong>: O(sqrt(n))</li></ol><ol type="1" id="8a38acef-4cf3-441f-af48-9e10520faf69" class="numbered-list" start="5"><li><strong>Квадратичная функция</strong>: O(n^2)</li></ol><ol type="1" id="56eb7b60-2734-4265-b11b-db30b20cafc5" class="numbered-list" start="6"><li><strong>Степенная функция</strong>: O(n^k), где k - константа</li></ol><ol type="1" id="73a61894-917e-4cc6-aa8f-e366fbe9b51a" class="numbered-list" start="7"><li><strong>Показательная функция</strong>: O(a^n), где a - константа</li></ol><ol type="1" id="e82c08ed-9dba-41e8-94a4-1d1f2e7c5ee6" class="numbered-list" start="8"><li><strong>Факториал</strong>: O(n!)</li></ol><p id="d2a0badf-8c8f-4911-9ca3-d07da38a009e" class="">Например, для алгоритма сортировки пузырьковой метод имеет временную сложность O(n^2), а алгоритм быстрого сортировки имеет временную сложность O(n log n).</p><p id="8795e485-0855-4444-a6cf-938b430b3f06" class="">Асимптотическая нотация позволяет сравнивать различные алгоритмы и определить, какой из них более эффективен для конкретной задачи. Однако стоит учитывать, что в реальных условиях выполнения алгоритмов могут влиять дополнительные факторы, такие как размер памяти, скорость процессора и другие характеристики компьютерной системы.</p><p id="1920921a-740c-4c1d-bc45-4e40b3b29cef" class="">Метод математической индукции, использование для доказательства оценок.</p></details></li></ul><ul id="6b164957-91b7-4ee1-bc7f-d83db0115252" class="toggle"><li><details open=""><summary>3. Метод математической индукции, использование для доказательства оценок.</summary><p id="a1e7e878-c96f-4284-aac0-c287a1d5e757" class=""><strong>Индукция</strong> – это переход от общего к частному.</p><p id="f5b79d0d-0fcd-4e8c-aa70-df5238bbc1e4" class="">Метод используется для доказательства тех или иных утверждений с натуральными числами.</p><p id="bb641620-cc46-422a-8436-414c60227d73" class="">Он заключается в следующем: некоторое утверждение справедливо для всякого натурального n, если:</p><ul id="0864c2f6-d06f-460e-9ea8-60803eec800e" class="bulleted-list"><li style="list-style-type:disc">Оно справедливо для n=1 и</li></ul><ul id="dc37cc87-660c-4a0d-b62e-c42fc7b9ee86" class="bulleted-list"><li style="list-style-type:disc">Из справедливости утверждения для какого-либо произвольного натурального n = k следует его справедливость для n = k+1</li></ul><p id="310b9134-dea8-48d9-bf40-49b57cd65a57" class="">Пример: 1=1^2, 1+3=2^2, 1+3+5=3^2.</p><p id="989e2d89-600c-46de-ab99-c387b35c46a7" class="">Если что: 1^2 – это один во второй степени.</p></details></li></ul><ul id="88dadb9d-5d70-404f-87e5-df741435d565" class="toggle"><li><details open=""><summary>4. Алгоритмы для работы с большими числами: сложение, умножение, быстрое возведение в степень</summary><p id="65ba6ec6-6e03-4e5f-bad3-44be0aa8d2f7" class="">Для арифметики с большими числами (сложение и умножение) есть различные алгоритмы (алг. Карацубы, Фюрера и др). Однако вполне применимы наивные алгоритмы, которые основаны на сложении и умножении в столбик.</p><p id="469c2ee1-6243-4ffd-883b-1e7d18a524f9" class=""> Так, можно представить два числа в виде массивов, каждый элемент которых содержит цифру в разряде числа. Для удобства следует сделать оба списка одинаковыми по длине, т.е. в список числа с наименьшим количеством разрядов стоит добавить ведущие нули. Теперь, проходясь циклом по всем разрядам чисел от младших к старшим, будем складывать каждый разряд и записывать его результат по модулю 10, а при переходе через разряд добавлять 1 к следущему разряду. Аналогичным образом работает алгоритм умножения (реализацию обоих алгоритмов можно найти в практических вопросах). Сложность алгоритма сложения - O(n) где n - количество разрядов в более длинном числе, а умножения - O(n*m) где n и m - количества разрядов в числах.</p><p id="536fc266-9678-4a50-97a2-f638c4b6d468" class="">Бинарное возведение в степень - алгоритм возведения в степень, основывающийся на свойстве степеней - (a^n)*(a^m)=a^(n+m)</p><p id="fc6c2a2c-0001-4fcb-b67a-4923d6f1bdec" class="">Можно вывести следущее соотношение:</p><p id="1d6adde7-b7ff-40d2-80a3-c0bc9a3ca7d9" class="">a^1 = a</p><p id="237cb900-b864-4fbb-b950-c78356a97a73" class="">a^(2n) = a^n * a^n</p><p id="225844a3-d7fd-4cb2-9ab2-29124dd0a892" class="">a^(2n+1) = a^(n+1) * a^n</p><p id="47e1dd15-d6d0-457e-944e-a2f126743c1c" class="">Данная задача как правило решается за счёт нисходящей рекурсии и имеет сложность O(log n)<div class="indented"><p id="616cb83a-b916-4521-ba18-e6e1d2fe18f0" class="">Примеры этих алгоритмов можно найти в практике.</p></div></p></details></li></ul><ul id="a19d93e1-c2bf-488c-b6fa-5b25138c03b8" class="toggle"><li><details open=""><summary>5. Арифметика по модулю: сложение, умножение, возведение в степень</summary><p id="b4de3917-4534-45e4-8953-dd2c62e51fa2" class="">Если два целых числа a и b при делении на m дают<br/>одинаковые остатки, то они называются сравнимыми (или<br/>равноостаточными) по модулю числа m.<br/>a ≡ b (% m)<br/></p><p id="6678c778-c81d-453e-a989-0900c1bc64a6" class="">Определение сравнимости чисел a и b по модулю m равносильно любому из<br/>следующих утверждений:<br/>● разность чисел a и b делится на m без остатка;<br/>● число a может быть представлено в виде a=b+k * m, где k — некоторое<br/>целое число.<br/></p><p id="3ed8c8ed-889f-4f21-a6e3-85945619f297" class=""><strong>Математические операции:</strong></p><p id="b90f47eb-9298-4b53-9f51-80e6f30561b6" class=""><em>(A + B) % C = (A % C + B % C) % C<br/>(A * B) % C = (A % C * B % C) % C<br/>A^B % C = ( (A % C)^B ) % C<br/></em></p><p id="0c5b3f9a-8cef-4adb-a3f3-5eccb7d43aa5" class="">Это необходимо для оптимизации вычислений при работе с большими числами: если результат необходимо искать по модулю, то можно оперировать остатками по этому же модулю при математических операциях.</p></details></li></ul><ul id="c385c722-51a6-4f3c-8fc2-4e20f6a85cad" class="toggle"><li><details open=""><summary>6. Алгоритм Евклида, расширенный алгоритм Евклида.</summary><p id="c3ff1083-27a2-4982-8f4f-668d58037d04" class=""><strong>Алгоритм Евклида</strong></p><p id="7d9adbab-4cf1-4ac6-96ca-f9851455cdd4" class="">Даны два целых положительных числа m и n. Требуется найти их наибольший общий делитель, т.е. наибольшее целое положительное число, которое нацело делит оба числа m и n.</p><ol type="1" id="a9441645-7ac6-4346-b6a0-a63d966e48e4" class="numbered-list" start="1"><li>[Нахождение остатка] Разделим m на n, и пусть остаток от деления будет равен r (где 0&lt;= r &lt;= n)</li></ol><ol type="1" id="76f8471a-06e3-4ad2-be71-ffaa50ceff69" class="numbered-list" start="2"><li>[Сравнение с нулем] Если r=0, то выполнение алгоритма прекращается; n – искомое значение.</li></ol><ol type="1" id="f6eb7171-7cb4-47d5-a87e-c7f213e86b14" class="numbered-list" start="3"><li>[Замещение] Присвоить m&lt;-n, n&lt;-r и вернуться к первому шагу.</li></ol><p id="2e27218a-5837-4de6-86ed-897c56897c8d" class=""><strong>Расширенный алгоритм Евклида:</strong></p><p id="926dfe76-0086-419b-8fe3-7fc847cd8b9d" class="">Кратко: a*x + b*y = НОД(a, b)</p><p id="70e09527-1105-45bd-bf88-7ffc0a4237f8" class="">Пусть (x1, y1) – решение для задачи новой пары (b%a, a). Тогда:</p><p id="a8b0ee3c-6024-4d20-847a-061b00d01b0c" class="">X= y1 – [a/b] *x1,</p><p id="e1f1e632-03b0-4536-8076-57b4dc663cf5" class="">Y = x1</p><p id="755c9532-3274-49ea-b50f-7ccd21f7ae92" class="">Не кратко:</p><p id="8a39c52b-8706-4f6f-a153-cfb3b44cccf2" class="">Расширенный алгоритм Евклида – это модификация базового алгоритма Евклида, который помимо нахождения наибольшего общего делителя (НОД) двух чисел, также находит коэффициенты x и y, удовлетворяющие уравнению ax + by = НОД(a, b).</p><p id="fbf157c8-3ce3-499c-992b-8fb54031f47a" class="">Алгоритм начинается с тех же шагов, что и базовый алгоритм Евклида:</p><p id="136e1b0c-6229-4094-a6f2-883f98a6018f" class=""><strong>Шаг 1:</strong></p><p id="55b6bc2d-3289-476a-9cd7-a176dcc90a0a" class="">Пусть a и b – два числа, для которых мы хотим найти НОД.</p><p id="cece3c59-a6d2-4c01-b322-e33db8c0746d" class="">Если b равно 0, то НОД(a, b) равен a, и алгоритм останавливается.</p><p id="ba494323-b5ce-4d04-bfbe-65b16a9134a1" class=""><strong>Шаг 2:</strong></p><p id="06604242-d6f9-457c-b3be-1c797d9cb00c" class="">Вычисляем остаток r от деления a на b: r = a % b.</p><p id="5bda00cc-8b68-4292-994e-638724cc22a1" class="">Шаги 1 и 2 повторяются до тех пор, пока остаток r не станет равным 0.</p><p id="68285508-134b-4d40-8d9e-a3dd9b236d4d" class="">После этого, НОД(a, b) будет равен b.</p><p id="ad285f3b-7c42-40fc-be37-8e3f10412abf" class="">Теперь, чтобы найти коэффициенты x и y, удовлетворяющие уравнению ax + by = НОД(a, b), мы используем обратную подстановку:</p><p id="168f69c5-c493-4a89-a76d-b253e6878ded" class=""><strong>Шаг 3:</strong></p><p id="f0bc45c9-1cc2-43f9-8f0a-ac8508e66d41" class="">Из уравнения ax + by = НОД(a, b) следует, что:</p><p id="e157dcd0-899d-45df-887a-f4f6f37c0d85" class="">ax + by = bx’ + (a % b)y’, где x’ и y’ – коэффициенты, найденные на предыдущем шаге.</p><p id="457c80b4-87cd-46fd-9ff1-144805e897a1" class="">Раскрывая скобки, получаем:</p><p id="d64f5f78-bc97-4111-960c-b4a91ccca95f" class="">ax + by = bx’ + (a – (a // b)b)y’ = ay’ + b(x’ – (a // b)y’).</p><p id="080df589-c67c-4cc6-8d31-4a0747935f62" class="">Таким образом, мы получаем новые коэффициенты x = y’ и y = x’ – (a // b)y’.</p><p id="82b6d7d2-b41a-4bd6-bc05-02cf09a71bba" class="">Шаг 3 повторяется до тех пор, пока не достигнут базовый случай, когда остаток r равен 0.</p><p id="74055e22-45c9-44e7-b89b-917ac8ffa856" class="">В итоге, расширенный алгоритм Евклида позволяет найти НОД(a, b) и коэффициенты x и y, удовлетворяющие уравнению ax + by = НОД(a, b).</p></details></li></ul><ul id="c1046406-6ec3-4726-b80e-9ebd99349204" class="toggle"><li><details open=""><summary>7. Проверка чисел на простоту, решето Эратосфена.</summary><p id="8476590e-1dc5-4f73-a3d3-f8d3fe164733" class=""><strong>Проверка чисел на простоту, решето Эратосфена.</strong></p><p id="fa5170f7-a502-4112-b2bc-707101d0dba9" class="">Простым числом называется число, большее 1, которое делится нацело только на себя и на 1(имеет два натуральных делителя).</p><p id="859705f8-86f9-4200-a093-837a5b8d2767" class=""><strong>Проверка чисел на простоту</strong></p><p id="b63adec4-2d04-4e77-8aed-5709e610b1ab" class="">Необходимо узнать, существуют ли такие натуральные числа x, y (1&lt;x,  y&lt;N), что x*y = N.</p><p id="2016c2ad-570b-4bfe-b33f-a57c63488bde" class="">Условимся, что x&lt;=y, тогда можно сказать, что x меньше либо равен квадратному корню из числа N.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="daf357ea-e4c0-416f-b755-3bbdcbb1a8e3" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def isPrime(n):
    if n == 2:
        return True
    j = int(n ** 0.5) + 1
    for i in range(2, j+1):
        if n % 1 == 0:
            return False
    return True</code></pre><p id="7409190f-865a-4df2-9673-a980333c2b6b" class=""><strong>Решето Эратосфена.</strong></p><p id="fc1abb8f-b9f3-4a9b-8bc4-eda8669bdee7" class=""><strong>Решето Эратосфена </strong>– алгоритм нахождения всех простых чисел, не превышающих некоторое натуральное число n.</p><ol type="1" id="2bc6aef0-5aec-4583-9e78-f4c610e5d459" class="numbered-list" start="1"><li>Выписать подряд все целые числа от двух до n(2, 3, 4…n)</li></ol><ol type="1" id="892e8ed9-7063-44e3-a209-d1d16cc1ec9d" class="numbered-list" start="2"><li>Пусть переменная p изначально равна 2 – первому простому числу.</li></ol><ol type="1" id="2fc52c33-e320-4e60-8269-f529cce3e069" class="numbered-list" start="3"><li>Зачеркнуть в списке числа от 2p до n, считая шагами по p(это будут числа, кратные p: 2p, 3p, 4p….)</li></ol><ol type="1" id="3fe06fe4-e6e9-4c0b-935c-a502495b2bdd" class="numbered-list" start="4"><li>Найти первое незачеркнутое число в списке, больше чем p, и присвоить значению переменной p это число.</li></ol><ol type="1" id="48b8f6b7-a0bf-4f17-9530-0e565ad8c094" class="numbered-list" start="5"><li>Повторять шаги 3 и 4, пока это возможно.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d9b3bd26-1c89-44ed-9637-f3070ffdba29" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">n =int(input(&#x27;Введите N: &#x27;))
a = [i for i inrange(n + 1)]
a[1] = 0
i = 2
while i &lt;= n:
    if a[i] != 0:
        j = i + i
        while j &lt;= n :
            a[j] = 0
            j = j + i
    i += 1
a =set(a)
a.remove(0)
print(a)</code></pre></details></li></ul><ul id="1bedc04a-05e9-4d26-9cb4-d17744e90b25" class="toggle"><li><details open=""><summary>8. Криптография: схемы с закрытым ключом, RSA.</summary><p id="c0bdb42f-9eca-420e-9d14-96680255a38b" class=""><strong>RSA(аббревиатура от фамилий </strong><strong>Rivest, </strong><strong>Shamir и </strong><strong>Adleman)</strong> – криптографический алгоритм с открытым ключом, основывающийся на вычислительной сложности задачи факторизации больших полупростых чисел.</p><p id="af774fdc-b4ac-433c-b0af-c722742bd8ef" class="">Например: 592939 * 592967 = 351593260013. Но как имея только число 351593260013 узнать числа 592939 и 592967? Это называется “сложность задачи факторизации произведения двух больших простых чисел”, т.е. в одну сторону просто, а в обратную невероятно сложно.</p><p id="fa73b3be-2689-4ff8-b86c-17c98328f067" class="">Используется при обмене данными и в качестве цифровой подписи. Является базовой частью протокола HTTPS.(более подробный процесс как это все происходит смотрите в лекции 2. Там все продемонстрировано на картинках)</p><p id="caa4de00-4c97-4269-bcbd-8790d03c2e11" class=""><strong>Процедура создания ключей</strong></p><ol type="1" id="09e82faa-2f1f-4dde-89d4-15d2771ab2b7" class="numbered-list" start="1"><li>Выбираем два случайных простых числа p и q</li></ol><ol type="1" id="e4e5810f-9d63-4664-93ad-8e6540880ff2" class="numbered-list" start="2"><li>Вычисляем их произведение: N = p*q</li></ol><ol type="1" id="dbe9e1e8-f8ed-4e09-af52-b664f32e554c" class="numbered-list" start="3"><li>Вычисляем функцию Эйлера фи(N)=(p-1)*(q-1)</li></ol><ol type="1" id="cae7976d-f089-470d-a50a-5dde2b7133a9" class="numbered-list" start="4"><li>Выбираем число е(обычно простое, но необязательно), которое меньше фи(N) и является взаимно простым с фи(N) (не имеющих общих делителей друг с другом, кроме него же и 1)</li></ol><ol type="1" id="5672affa-6482-4b3e-9e7a-d73354e3cebb" class="numbered-list" start="5"><li>Ищем число d, обратное числу е по модулю фи(N). Т.е. остаток от деления (d*e) и фи(N) должен быть равен 1. Найти его можно через расширенный алгоритм Евклида.</li></ol><p id="288a8740-0304-4cbe-910f-a1c4c1a2a02d" class="">e и n – открытый ключ; d и n -закрытый ключ</p><p id="25ddd9e9-8454-4f3b-9d89-009a44ea9754" class="">Пример генерации ключей:</p><p id="fee1baac-0bbf-4fc0-95cc-6c8f3269db9c" class="">Пусть p=19, q=41</p><p id="2f140985-0576-48de-9435-06f8ed2d75ff" class="">N = p*q = 779</p><p id="e577ccd5-0817-4aca-9d06-63c01658cb82" class="">Фи(N) = (p-1)*(q-1) = 720</p><p id="cc80d7ae-59ec-497a-9eed-145275e395fd" class="">e = 691</p><p id="3d858dcf-74e4-4400-8f2c-0966c0d7d259" class="">d = 571</p><p id="67043cb5-310d-49ca-a644-e03902185f6c" class="">Получается: {691, 779} – открытый ключ. {571, 779} – закрытый ключ</p></details></li></ul><ul id="11934c55-8486-4d62-a249-cc9ed69c10ff" class="toggle"><li><details open=""><summary>9. Квадратичные сортировки (вставками и пузырьковая).</summary><p id="1b26ef5f-332e-4b0d-adfc-08b9892d51e0" class="">Квадратичные, т.к. их сложность O(n^2). В квадратичные сортировки входят такие алгоритмы как:</p><p id="57cd9587-1aab-4247-986f-c7d4beb1a7c4" class=""><strong>Сортировка пузырьком(или сортировка простыми обменами)</strong></p><p id="6e6585b4-ac70-4921-83ca-d2906b7fb115" class="">Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется перестановка элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны – массив отсортирован.</p><p id="c7131723-2f35-4cc0-87b9-e899cdf75c82" class="">С помощью for:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4e37a3b2-834e-48a9-be99-9d2d829d84c2" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">from randomimport randint

N = 10
a = []
for iin range(N):
    a.append(randint(1, 99))
print(a)


for iin range(N-1):
for jin range(N-i-1):
if a[j] &gt; a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]

print(a)</code></pre><p id="5250b8bc-e524-47b9-8794-876adcabe8d5" class="">С помощью while:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="76129641-7ac3-4807-8ad2-bc0afc9a4042" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">from randomimport randint

N = 10
a = []
for iin range(N):
    a.append(randint(1, 99))
print(a)

i = 0
while i &lt; N - 1:
    j = 0
while j &lt; N - 1 - i:
if a[j] &gt; a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]
        j += 1
    i += 1

print(a)</code></pre><p id="6c8fa877-8f78-46ce-853e-a9001684c2fc" class=""><strong>Сортировка вставками</strong></p><p id="dd2a4e10-7402-4fcc-94c2-5d4b55211b05" class="">В начальный момент отсортированная последовательность пуста. На каждом шаге алгоритма выбирается один из элементов входных данных и помещается на нужную позицию в уже отсортированной последовательности до тех пор, пока набор входных данных не будет исчерпан.</p><p id="6e1dc7aa-8000-46ec-a56e-38107ba9b176" class="">Данный алгоритм можно ускорить при помощи использования бинарного поиска для нахождения места текущему элементу в отсортированной части. Проблема с долгим сдвигом массива вправо решается при помощи смены указателей.<br/><br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="848daf1c-ae57-4ba9-b253-9676445a02b7" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def insertion_sort(list1):
    for i in range(1, len(list1)):
        value = list1[i]
        j = i - 1
        while j &gt;= 0 and value &lt; list1[j]:
            list1[j + 1] = list1[j]
            j -= 1
        list1[j + 1] = value
    return list1</code></pre><p id="ef2f4699-a084-416a-849d-1e3827b48b73" class="">выбором минимумом - хз, узнаю позже у зернова</p></details></li></ul><ul id="8c65f040-1fc3-4d1e-8d74-5ebca3d74d99" class="toggle"><li><details open=""><summary>10. Метод «разделяй и властвуй». Бинарный поиск.</summary><p id="13732e7c-2a9e-4d8d-931d-a31c4c0a0441" class=""><strong>“Разделяй и властвуй”</strong> в информатике – это схема разработки алгоритмов, заключающаяся в рекурсивном разбиении решаемой задачи на две или более подзадачи того же типа, но меньшего размера, и комбинировании их решений для получения ответа к исходной задаче; разбиения выполняются до тех пор, пока все подзадачи не окажутся элементарными.</p><p id="91ca0731-eaec-46cd-bbee-c48963b0d244" class="">Данный метод применяется в таких алгоритмах как бинарный(двоичный) поиск и сортировка слиянием.</p><p id="977fb174-f314-40d9-b5e1-443e0d4362a1" class=""><strong>Бинарный(двоичный) поиск</strong></p><p id="bfc3dc40-49e8-4faa-ac74-bb557d4a69b0" class="">Дана таблица записей R1, R2, …Rn, ключи которых расположены в порядке возрастания: K1&lt;K2&lt;..&lt;Kn, алгоритм используется для поиска заданного аргумента K.</p><ol type="1" id="aa6bd90a-b974-4a7a-a795-5fbedc1eb977" class="numbered-list" start="1"><li>Установить I &lt;- 1, u &lt;- N</li></ol><ol type="1" id="8d88e193-ae09-48c8-9113-6d0a44918010" class="numbered-list" start="2"><li>Если u&lt;I, алгоритм завершается неудачно; иначе установить I &lt;- floor((l+u)/2), чтобы I соответствовало примерно середине рассматриваемой части таблицы.</li></ol><ol type="1" id="51d5cb74-d9fe-44c0-b6c2-3cab39583651" class="numbered-list" start="3"><li>Если K&lt;Ki, перейти к шагу 4; если K&gt;Ki, перейти к шагу 5, если K=Ki, алгоритм успешно завершается.</li></ol><ol type="1" id="f899f223-7932-4804-bd62-5c91d084608f" class="numbered-list" start="4"><li>Установить u &lt;- i-1 и перейти к шагу 2.</li></ol><ol type="1" id="91aa7097-c4e4-4224-97b3-129e7a2bdf0c" class="numbered-list" start="5"><li>Установить I &lt;- i+1 и перейти к шагу 2.</li></ol><p id="e4cc3ed1-71f2-495c-83a9-123aabb9ce4f" class="">Сложность: O(logn)</p></details></li></ul><ul id="310215e1-272b-40dc-ae42-53bbd72c41a3" class="toggle"><li><details open=""><summary>11. Сортировка слиянием: наивная и эффективная реализация.</summary><ol type="1" id="d2a9b317-1e11-4c73-b8c1-b65e0d8b8082" class="numbered-list" start="1"><li>Сортируемый массив разбивается на две части примерно одинакового размера. Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива не достигнет единицы(любой массив длины 1 можно считать упорядоченным)</li></ol><ol type="1" id="b3e9db3b-3197-4197-9247-b78cf62f7880" class="numbered-list" start="2"><li>Каждая из получившихся частей сортируется отдельно, например – тем же самым алгоритмом.</li></ol><ol type="1" id="8e5b8817-aa71-4a98-b5af-9ccd39da21f2" class="numbered-list" start="3"><li>Два упорядоченных массива половинного размера соединяются в один.</li></ol><p id="94e8debd-07b3-498f-b749-891c3eea4ae8" class="">a. На каждом шаге мы берем меньшей из двух первых элементов подмассивов и записываем его в результирующий массив. Счетчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.</p><p id="06932e0b-2adf-496b-9283-546b6ee1c01b" class="">b. Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив.</p><p id="d7275c41-8356-44a8-aef4-26ac03bf61f1" class="">
</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a41bcc5d-a571-4fc7-abfc-128262aa69a8" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def merge(A, B):
    i, j, C = 0, 0, []
    while True:
        if A[i] &lt; B[j]:
            C.append(A[i])
            i += 1
            if i == len(A):
                C.extend(B[j:])
                break
        else:
            C.append(B[j])
            j += 1
            if j == len(B):
                C.extend(A[i:])
                break
    return C</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1c47c4e2-be69-4d16-9f45-e5a8c1ef56e5" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def top_down_merge_sort(A):
    if len(A) == 1:
        return A

    d = len(A) // 2
    left = top_down_merge_sort(A[:d])
    right = top_down_merge_sort(A[d:])
    return merge(left, right)

def bottom_up_merge_sort(A):
    k = 1
    while k &lt; len(A):
        for i in range(0, len(A) - k, 2 * k):
            A[i:i + 2 * k] = merge(A[i:i + k], A[i + k:i + 2 * k])
        k *= 2
    return A</code></pre><p id="e4180af6-60af-48a5-b9e5-394e2b368be6" class="">Эффективная реализация включает в себя Galloping и Chunking:</p><p id="a855629f-0ad9-435b-9d42-c6a175976c1c" class="">Сортировка слиянием. Галопирование(galloping)</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a0361dca-b629-4752-9283-843df6ffa01f" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def galloping(AB, n, C):
    C[:] = AB[:n]
 # r — указатель на конец результата
 # j — место последней вставки
 # m — длина остатка B
    r, j, m = 0, n, len(AB) - n
    for i in range(n):
 # k — степень двойки
 # l — указатель на 2^k-1 элемент
    k, l = 0, 0
    while l &lt; m and AB[j+l] &lt; C[i]:
        k += 1
        l = 2**k - 1
    if l &gt;= m:
        l = m - 1
    while l &gt;= 0 and AB[j+l] &gt; C[i]:
        l -= 1
    l += 1
    AB[r:r+l], AB[r+l] = AB[j:j+l], C[i]
    r, j, m = r + l + 1, j + l, m - l</code></pre><p id="baf6aba8-5dcd-4603-9ff8-685fd4404a04" class="">Сортировка слиянием. Chunking</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c0e85b52-0fdc-4754-a8d4-b0cef6e479d7" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def chunking(A):
    chunks = []
    a, d = 0, 0
    for b in range(1, len(A)):
        if d == 0:
            d = A[b] - A[a]
            continue
        if (A[b] - A[b-1])*d &lt; 0:
            chunks.append((a, b-1) if d &gt; 0 else (b-1, a))
            a, d = b, 0
    chunks.append((a, b) if d &gt; 0 else (b, a))
    return chunks</code></pre></details></li></ul><ul id="03a0504f-0474-4be7-9616-d8de1fe6cbbf" class="toggle"><li><details open=""><summary>12. Быстрая сортировка: понятие вероятностного алгоритма, время работы в среднем, простейший алгоритм, inplace-алгоритм.</summary><p id="c055eefd-7d75-4d14-b30f-c6009da76149" class=""><strong>Быстрая сортировка, сортировка Хоара </strong>– Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем O(logn) обменов при упорядочении n элементов.</p><p id="36e6767b-b418-419a-8d86-19a79c540fa7" class=""><strong>Суть алгоритма:</strong></p><ol type="1" id="190bff6d-6bac-44e3-a127-064c21afeec8" class="numbered-list" start="1"><li>Выбор опорного элемента (Pivot): Из массива выбирается элемент, называемый опорным. Обычно выбирают середину массива, но это может быть сделано различными способами.</li></ol><ol type="1" id="99c7cc16-8eba-4a31-adb5-73d8b6803afe" class="numbered-list" start="2"><li>Разделение (Partitioning): Массив разделяется на две подгруппы: элементы, меньшие опорного, и элементы, большие опорного. Элементы, равные опорному, могут оказаться в любой из подгрупп или в отдельном массиве, в зависимости от конкретной реализации.</li></ol><ol type="1" id="fb4615da-d2dd-47f2-bac3-4b23581ebe5e" class="numbered-list" start="3"><li>Рекурсивная сортировка:<ol type="a" id="35f9ba38-a18a-45ad-8602-3f9ab5655711" class="numbered-list" start="1"><li>Левая подгруппа сортируется рекурсивно, применяя тот же процесс.</li></ol><ol type="a" id="e51ec591-a238-4eec-bde6-2fb0c6c83b52" class="numbered-list" start="2"><li>Правая подгруппа сортируется рекурсивно, применяя тот же процесс.</li></ol></li></ol><ol type="1" id="c6969d7f-caa6-446f-8bf0-d20a040506fc" class="numbered-list" start="4"><li>Объединение:<ol type="a" id="16067709-af87-4a6b-b6cc-a8cad6bbebd1" class="numbered-list" start="1"><li>Результатом сортировки будет объединение отсортированных левой подгруппы, опорного элемента и отсортированной правой подгруппы.</li></ol></li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="761c6055-4a24-4538-aa45-f789bbffeadd" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">#алгоритм быстрой сортировки
def func1(arr):
    if len(arr) &lt;= 1: #должно заканчиваться, если в списке один элемент
        return arr
    pivot = arr[0] #берем нашу границу - опорный элемент.первый зачастую
    less = [x for x in arr[1:] if x &lt; pivot] #создаем три arr который меньше равен и больше нашему pivot
    equal = [x for x in arr[1:] if x == pivot]
    greater = [x for x in arr[1:] if x &gt; pivot]
    return func1(less) + [pivot] + equal + func1(greater)

print(func1([1, 4, 2, 5, 3, 5, 8, 7]))
</code></pre><p id="b98afed9-3404-4301-8bcb-11251ab08964" class=""><strong>Вероятностный алгоритм</strong> – это алгоритм, предусматривающий обращение на определённых этапах своей работы к генератору случайных чисел с целью получения экономии во времени работы за счёт замены абсолютной достоверности результата достоверностью с некоторой вероятностью</p><p id="b7697b5b-da92-4365-8c6e-87bf73fef0a5" class=""><strong>Inplace-алгоритм</strong> –  алгоритм не использует дополнительное пространство для манипулирования входными данными, но может потребовать небольшого, хотя и непостоянного дополнительного пространства для своей работы. (если кратко:это алгоритм, который не занимает память выходными данными. то есть он берет наш массив, переставляет в нем элементы, и возвращает тот же, но отсортированный).</p><p id="b6e6a097-2595-40b6-8ce9-28327f370f24" class="">
</p></details></li></ul><ul id="c8b37b14-53cd-453e-8ab8-33037e0712b9" class="toggle"><li><details open=""><summary>13. Динамическое программирование. Общие принципы динамического программирования. Восстановление ответа.</summary><p id="ae4e0024-2183-4ba8-a5cf-0c8b98d9ac19" class=""><strong>Динамическое программирование</strong> – способ решения сложных задач путем разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений можно значительно сократить.</p><p id="7c47632e-54d2-45bc-9211-761af574f73f" class=""><strong>Динамическое</strong> <strong>программирование</strong> похоже на метод «<strong>разделяй</strong> <strong>и</strong> <strong>властвуй</strong>», оба из которых решают исходную проблему путем решения подзадач. <strong>Разница</strong> в том, что алгоритм «<strong>разделяй</strong> <strong>и</strong> <strong>властвуй</strong>» будет выполнять много ненужной работы при решении подзадач, он будет многократно решать эти общие подзадачи; в то время как алгоритм <strong>динамического</strong> <strong>программирования</strong> решает каждую подзадачу только один раз, и сохраняет свое решение в таблице.</p><p id="a8478f18-d074-4a42-8054-e80709ee6b0f" class=""><strong>Принципы ДП</strong><strong>:</strong></p><ul id="e5bceda0-a1e9-4320-8469-e4ec52377e87" class="bulleted-list"><li style="list-style-type:disc">Метод динамического программирования сверху(<strong>мемоизация, ленивая динамика</strong>) – это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем.</li></ul><ul id="aefeeb27-6683-4953-8078-2de1389719b9" class="bulleted-list"><li style="list-style-type:disc">Динамическое программирование снизу(<strong>табуляция</strong>) – включает в себя переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач.</li></ul><p id="50f0a19d-39c3-4ad1-acd6-dc32607e2dd6" class=""><strong>Основная идея динамического программирования состоит в том, чтобы:</strong></p><ol type="1" id="723d11f1-6f2c-4381-a89b-8d5fe85883f6" class="numbered-list" start="1"><li>Свести задачу для N к задаче для чисел, меньших, чем N (с помощью формулы)</li></ol><ol type="1" id="8034d364-cf55-4708-b961-bf7a3c0fdb4e" class="numbered-list" start="2"><li>Хранить все ответы в массиве</li></ol><ol type="1" id="d0fe13ae-a5c0-41cc-b645-ac44ee5723c1" class="numbered-list" start="3"><li>Заполнить начало массива вручную(для которых формула не работает)</li></ol><ol type="1" id="02735a09-86a5-449a-8413-82daa90209ac" class="numbered-list" start="4"><li>Обойти массив и заполнить ответы по формуле</li></ol><ol type="1" id="245bb2fc-5eea-41e3-9bb2-120d8f443b37" class="numbered-list" start="5"><li>Вывести ответ откуда-то из этого массива</li></ol></details></li></ul><ul id="6fced140-ec9b-4114-b62c-88fa179faedd" class="toggle"><li><details open=""><summary>14. Наибольшая возрастающая подпоследовательность.</summary><p id="14581ab4-9626-424f-a845-d272b9f42a41" class="">Алгоритм поиска наибольшей возрастающей подпоследовательности. Рассмотрим последовательность чисел a 1 , a 2 , …, a n. Если вычеркнуть из этой последовательности часть чисел, мы получим другую последовательность, которую называют подпоследовательностью данной последовательности. Например, рассмотрим последовательность чисел: [10, 22, 9, 33, 21, 50, 41, 60, 80]. Возможны несколько возрастающих подпоследовательностей, но самая длинная из них - [10, 22, 33, 50, 60, 80].</p><p id="df9f3a14-c26c-4ab3-80f8-9209444ddc03" class="">Рассмотрим теперь еще одну последовательность b 1 , b 2 , …, b m. Требуется найти длину самой длинной подпоследовательности последовательности {a I }, которая одновременно является и подпоследовательностью последовательности {b I }. Такую последовательность называют наибольшей общей подследовательностью (НОП). Например, для последовательностей 1, 2, 3, 4, 5 и 2, 7, 3, 2, 5 НОП является подпоследовательность 2, 3, 5, состоящая из трёх членов.</p><p id="8689725d-6212-4593-b2c8-3d3884ab365f" class="">| Другими словами, вы ищете такую последовательность чисел, которая встречается и в {a I } и в {b I }, и при этом имеет максимальную длину</p><p id="b21648f7-a17a-41fa-95e3-3da278759517" class="">Опишем подзадачи, на которые мы будем разбивать нашу задачу. Мы напишем функцию LCS(p, q), которая находит длину НОП для двух начальных участков a1 … ap и b1…bq наших последовательностей. Пусть для всех пар q и p (p &lt; n, q &lt; m), мы задачу решать уже научились. Попробуем вычислить LCS(n, m). Рассмотрим два случая:</p><ul id="38a89d94-c1ab-4124-a6f6-afcaa582f5f3" class="bulleted-list"><li style="list-style-type:disc">an = b m . Тогда LCS(n, m)=LCS(n-1, m-1)+1.</li></ul><ul id="64e005f4-3679-4cd2-aae6-8d3529fbd4a4" class="bulleted-list"><li style="list-style-type:disc">an ≠ b m . Тогда LCS(n, m)=max(LCS(n, m-1), LCS(n-1, m)). Пользуясь этими формулами, мы можем заполнить таблицу значений LCS(p, q) для всех p и q последовательно: сначала заполняем первую строчку слева направо, затем вторую и т. д. Последнее число в последней строке и будет ответом на поставленную задачу. Данный алгоритм требует порядка O(nm) операций.</li></ul><p id="5e8fe08a-6cb4-4e34-9480-257ea14f915a" class="">(в коде — задача 17 — хорошо видно это)</p><p id="4d5a7176-309d-4121-ac8a-fb7dfeab9fac" class=""><br/>Данный алгоритм требует порядка O(nm) операций.<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c6bb9d85-b0de-489c-b661-716ccc85589d" class="code"><code class="language-Python">

Задача 17:
#наибольшая возрастающая последовательность
def lcs(arr1: list[int], arr2: list[int]):
    dp = [[0] * len(arr2) for i in range (len(arr1))]
    for i in range (len(arr1)):
        for j in range (len(arr2)):
            if arr1[i] == arr2[j]:
                dp[i][j] = 1 + dp[i - 1][j - 1] #если значения совпадают, то берем по диагоняли
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) #если нет, то берем максимум из значения слева по горизонтали, сверху по вертикале.
    return dp[i][j]


a = [1, 2, 3, 4, 5, 6]
b = [2, 7, 3, 5, 2, 6]

print(lcs(a, b))  # 4</code></pre></details></li></ul><ul id="e61758c5-90d2-474e-be39-be99e0b70406" class="toggle"><li><details open=""><summary>15. Дискретная задача о рюкзаке.</summary><p id="2cb39cbb-94eb-4862-83ed-7e5fb489fc6e" class="">Задача о рюкзаке(Knapsack problem) – дано N предметов, ni(i-степень) имеет массу wi(i-степень) &gt;0 и стоимость pi(i-степень) &gt; 0. Необходимо выбрать из этих предметов такой набор, чтобы суммарная масса не превосходила заданной величины W(вместимость рюкзака), а суммарная стоимость была максимальна.</p><p id="a35c36c4-8287-4b30-b9a8-e61d2efaaf4e" class="">Задачу о рюкзаке можно решить несколькими способами:</p><ul id="e82d492a-4037-45bc-8326-babc04b31ddc" class="bulleted-list"><li style="list-style-type:disc">Перебирать все подмножества набора из N предметов. Сложность такого решения O(2^n)</li></ul><ul id="39214080-3fe9-45ba-9c5d-f568f223b01c" class="bulleted-list"><li style="list-style-type:disc">Методом Meet-in-the-middle. Сложность решения O(2^n/2 * N)</li></ul><ul id="c143aefb-7d86-4455-9ce1-5821b72acf0c" class="bulleted-list"><li style="list-style-type:disc">Метод динамического программирования. Сложность – O(NW)</li></ul><p id="7ea1f9b4-9f9c-42a1-882e-a5bd1d1f2164" class="">Для решения построим таблицу размерности N на W, где столбцы соответствуют объему рюкзака, а строки отдельным предметам. В общем случае формула для стоимости в каждой ячейке выглядит так:</p><p id="1883949d-2188-4a4f-a421-35e0d1a97d17" class="">S[i, j] = max (S[i−1, j], цена i-го предмета + S[i−1, j−вес i-го предмета]), где i — номер строки, j — столбца.</p></details></li></ul><ul id="4c2ed0dd-1668-4ec1-a67a-b7ae1551ef16" class="toggle"><li><details open=""><summary>16. Редакционное расстояние.</summary><p id="88ee4741-1922-4f24-9da5-afdd1d8aefbf" class=""><strong>Расстояние Левенштейна</strong> (редакционное расстояние или дистанция редактирования) между двумя строками в теории информации и компьютерной лингвистике – это минимальное количество операций вставки одного символа, удаление одного символа и замены одного символа на другой, необходимых для превращения одной строки в другую.</p><p id="a803a593-9293-4d00-806b-d1022dbc3df8" class="">Нахождения расстояния Левенштейна аналогично нахождению НОП для двух строк, за исключением того, что мы ищем не максимальное, а минимальное количество.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="95e339ae-4f29-4f98-a0b1-e33af0d449de" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def levenstein(s1, s2):
    dp = [[0] * len(s2) for i in range(len(s1))]

    for i in range(len(s1)):
        dp[i][0] = i
    for i in range(len(s2)):
        dp[0][i] = i

    for i in range(len(s1)):
        for j in range(len(s2)):
            if s1[i] == s2[j]: #если одинаковые, то по диагонали идем
                dp[i][j] = dp[i-1][j-1] #расстояние редакционное не меняется
            else:
                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 #рассматриваем какое нам выгоднее: сверху - замена, сбоку - удаление, 
                #по диагонали - добавление, и +1 потому что операция эта выполняется
    return dp[-1][-1]

levenstein(&#x27;cat&#x27;, &#x27;coro&#x27;)</code></pre></details></li></ul><ul id="5b4699c3-4d2a-4254-8f22-0fe638016cd3" class="toggle"><li><details open=""><summary>17. Односвязный список, двусвязный список.</summary><p id="64db1dd5-02f3-4731-8b13-f90fa7e55b3a" class=""><strong>Линейный однонаправленный список</strong> – это структура данных, состоящая из элементов одного типа, связанных между собой последовательно посредством указателей. Каждый элемент списка имеет указатель на следующий элемент. Последний элемент списка указывает на NULL. Элемент, на который нет указателя, является первым(головным) элементом списка. Здесь ссылка в каждом узле указывает на следующий узел в списке. В односвязном списке можно передвигаться только в сторону конца списка. Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно.</p><p id="fbeea6e4-629a-4d97-8d03-cdbdc255fddd" class="">В информатике линейный список обычно определяется как абстрактный тип данных(АТД), формализующий понятие упорядоченной коллекции данных. На практике линейные списки обычно реализуются при помощи массивов и связных списков.</p><p id="051e156a-909e-4046-8eca-5f695884db5a" class="">АТД нетипизированного изменяемого списка может быть определен как набор из конструктора и основных операций:</p><ul id="f50bbc15-9f68-4eab-85b6-d00d175bea6a" class="bulleted-list"><li style="list-style-type:disc">Операция, проверяющая список на пустоту.</li></ul><ul id="032e1e48-2673-44fb-8e0a-279851411675" class="bulleted-list"><li style="list-style-type:disc">Три операции добавления объекта в список (в начало, конец или внутрь после любого (n-го) элемента списка)</li></ul><ul id="aa10a164-c7db-4267-8851-a801749d4819" class="bulleted-list"><li style="list-style-type:disc">Операция, вычисляющая первый (головной) элемент списка</li></ul><ul id="2d7d539e-79bf-4af8-b911-385ad7114f65" class="bulleted-list"><li style="list-style-type:disc">Операция доступа к списку, состоящему из всех элементов исходного списка, кроме первого.</li></ul><p id="c3bf4493-1fca-4fae-b090-cef5369456e4" class=""><strong>Характеристики</strong><strong>:</strong></p><ul id="7f225202-ca20-426e-b91b-59c8c33b7096" class="bulleted-list"><li style="list-style-type:disc">Длина списка. Количество элементов в списке.</li></ul><ul id="4712dba8-7fcb-418a-95eb-561f8d68ec4c" class="bulleted-list"><li style="list-style-type:disc">Списки могут быть типизированными и нетипизированными. Если список типизирован, то тип его элементов задан, и все его элементы должны иметь типы, совместимые с заданным типом элементов списка.</li></ul><ul id="2e6b3ae6-b576-4e17-be02-a5953a835bd8" class="bulleted-list"><li style="list-style-type:disc">Список может быть сортированным или несортированным.</li></ul><ul id="5317e39e-9e28-4307-8798-0939a2ec6f77" class="bulleted-list"><li style="list-style-type:disc">В зависимости от реализации может быть возможен произвольным доступ к элементам списка</li></ul><p id="eeea649a-25a1-4add-b896-b01563eca065" class=""><strong>Двусвязный список</strong></p><p id="e1077a8d-2beb-48f3-a3f2-da21ba2d3a18" class=""><strong>Двусвязный список (двунаправленный связный список) -</strong> ссылки в каждом узле указывают на предыдущий и на последующий узел в списке. Как и односвязный список, двусвязный допускает только последовательный доступ к элементам, но при этом дает возможность перемещения в обе стороны. В этом списке проще производить удаление и перестановку элементов, так как легко доступны адреса тех элементов списка, указатели которых направлены на изменяемый элемент.</p><p id="042ec6da-0df9-4b95-ab32-b216fb1513bd" class=""><strong>Как применяют связные списки</strong><strong>:</strong></p><ul id="f3218208-8f56-4b2d-9c2f-50adcc43dcfd" class="bulleted-list"><li style="list-style-type:disc">Для построения более сложных структур данных.</li></ul><ul id="6decb8b6-ae30-47ab-8d28-dfa41c5a4cc8" class="bulleted-list"><li style="list-style-type:disc">Для реализаций файловых систем.</li></ul><ul id="a0b22178-a5c3-4f40-8ff7-b040fdcb2f28" class="bulleted-list"><li style="list-style-type:disc">Для формирования хэш-таблиц.</li></ul><ul id="2c969e39-6b74-4da0-90aa-184af20508e0" class="bulleted-list"><li style="list-style-type:disc">Для выделения памяти в динамических структурах данных.</li></ul></details></li></ul><ul id="20a6a61a-3243-4f8b-a7d4-ba6638a3f1de" class="toggle"><li><details open=""><summary>18. Стек.</summary><p id="da18cc15-eff8-49fe-bfe9-2e68208bae46" class=""><em>Стек (stack — стопка</em>) — структура данных, представляющая из себя<br/>упорядоченный набор элементов, в которой добавление новых элементов и<br/>удаление существующих производится с одного конца, называемого<br/>вершиной стека. Притом первым из стека удаляется элемент, который был<br/>помещен туда последним, то есть в стеке реализуется стратегия «последним<br/>вошел — первым вышел» (last-in, first-out — LIFO).<br/><br/><strong>Операции стека:<br/><br/></strong>● empty — проверка стека на наличие в нем элементов,<br/>● push (запись в стек) — операция вставки нового элемента,<br/>● pop (снятие со стека) — операция удаления нового элемента.<br/></p><p id="27e99cec-fcbd-44cf-b6d7-5d92a66f0442" class=""><strong>Как применяют стеки:</strong><br/>● Для реализации рекурсии.<br/>● Для вычислений постфиксных значений.<br/>● Для временного хранения данных, например истории запросов или<br/>изменений.<br/></p></details></li></ul><ul id="06449b32-5f71-4f29-b135-1e6d99a01abe" class="toggle"><li><details open=""><summary>19. Очередь.</summary><p id="bb376241-9f70-43b5-8122-ca477b689b89" class=""><em>Очередь (queue)</em> — это структура данных, добавление и удаление элементов в<br/>которой происходит путём операций push и pop соответственно. Притом первым из<br/>очереди удаляется элемент, который был помещен туда первым, то есть в очереди<br/>реализуется принцип «первым вошел — первым вышел» (first-in, first-out — FIFO). У<br/>очереди имеется голова (head) и хвост (tail). Когда элемент ставится в очередь, он<br/>занимает место в её хвосте. Из очереди всегда выводится элемент, который<br/>находится в ее голове.<br/><br/><strong>Очередь поддерживает следующие операции:<br/><br/></strong>● empty — проверка очереди на наличие в ней элементов,<br/>● push (запись в очередь) — операция вставки нового элемента,<br/>● pop (снятие с очереди) — операция удаления нового элемента,<br/>● size — операция получения количества элементов в очереди.<br/><br/><strong>Как применяют очереди:<br/><br/></strong>● Для реализации очередей, например на доступ к определённому<br/>ресурсу.<br/>● Для управления потоками в многопоточных средах.<br/>● Для генерации значений.<br/>● Для создания буферов.<br/></p></details></li></ul><ul id="fd78c2d2-a903-4fad-8978-80e5e77f5085" class="toggle"><li><details open=""><summary>20. Дек.</summary><p id="a3cf2241-6e68-49e0-91f0-244909148a90" class=""><em>Дек (deque — double ended queue)</em> — структура данных, представляющая<br/>из себя список элементов, в которой добавление новых элементов и<br/>удаление существующих производится с обоих концов. Эта структура<br/>поддерживает как FIFO, так и LIFO, поэтому на ней можно реализовать как<br/>стек, так и очередь. В первом случае нужно использовать только методы<br/>головы или хвоста, во втором — методы push и pop двух разных концов. Дек<br/>можно воспринимать как двустороннюю очередь.<br/></p><p id="7d726863-5d85-488a-b2e1-153aa894a936" class=""><strong>Дек имеет следующие операции:</strong><br/>● empty — проверка на наличие элементов,<br/>● pushBack (запись в конец) — операция вставки нового элемента в конец,<br/>● popBack (снятие с конца) — операция удаления конечного элемента,<br/>● pushFront (запись в начало) — операция вставки нового элемента в<br/>начало,<br/>● popFront (снятие с начала) — операция удаления начального элемента.<br/></p></details></li></ul><ul id="ae654468-1086-4bc9-9603-d0a62b5f58c3" class="toggle"><li><details open=""><summary>21. Куча.</summary><p id="fb8ccf24-2319-4df2-b75c-237031b1c902" class=""><em>Куча</em> — это полное двоичное дерево, удовлетворяющее свойству кучи: если<br/>узел A — это родитель узла B, то ключ узла A ≥ ключ узла B.<br/>● Если любой узел всегда больше дочернего узла (узлов), а ключ<br/>корневого узла является наибольшим среди всех остальных узлов, это<br/>max-куча.<br/>● Если любой узел всегда меньше дочернего узла (узлов), а ключ<br/>корневого узла является наименьшим среди всех остальных узлов, это<br/>min-куча.<br/></p></details></li></ul><ul id="abf731fb-d1f9-4d1a-873d-5ced0f1c417e" class="toggle"><li><details open=""><summary>22. Графы. Способы хранения: матрица смежности, списки смежности, матрица инцидентности.</summary><p id="f3f64f5d-21b2-42cc-bf07-0235ed92c7ed" class=""><strong>Граф</strong> — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер. Элемент множества рёбер есть пара элементов множества вершин.</p><p id="3f7875fd-dc82-4a96-a1af-cf2f21a717bc" class=""><strong>Виды графов</strong><strong>:</strong></p><p id="51aa7e05-0b2b-4e33-b183-71653e01a5cc" class=""><strong>Простой (неориентированный)</strong> граф G(V,E) есть совокупность двух множеств – непустого множества V и множества E неупорядоченных пар различных элементов множества V. Множество V называется множеством вершин, множество E называется множеством рёбер.</p><p id="d9b3fea6-7d34-4d9a-8d0c-d1c48e9989f9" class=""><strong>Ориентированный граф (орграф) </strong>G(V,E) есть совокупность двух множеств – непустого множества V и множества E дуг или упорядоченных пар различных элементов множества V.</p><p id="ba50e6e9-1515-4c55-9997-4e6182072b98" class=""><strong>Взвешенный граф</strong> — граф, каждому ребру которого поставлено в соответствие некое значение (вес ребра).</p><p id="e375e7e3-ed4b-47dc-9d00-c9ff27a4e19a" class="">Путь - любая последовательность вершин, в которой каждые две соседние вершины соединены ребром (A → C → B → G, A → D → B → D → B). Длина пути - количество рёбер в нём (3 и 4 соответственно для примеров выше). Цикл - путь, у которого начальная и конечная вершина совпадают (A → C → B → D → A, F → E → F). Простой путь - путь, в котором нет повторяющихся рёбер. Простой цикл - цикл, который является простым путём.</p><p id="7c043412-9987-4105-9ae0-dd7902fbb878" class=""><strong>Способы хранения графов</strong><strong>:</strong></p><p id="7d2ec8be-b4c3-48dd-b955-9fcb679e556f" class="">Матрицей смежности A=||αi,j|| невзвешенного графа G=(V,E) называется матрица A[V×V], в которой αi,j — количество рёбер, соединяющих вершины vi и vj , причём при i=j каждую петлю учитываем дважды, если граф не является ориентированным, и один раз, если граф ориентирован. Матрицей смежности A=||αi,j|| взвешенного графа G=(V,E) называется матрица A[V×V], в которой αi,j — вес ребра, соединяющего вершины vi и vj .</p><p id="b0844576-62cc-4508-afbe-4e8ada696869" class="">Матрица смежности:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="095a5e54-580e-4b07-a9ad-c1b031fa7f0b" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">class Graph(object):
 def __init__(self, size):
  self.adjMatrix = [[0] * size for i in range(size)]
  self.size = size
 def add_edge(self, v1, v2):
  if v1 == v2:
   print(f&quot;Та же вершина {v1} и {v2}&quot;)
   self.adjMatrix[v1][v2] = 1
   self.adjMatrix[v2][v1] = 1
 def __len__(self):
  return self.size
 def remove_edge(self, v1, v2):
  if self.adjMatrix[v1][v2] == 0:
   print(f&quot;Нет ребра между {v1} и {v2}&quot;)
   return
  self.adjMatrix[v1][v2] = 0
  self.adjMatrix[v2][v1] = 0
 def print_matrix(self):
  for row in self.adjMatrix:
   for val in row:
    print(f&#x27;{val:4d}&#x27;)
   print
</code></pre><p id="7521fb8d-444f-46ad-a6bb-562586c32061" class=""><strong>Плюсы матрицы смежности</strong><strong>:</strong></p><ul id="39b20102-59fc-44d2-ba4e-1fd5cf64b260" class="bulleted-list"><li style="list-style-type:disc">Добавление ребра, удаление ребра, проверка наличия ребра между вершинами i и j за O(n)</li></ul><ul id="88f366f5-2c5c-4ad5-aba2-73b4c5edaa50" class="bulleted-list"><li style="list-style-type:disc">Лучший выбор для плотных графов. В случае разреженного графа и матрицы смежности можно использовать структуры данных для разреженных матриц</li></ul><ul id="18165a19-2806-4a34-945e-7c9d07ffb713" class="bulleted-list"><li style="list-style-type:disc">Возможность выполнения операция на GPU</li></ul><p id="69573be0-e73f-40ba-8402-306347c3d838" class=""><strong>Минусы</strong><strong>:</strong></p><ul id="3bcbf768-a569-4891-82a2-febb8f80f009" class="bulleted-list"><li style="list-style-type:disc">Требуется VxV памяти для хранения. Чаще всего графы не имеют большого количества связей и лучшим выбором будут списки смежности.</li></ul><ul id="0af96825-a96d-4c6e-8f81-cb47dd27e56c" class="bulleted-list"><li style="list-style-type:disc">Выполнения операций по нахождению внешних и внутренних ребер требует большего времени.</li></ul><p id="15b55dc2-e368-4741-aebf-10555ab5cdb0" class="">
</p><p id="10a36a35-1391-411c-9717-3ee75033064a" class="">Еще один способ хранения - <strong>Списки смежности</strong></p><p id="e89107ed-dd5a-4500-8085-0b0b9dec52b2" class="">Список смежности — один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.</p><p id="90825cdd-ee95-4984-a799-a6067a8e24dc" class="">Список смежности:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="aead9668-2aa8-41a3-a22f-20055cd39da9" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">graph = {&#x27;A&#x27;: set([&#x27;B&#x27;, &#x27;C&#x27;]),
 &#x27;B&#x27;: set([&#x27;A&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]),
 &#x27;C&#x27;: set([&#x27;A&#x27;, &#x27;F&#x27;]),
 &#x27;D&#x27;: set([&#x27;B&#x27;]),
 &#x27;E&#x27;: set([&#x27;B&#x27;, &#x27;F&#x27;]),
 &#x27;F&#x27;: set([&#x27;C&#x27;, &#x27;E&#x27;])}</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d5944389-1252-48f1-8fb6-b25d30801439" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">class AdjNode:
 def __init__(self, value):
  self.vertex = value
  self.next = None
class Graph:
 def __init__(self, num):
  self.V = num
  self.graph = [None] * self.V
 def add_edge(self, s, d):
  node = AdjNode(d)
  node.next = self.graph[s]
  self.graph[s] = node
  node = AdjNode(s)
  node.next = self.graph[d]
  self.graph[d] = node

 def print_agraph(self):
  for i in range(self.V):
   print(&quot;Вершина &quot; + str(i) + &quot;:&quot;, end=&quot;&quot;)
   temp = self.graph[i]
   while temp:
    print(f&quot; -&gt; {temp.vertex}&quot;, end=&quot;&quot;)
    temp = temp.next
   print(&quot; \n&quot;)</code></pre><p id="5d291e08-5165-4f3c-a7c5-eb1296b9b575" class=""><strong>Плюсы списков смежности</strong><strong>:</strong></p><ul id="53e560ca-623f-4e92-9c25-74ee0fc02dda" class="bulleted-list"><li style="list-style-type:disc">Эффективны в плане потребления памяти, так как хранится только информация о ребрах. Для больших разреженных графов могут сберечь большой объем памяти.</li></ul><ul id="a03ad6c4-4e0f-4578-a325-d7144f08c5b7" class="bulleted-list"><li style="list-style-type:disc">Быстрый поиск смежных вершин</li></ul><p id="bbf15a74-17ee-4a7b-a9a8-b2179b61af36" class=""><strong>Минусы списков смежности</strong><strong>:</strong></p><ul id="f93c45fe-da4f-43d2-bb1d-ecb5890a359e" class="bulleted-list"><li style="list-style-type:disc">Построение списка смежности не быстрее построения матрицы смежности, так как необходимо так же проверить и найти все узлы</li></ul><p id="f2913800-ccb2-4d7e-a236-df39f5df9d19" class="">
</p><p id="446a233b-1d03-484d-915d-73f9f2d81204" class="">Еще один способ - матрица инцидентности </p><p id="b7b0af9a-5baa-4fc4-b396-71628de6869b" class=""><strong>Матрица инцидентности</strong></p><p id="fde42757-2ad4-4f06-b18c-5273afa25158" class="">Вершина v инцидентна ребру e, если v ∈ e; тогда еще говорят, что e есть ребро при v; Матрицей инцидентности (инциденций) неориентированного графа называется матрица I(|V|×|E|), для которой I i,j=1, если вершина vi инцидентна ребру ej , в противном случае I i,j=0. Матрицей инцидентности (инциденций) ориентированного графа называется матрица I(|V|×|E|), для которой I i,j=1, если вершина vi является началом дуги ej , I i,j=−1, если vi является концом дуги ej , в остальных случаях I i,j=0.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="35b9773c-268d-413c-906f-2d8b0372b7ad" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">class Graph(object):
 def __init__(self, size):
  self.incMatrix = []
  self.size = size
 def add_edge(self, v1, v2):
  if v1 == v2:
   print(f&quot;Та же вершина {v1} и {v2}&quot;)
   return
  newEdge = [1 if i == v1 or i == v2 else 0 for i in range(self.size)]
  self.incMatrix.append(newEdge)
 def __len__(self):
  return self.size
def remove_edge(self, v1, v2):
 for e in range(len(self.incMatrix)):
  if self.incMatrix[e][v1] and self.incMatrix[e][v2]:
   self.incMatrix.pop(e)
   return
 print(f&quot;Нет ребра между {v1} и {v2}&quot;)</code></pre></details></li></ul><ul id="2d04484a-8769-4803-a367-04011bb59298" class="toggle"><li><details open=""><summary>23. Поиск в глубину в неориентированных графах.</summary><p id="c75d9f28-5c13-4905-995e-4538da088db2" class=""><strong>Обход в глубину</strong> (поиск в глубину, Depth-First Search, DFS) — один из основных методов обхода графа, часто используемый для проверки связности, поиска цикла и компонент сильной связности и для топологической сортировки. Общая идея алгоритма состоит в следующем: для каждой не пройденной вершины необходимо найти все не пройденные смежные вершины и повторить поиск для них.</p><p id="6798b6bb-de32-4b05-a585-2c692f3faff1" class=""><strong>Пошаговое представление:</strong></p><ol type="1" id="3d785730-f50c-44e9-9ca3-c2030d1fcc9c" class="numbered-list" start="1"><li>Выбираем любую вершину из еще не пройденных, обозначим ее как u.</li></ol><ol type="1" id="cd953e1c-8575-4099-b543-717fbd8968c4" class="numbered-list" start="2"><li>Запускаем процедуру dfs(u):</li></ol><ol type="1" id="57ba461f-2abe-441e-904c-8955f19d6e51" class="numbered-list" start="3"><li>Помечаем вершину u как пройденную</li></ol><ol type="1" id="bb685db8-a1d1-41de-be54-6f28b83f93fb" class="numbered-list" start="4"><li>Для каждой не пройденной смежной с u вершиной (назовем ее v) запускаем dfs(v)</li></ol><ol type="1" id="5b92df2e-6472-47f3-bd23-92e8faefaee6" class="numbered-list" start="5"><li>Повторяем шаги 1 и 2, пока все вершины не окажутся пройденными.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="250a000d-a0c9-4ef1-9621-093d9ae38d5b" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">from collections import defaultdict
class Graph:
 def __init__(self):
  self.graph = defaultdict(list)
 def addEdge(self, u, v):
  self.graph[u].append(v)
 def DFSUtil(self, v, visited):
  visited.add(v)
  print(v, end=&#x27; &#x27;)
  for neighbour in self.graph[v]:
   if neighbour not in visited:
    self.DFSUtil(neighbour, visited)
 def DFS(self, v):
  visited = set()
  self.DFSUtil(v, visited)</code></pre><p id="0d1c7ee9-8f95-4a20-800f-2abab663ed94" class="">Процедура dfs вызывается от каждой вершины не более одного раза, а внутри процедуры рассматриваются все такие ребра {e | begin(e)=u}. Всего таких ребер для всех вершин в графе O(E), следовательно, время работы алгоритма оценивается как O(V+E).</p></details></li></ul><ul id="2ec1cde4-3487-44a5-bb7a-bfcdcff6a811" class="toggle"><li><details open=""><summary>24. Выделение компонент связности.</summary><p id="ee54059a-2bd4-4362-bdc1-8399884643d9" class=""><strong>Компонент связности</strong> – набор вершин графа, между любой парой которых существует путь.</p><p id="5aec8e6d-ac64-4fac-8ee2-c31b43d3ab6b" class="">Для поиска компонент связности используется обычный DFS практически без модификаций. При запуске обхода из одной вершины, он гарантированно посетит все вершины, до которых возможно добраться, то есть, всю компоненту связности, к которой принадлежит начальная вершина. Для нахождения всех компонент просто попытаемся запустить обход из каждой вершины по очереди, если мы ещё не обошли её компоненту ранее. Простейший вариант: просто заполнить список comp, где comp[i] - номер компоненты связности, к которой принадлежит вершина i.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0b379362-7e18-4e06-bb13-3a72feb5f522" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">visited = [False] ∗ n
def dfs(start):
 visited[start] = True
 for v in g[start]:
  if not visited[v]:
   dfs(v)
ncomp = 0
for i in range(n):
 if not visited[i]:
  ncomp += 1
  dfs(i)</code></pre><p id="34d3b449-6f2a-4f3c-8d7d-befe47090425" class="">Другой вариант кода:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4356f4df-9887-47b4-8fd3-f4cac4b67925" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def dfs(start, g, n):
    visited = [False] * n
    order = []
    visited[start] = True


    def dfs_rec(v):
        for v in g[start]:
            if not visited[v]:  # замыкание
                order.append(v)  # замыкание
                dfs_rec(v)
    dfs_rec(start)
    return order</code></pre></details></li></ul><ul id="bb3e7b9a-0eb7-4aa0-852e-9c38d6282f8c" class="toggle"><li><details open=""><summary>25. Поиск в глубину в ориентированных графах: ориентированные ациклические графы.</summary><p id="6df07bd4-15f1-4491-8394-7e1f93589422" class="">Ориентированный ациклический граф (направленный ациклический граф, DAG, directed acyclic graph) – орграф, в котором отсутствуют направленные циклы, но могут быть “параллельные” пути, выходящие из одного узла и разными путями приходящие в конечный узел. Направленный ациклический граф является обобщением дерева(точнее, их объединения – леса).</p><p id="38f1b698-46e6-46a9-ac15-10421a023674" class="">Направленные ациклические графы широко используется в приложениях: в компиляторах, в искусственном интеллекте (для представления искусственных нейронных сетей без обратной связи), в статистике и машинном обучении.</p><p id="610077b4-b66f-4749-b9b5-e33b5ae05a5c" class="">Нахождение цикла в орграфе:</p><ol type="1" id="bf727d9d-609a-4d41-aabd-4a0f70ff4fb3" class="numbered-list" start="1"><li>Пометить текущий узел как посещенный и добавить его индекс в стек.</li></ol><ol type="1" id="ebbd96cc-3b19-4c9d-a6b8-bc8e97a0a0c0" class="numbered-list" start="2"><li>Пройти в цикле по вершинам, выполнить рекурсивный вызов функции dfs(данный шаг необходим для гарантии, что, если граф является лесом, мы проверим все подграфы):</li></ol><p id="3729b023-c321-4b0b-aa59-de02b22762dd" class="">a. В каждом рекурсивном вызове найти все смежные вершины для данной вершины:</p><p id="3b57101c-50e4-46a9-a88b-e56ef6f3c01e" class="">i.eсли смежная вершина уже добавлена в стек, то граф циклический, возвращаем истину.</p><p id="dc380f5e-4e5c-4ccf-9d42-27667084176b" class="">ii.иначе, вызываем рекурсивную функцию для смежной вершины.</p><p id="bb663131-e965-4b8e-8d18-0ce4873722ab" class="">b. При выходе из рекурсивного вызова, удалить текущий узел из стека, чтобы показать, что он более не является частью проверяемого пути.</p><ol type="1" id="577581ad-b019-4b3d-8a20-bb05419b1f65" class="numbered-list" start="3"><li>Если какая-либо из функций возвращает истину, остановить дальнейшее выполнение и вернуть истину в качестве результата.</li></ol></details></li></ul><ul id="bb9480a2-7909-4eb7-9db7-5cafd629f3e1" class="toggle"><li><details open=""><summary>26. Топологическая сортировка вершин.</summary><p id="b24fca4c-a04c-4159-84fa-e0fd230fc440" class=""><strong>Топологическая сортировка для ориентированного ациклического графа(</strong><strong>Directed</strong> <strong>Acyclic</strong> <strong>Graphs</strong><strong>, </strong><strong>DAG</strong><strong>)</strong> – это линейное упорядочение вершин, для которого выполняется следующее условие – для каждого направленного ребра uv вершина u предшествует вершине v в упорядочении. Если граф не является DAG, то топологическая сортировка для него невозможна.</p><p id="5d83950f-0aa8-4394-91aa-56168b912715" class="">Например, топологическая сортировка приведенного графа – “5 4 2 3 1 0”. Для графа может существовать несколько топологических сортировок. Например, другая топологическая сортировка для этого же графа – “4 5 2 3 1 0”. Первая вершина в топологической сортировке – это всегда вершина без входящих ребер.</p><p id="804eebc5-72e6-4378-aca8-64f2d710e082" class=""><strong>Алгоритм Кана</strong></p><ol type="1" id="dbcef7d8-d8f3-4bf6-986d-05d9b828d0e2" class="numbered-list" start="1"><li>Вычислить количество входящих дуг для каждой вершины в графе и установить начальное значение счетчика посещенных узлов на 0.</li></ol><ol type="1" id="50e8a973-d068-4586-8bcf-9a4328c9382e" class="numbered-list" start="2"><li>Выбрать все вершины с 0 входящих дуг и поставить их все в очередь.</li></ol><ol type="1" id="802692fe-03f5-49ce-958b-8d3b3255c876" class="numbered-list" start="3"><li>Добавить одну посещенную вершину к счетчику после удаления вершины из очереди.</li></ol><ol type="1" id="9ccd323e-d5b7-4f85-b10c-b6b8946b0790" class="numbered-list" start="4"><li>Для каждой смежной вершины уменьшить число входов на 1.</li></ol><ol type="1" id="373aa7de-2e8b-4f83-a730-60cdc4698f0a" class="numbered-list" start="5"><li>Добавить вершину в очередь, если число входов любой из смежных вершин уменьшилось до 0.</li></ol><ol type="1" id="ebee01f0-5c11-4c3b-820a-a7dca4ed0bb1" class="numbered-list" start="6"><li>Пока очередь не пуста, повторять с шага 3.</li></ol><ol type="1" id="8683d995-0316-478b-b4c9-82bbc8067cf7" class="numbered-list" start="7"><li>Топологическая сортировка невозможна для графа если число посещенных узлов не равно числу вершин графа.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1ea2d9f9-313c-475b-a000-e6502adf9b5d" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def isCyclic(self):
    inDegree = [0] * self.V
    q = deque()
    visited = 0

    for u in range(self.V):
        for v in self.adj[u]:
            inDegree[v] += 1
        for u in range(self.V):
            if inDegree[u] == 0:
                q.append(u)
        while q:
            u = q.popleft()
            visited += 1
            for v in self.adj[u]:
                inDegree[v] -= 1
                if inDegree[v] == 0:
                    q.append(v)
        return visited != self.V</code></pre></details></li></ul><ul id="5d0de375-552e-4989-b54b-ea71868f6c42" class="toggle"><li><details open=""><summary>27. Нахождение кратчайших путей из одной вершины в невзвешенных графах, поиск в ширину.</summary><p id="01b3e3fa-b32f-4b4f-aed9-7efe3bb04ca8" class="">Дан невзвешенный ориентированный граф <em><em><em><em><em><em><em><em><em><em>G = (V, E)</em></em></em></em></em></em></em></em></em></em>, а также вершина <em>s</em>. Найти длину<br/>кратчайшего пути от <br/><em><em>s </em></em>до каждой из вершин графа. Длина пути — количество рёбер в нём.</p><p id="e45490b9-b03c-4f8c-a8e1-fcee6363f8ad" class=""><strong>Обход в ширину (Поиск в ширину, BFS, Breadth-first search) </strong>— один из простейших алгоритмов обхода графа, являющийся основой для многих важных алгоритмов для работы с графами.<br/>Алгоритм работает следующим образом.<br/></p><ol type="1" id="67f5ce79-7872-4a08-ae1f-af7a30fd7833" class="numbered-list" start="1"><li>Создадим массив <em><em><em><em>dist </em></em></em></em>расстояний. Изначально <em><em><em><em><em><em><em><em><em><em>dist[s] = 0</em></em></em></em></em></em></em></em></em></em> (поскольку расстояний от вершины до самой себя равно <em>0</em>) и <em><em><em><em><em><em><em><em><em><em><em><em>dist[v] = ∞ </em></em></em></em></em></em></em></em></em></em></em></em>для <em><em><em><em><em><em><em>v ≠ s</em></em></em></em></em></em></em>.</li></ol><ol type="1" id="fa2d0529-c5af-417d-9c09-fd4e9cee57b3" class="numbered-list" start="2"><li>Создадим очередь <em>q</em>. Изначально в <em>q</em> добавим вершину <em>s</em>.</li></ol><ol type="1" id="326fddd5-98e0-4dc0-a503-8d1e26d5bfd0" class="numbered-list" start="3"><li>Пока очередь <em>q</em> непуста, делаем следующее:<br/>i. Извлекаем вершину <br/><em>v</em> из очереди.<br/>ii. Рассматриваем все рёбра <br/><em>(v,u)∈E</em>. Для каждого такого ребра пытаемся сделать релаксацию: если <em>dist[v] + 1 &lt; dist[u</em>], то мы делаем присвоение <em>dist[u] = dist[v] + 1</em> и добавляем вершину <em>u</em> в очередь.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2acca5a4-298f-4ede-98b7-d2fdeeadaf9c" class="code"><code class="language-Python">def BFS(self, s):
		visited = [False] * (max(self.graph) + 1)
		queue = []
		queue.append(s)
		visited[s] = True
		while queue:
				s = queue.pop(0)
				print(s, end=&quot; &quot;)
				for i in self.graph[s]:
						if visited[i] == False:
								queue.append(i)
								visited[i] = True</code></pre><p id="2edfa9f3-8731-43db-830c-46b7023abf51" class=""><strong>Алгоритм волновой трассировки (волновой алгоритм, алгоритм Ли)</strong> — алгоритм поиска пути, алгоритм поиска кратчайшего пути на планарном графе. Принадлежит к алгоритмам, основанным на методах поиска в ширину.</p><p id="7d9d46bf-ae3c-4a8d-be0c-fb14b21a20b4" class="">Работа алгоритма включает в себя три этапа: инициализацию, распространение волны и<br/>восстановление пути.<br/></p><ul id="5402edb3-049c-4be1-9208-7653d4e6915b" class="bulleted-list"><li style="list-style-type:disc">Во время инициализации строится образ множества ячеек обрабатываемого поля, каждой ячейке приписываются атрибуты проходимости/непроходимости, запоминаются стартовая и финишная ячейки.</li></ul><ul id="edf85db7-52e0-4330-a4df-de723fd622c5" class="bulleted-list"><li style="list-style-type:disc">Далее, от стартовой ячейки порождается шаг в соседнюю ячейку, при этом проверяется, проходима ли она, и не принадлежит ли ранее меченной в пути ячейке.</li></ul><ul id="5e6971cc-b4ab-4ec6-8748-6c252595905c" class="bulleted-list"><li style="list-style-type:disc">При выполнении условий проходимости и непринадлежности её к ранее помеченным в пути ячейкам, в атрибут ячейки записывается число, равное количеству шагов от стартовой ячейки, на первом шаге это будет 1. Каждая ячейка, меченная числом шагов от стартовой ячейки, становится стартовой и из неё порождаются очередные шаги в соседние ячейки.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="39796da6-8543-43ba-838b-508cc89ee468" class="code"><code class="language-Python">from collections import deque
def lee_algorithm(matrix, start, end):
		queue = deque()
		visited = set()
		distance = {start: 0}
		prev = {}

		queue.append(start)
		visited.add(start)

		while queue:
				node = queue.popleft()
				for neighbor in get_neighbors(matrix, node):
						if neighbor not in visited:
								visited.add(neighbor)
								distance[neighbor] = distance[node] + 1
								prev[neighbor] = node
								queue.append(neighbor)
						if neighbor == end:
								return get_shortest_path(prev, start, end)
		return None


def get_neighbors(matrix, node):
		neighbors = []
		row, col = node

		if row &gt; 0 and matrix[row - 1][col] != 1:
				neighbors.append((row - 1, col))

		if row &lt; len(matrix) - 1 and \
						matrix[row + 1][col] != 1:
				neighbors.append((row + 1, col))

		if col &gt; 0 and matrix[row][col - 1] != 1:
				neighbors.append((row, col - 1))

		if col &lt; len(matrix[0]) - 1 and \
						matrix[row][col + 1] != 1:
				neighbors.append((row, col + 1))
		return neighbors


def get_shortest_path(prev, start, end):
		path = []
		node = end
	
		while node != start:
				path.append(node)
				node = prev[node]

		path.append(start)
		path.reverse()
		return path</code></pre></details></li></ul><ul id="9d2a5ac6-eb3b-4d47-a086-cda7ae39a1c8" class="toggle"><li><details open=""><summary>28. Нахождение кратчайших путей из одной вершины в графах с положительными весами.</summary><p id="5f1c8788-5aac-4589-a94e-c3c263191c64" class="">Дан взвешенный ориентированный граф <em><em><em><em><em><em>G(V, E)</em></em></em></em></em></em>, а также вершина <em>s</em>. Длина ребра <em><em><em><em><em><em><em>(u, v) </em></em></em></em></em></em></em>равна <em><em><em><em><em><em><em>w(u, v)</em></em></em></em></em></em></em>. Длины всех рёбер неотрицательные.</p><p id="3b2b9a55-2199-4bf8-93d2-eaaa8d4a4738" class="">Найти длину кратчайшего пути от <em>s</em> до каждой из вершин графа. Длина пути — сумма длин рёбер в нём.</p><p id="fd3787ac-f484-446e-9a99-dda7fd8b1489" class=""><strong>Алгоритм Дейкстры</strong></p><ol type="1" id="823e956b-6ce5-4dd5-a7e7-239eb4d16031" class="numbered-list" start="1"><li>Создать массив <em><em><em><em><em>dist</em></em></em></em></em> расстояний. Изначально <em><em><em><em><em><em><em><em>dist[s] = 0</em></em></em></em></em></em></em></em> и <em><em><em><em><em><em><em><em><em><em><em><em>dist[v] = ∞</em></em></em></em></em></em></em></em></em></em></em></em> для <em><em><em><em><em><em><em>v ≠ s</em></em></em></em></em></em></em>.</li></ol><ol type="1" id="9adf7bd5-c1d7-4b37-a37d-465eb516d23e" class="numbered-list" start="2"><li>Создать булёв массив <em><em><em><em>used</em></em></em></em>, <em><em><em><em><em>used[v] = 0 </em></em></em></em></em>для всех вершин <em><em>v </em></em>— в нём мы будем отмечать, совершалась ли релаксация из вершины.</li></ol><ol type="1" id="76d003a0-ab34-44b1-9a8d-17a6924c433d" class="numbered-list" start="3"><li>Пока существует вершина <em>v</em> такая, что <em><em><em><em><em><em><em><em><em><em><em><em>used[v] = 0 </em></em></em></em></em></em></em></em></em></em></em></em>и <em><em><em><em><em><em><em><em><em><em><em><em><em>dist[v] ≠ ∞</em></em></em></em></em></em></em></em></em></em></em></em></em>, притом, если таких вершин несколько, то <em><em>v </em></em>— вершина с минимальным <em><em><em><em><em><em><em>dist[v]</em></em></em></em></em></em></em>, делать следующее:<br/>i. Пометить, что мы совершали релаксацию из вершины <br/><em>v</em>, то есть присвоить <em><em><em><em><em><em><em><em>used[v] = 1</em></em></em></em></em></em></em></em>.<br/>ii. Рассматриваем все рёбра <br/><em><em><em><em><em><em>(v, u) ∈ E</em></em></em></em></em></em>. Для каждого ребра пытаемся сделать релаксацию: если <em><em><em><em><em><em><em><em><em><em><em><em><em><em>dist[v] + w(v, u) &lt; dist[u]</em></em></em></em></em></em></em></em></em></em></em></em></em></em>, присвоить <em><em><em><em><em><em>dist[u] = dist[v] + w(v, u)</em></em></em></em></em></em>.</li></ol><p id="9c0db0b1-91c3-4a2b-a41c-281ea6d6ada1" class="">Иными словами, алгоритм на каждом шаге находит вершину, до которой расстояние сейчас минимально и из которой ещё не была произведена релаксация, и делает её.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f33a511a-c5c4-41f6-890a-4b6c297632cc" class="code"><code class="language-Python">class Graph():
		def __init__(self, vertices):
				self.V = vertices
				self.graph = [[0] * vertices
						for _ in range(vertices)]
	
		def printSolution(self, dist):
				print(&quot;Vertex \t Distance from Source&quot;)
				for node in range(self.V):
						print(node, &quot;\t\t&quot;, dist[node])
	
		def minDistance(self, dist, sptSet):
				min = 1e7
				for v in range(self.V):
						if dist[v] &lt; min and \
										sptSet[v] == False:
						min = dist[v]
						min_index = v
				return min_index

		def dijkstra(self, src):
				dist = [1e7] * self.V
				dist[src] = 0
				sptSet = [False] * self.V
				for cout in range(self.V):
						u = self.minDistance(dist, sptSet)
						sptSet[u] = True
						for v in range(self.V):
								if (self.graph[u][v] &gt; 0 and
										sptSet[v] == False and
										dist[v] &gt; dist[u] + self.graph[u][v]):
								dist[v] = dist[u] + self.graph[u][v]
				self.printSolution(dist)</code></pre></details></li></ul><ul id="63332865-9609-47c2-ac80-a8e681d6adc9" class="toggle"><li><details open=""><summary>29. Алгоритм Дейкстры, оценка времени работы при различных реализациях очереди с приоритетами (массивом, двоичной кучей).</summary><p id="ebe22bd2-5199-4c41-8d32-bf0404a70678" class="">Искать вершину с минимальным <em><em><em><em><em>dist </em></em></em></em></em>можно гораздо быстрее, используя такую структуру данных как очередь с приоритетом. Нам нужно хранить пары <em><em>(dist, index) </em></em>и уметь делать такие операции:</p><ul id="814f023e-bea5-45d6-9f84-335a5a974e76" class="bulleted-list"><li style="list-style-type:disc">Извлечь минимум (чтобы обработать новую вершину)</li></ul><ul id="0f5b2b7a-600c-4e91-80f9-373d37f8784a" class="bulleted-list"><li style="list-style-type:disc">Удалить вершину по индексу (чтобы уменьшить <em><em><em><em><em>dist </em></em></em></em></em>до какого-то соседа)</li></ul><ul id="537e7701-9148-41e7-992f-ed57bb0b6af7" class="bulleted-list"><li style="list-style-type:disc">Добавить новую вершину (чтобы уменьшить <em><em><em><em><em>dist </em></em></em></em></em>до какого-то соседа)</li></ul><p id="7ee45ceb-3cea-49cb-b38c-d031645bd83b" class="">Для этого используют, например, кучу или сет. Удобно помимо сета хранить сам массив <em>dist</em>, который его дублирует, но хранит элементы по порядку. Тогда, чтобы заменить значение <em><em><em>(dist1, u) </em></em></em>на <em><em><em><em><em><em><em><em><em><em>(dist2, u)</em></em></em></em></em></em></em></em></em></em>, нужно удалить из сета значение <em>(dist[u], u)</em>, сделать <em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>dist[u] = dist2</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>; и добавить в сет (<em><em><em><em><em><em>dist[u], u)</em></em></em></em></em></em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7adb7596-8b86-48f5-9405-0fbe6e897f32" class="code"><code class="language-Python">import heapq

def calculate_distances(graph, starting_vertex):
		distances = {vertex: float(&#x27;inf&#x27;) for vertex in graph}
		distances[starting_vertex] = 0
		pq = [(0, starting_vertex)]
		while len(pq) &gt; 0:
				current_distance, current_vertex = heapq.heappop(pq)
				if current_distance &gt; distances[current_vertex]:
						continue
				for neighbor, weight in graph[current_vertex].items():
						distance = current_distance + weight
						if distance &lt; distances[neighbor]:
								distances[neighbor] = distance
								heapq.heappush(pq, (distance, neighbor))
		return distances</code></pre><p id="6121f293-c1ea-4fe3-a6ad-6b6d3e685333" class="">Данный алгоритм будет работать за <em><em><em><em><em><em><em><em>VO(logV)</em></em></em></em></em></em></em></em> извлечений минимума и <em><em><em><em><em><em><em><em>O(ElogV)</em></em></em></em></em></em></em></em> операций<br/>уменьшения расстояния до вершины. Поэтому алгоритм работает за <br/><em><em><em>O(ElogV)</em></em></em>.</p><p id="d5f4cdaf-b853-4318-81b2-7029da2e6dc6" class="">Заметьте, что этот алгоритм не лучше и не хуже алгоритма без сета, который работает за<br/><br/><em><em><em><em><em><em><em><em><em><em><em><em><em>O(V^2+ E)</em></em></em></em></em></em></em></em></em></em></em></em></em>. Ведь если <em><em><em><em><em><em><em><em><em><em><em>E = O(V^2) </em></em></em></em></em></em></em></em></em></em></em>(граф почти полный), то Дейкстра без сета работает быстрее, а если, наример, <em>E=O(V)</em>, то Дейкстра на сете работает быстрее</p></details></li></ul><ul id="637c5a60-a6b4-4f48-9db5-12009e662859" class="toggle"><li><details open=""><summary>30. Кратчайшие пути в ациклических ориентированных графах.</summary><p id="71a298d9-4ed8-4f67-ac4e-91a387973798" class="">Пусть дан ациклический ориентированный взвешенный граф. Требуется найти вес кратчайшего пути из <em>u</em> в <em>v</em>.<br/>Пусть <br/><em><em>d </em></em>— функция, где <em><em><em><em>d(i) </em></em></em></em>— вес кратчайшего пути из <em><em>u </em></em>в <em>i</em>. Ясно, что <em><em>d(u)</em></em> равен 0. Пусть <em><em><em><em><em><em><em>w(i, j) </em></em></em></em></em></em></em>— вес ребра из <em><em>i </em></em>в <em>j</em>. Будем обходить граф в порядке топологической сортировки. Получаем следующие соотношения:</p><figure id="ba7a56be-d33e-4e52-a73d-c86df83fd172" class="image" style="text-align:center"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled.png"><img style="width:260px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled.png"/></a></figure><p id="04276db5-ffa3-4a97-aa16-816db915a25f" class="">Так как мы обходим граф в порядке топологической сортировки, то на <em>i</em>-ом шаге всем <em><em>d(j)</em></em> (<em>j</em> такие, что существует ребро из <em>j </em>в <em>i</em>) уже присвоены оптимальные ответы, и, следовательно, <em><em>d(i) </em></em>также будет присвоен оптимальный ответ.</p><figure id="069646ab-4fee-4da5-adbe-3bb2397b4e40" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%201.png"><img style="width:852px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%201.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8d51a8ca-c6e9-47f5-bc13-396b03beecd1" class="code"><code class="language-Python">def minDist(n, w, u):
		dist = [float(&#x27;inf&#x27;)] * n
		dist[u] = 0
		p = topSort(w)  # топологическая сортировка
		for i in range(n)
				for j in range(n):
						if w[i][j] &gt; 0:
								dist[j] = min(d[j], dist[p[i]] + w[p[i]][j])</code></pre></details></li></ul><ul id="63c188c7-a277-4bd0-a918-1386b3fb7599" class="toggle"><li><details open=""><summary>31. Алгоритм Беллмана-Форда, проверка наличия цикла отрицательного веса.</summary><p id="65977e4b-e0c6-48ce-8ae8-65ddaacb1c68" class="">Для заданного взвешенного графа найти кратчайшие пути из заданной вершины до всех остальных вершин. В случае, когда в графе содержатся циклы с отрицательным суммарным весом, достижимые из , сообщить, что кратчайших путей не существует.</p><p id="8a9ae2b2-297c-4362-b794-b4c645b8c52c" class=""><strong>Алгоритм Беллмана-Форда</strong> предназначен для решения задачи поиска кратчайшего пути на графе. Для заданного ориентированного взвешенного графа алгоритм находит кратчайшие расстояния от выделенной вершины-источника до всех остальных вершин графа.</p><p id="72bbb129-0195-41e3-9b7e-67f3e272a980" class="">Алгоритм Беллмана-Форда масштабируется хуже других алгоритмов решения указанной задачи (сложность O(|V||E|) против O(|E| + |V|ln(|V|) у алгоритма Дейкстры), однако его отличительной особенностью является применимость к графам с произвольными, в том числе отрицательными, весами.</p><p id="7b1e3fb0-bec9-4f86-98b7-13722138cb7c" class="">Примеры рисунками как работает алгоритм Беллмана-Форда в лекции 8 в самом конце.</p><p id="d28ddae4-ac40-45b9-8958-2c6326e54b28" class=""><strong>Алгоритм Беллмана-Форда</strong><strong>:</strong></p><ol type="1" id="efdee947-4329-4d22-b726-2bfca79a613e" class="numbered-list" start="1"><li>Инициализация: всем вершинам присваивается предполагаемое расстояние dist[v] = бесконечность, кроме вершины-источника, для которой dist(u) = 0.</li></ol><ol type="1" id="60f4010d-155e-47f2-bc56-91dea3f388d6" class="numbered-list" start="2"><li>Релаксация множества ребер E</li></ol><ol type="1" id="01074497-9161-43c4-863c-38c181c2d408" class="numbered-list" start="3"><li>Для каждого ребра e = (v, z) принадлежащим к E, вычисляется новое предполагаемое расстояние new_dist(z) = dist(v) + w(e)</li></ol><ol type="1" id="48496678-da54-441a-8a27-a07970de2f91" class="numbered-list" start="4"><li>Если new_dist(z) &lt; dist(z), то происходит присваивание dist(z) = new_dist(z) (релаксация ребра e)</li></ol><ol type="1" id="da8f5d12-9a41-45d3-adc1-0c3c5050e0d3" class="numbered-list" start="5"><li>Алгоритм производит релаксацию всех ребер графа до тех пор, пока на очередной итерации происходит релаксация хотя бы одного ребра.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0ac359b5-32bf-4967-b10f-fd088c246441" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    def addEdge(self, u, v, w):
        self.graph.append([u, v, w])

    def printArr(self, dist):
        print(&#x27;Расстояние до стартовой&#x27;)
        for i in range(self.V):
            print(f&quot;{i}\t\t{dist[i]}&quot;)

    def BellmanFord(self, src):
        dist = [float(&quot;Inf&quot;)] * self.V
        dist[src] = 0

        for _ in range(self.V - 1):
            for u, v, w in self.graph:
                if dist[u] != float(&quot;Inf&quot;) and dist[u] + w &lt; dist[v]:
                    dist[v] = dist[u] + w

        self.printArr(dist)</code></pre><p id="f4014c90-8159-48f5-b8cc-cd6bb0d5b04b" class=""><strong>Проверка наличия цикла отрицательного веса</strong></p><p id="055ca69f-d240-4b8a-a9b3-effbdf0c3b15" class="">Алгоритм Беллмана-Форда сможет бесконечно делать релаксации среди всех вершин этого цикла и вершин, достижимых из него. Следовательно, если не ограничивать число фаз числом n-1, то алгоритм будет работать бесконечно, постоянно улучшая расстояния до этих вершин.</p><p id="067f2a90-60c4-4a16-9a6f-586fb8ff186a" class="">Отсюда мы получаем <strong>критерий наличия достижимого цикла отрицательного веса</strong>: если после n-1 фазы мы выполним еще одну фазу, и на ней произойдет хотя бы одна релаксация, то граф содержит цикл отрицательного веса, достижимый из v; в противном случае, такого цикла нет.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bd2252ab-60f6-42e4-8166-b2f91015b828" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    def addEdge(self, u, v, w):
        self.graph.append([u, v, w])

    def printArr(self, dist):
        print(&#x27;Расстояние до стартовой&#x27;)
        for i in range(self.V):
            print(f&quot;{i}\t\t{dist[i]}&quot;)
    def BellmanFord(self, src):
        dist = [float(&quot;Inf&quot;)] * self.V
        dist[src] = 0
        for _ in range(self.V - 1):
            for u, v, w in self.graph:
                if dist[u] != float(&#x27;Inf&#x27;) and dist[u] + w &lt; dist[v]:
                    dist[v] = dist[u] + w

        for u, v, w in self.graph:
            if dist[u] != float(&quot;Inf&quot;) and dist[u] + w &lt; dist[v]:
                print(&quot;Граф содержит отрицательный цикл&quot;)
                return
        self.printArr(dist)</code></pre></details></li></ul><ul id="44d09d16-1f13-443f-abce-b952f0d5cff0" class="toggle"><li><details open=""><summary>32. Кратчайшие пути между всеми парами вершин: алгоритм Флойда-Уоршелла.</summary><p id="fc31c17f-0033-4444-bc9f-7dee8df3862d" class=""><strong>Алгоритм Флойда(алгоритм Флойда-Уоршелла) –</strong> алгоритм нахождения длин кратчайших путей между всеми парами вершин во взвешенном ориентированном графе. Работает корректно, если в графе нет циклов отрицательной величины, а в случае, когда такой цикл есть, позволяет найти хотя бы один такой цикл. Алгоритм работает за O(n3) времени и использует O(n2) памяти. Разработан в 1962 году. Примеры реализации в картинках в 8 лекции с 25-29 стр.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9f4329db-353d-40ed-9274-78ac374e83aa" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def floydWarshall(graph):
    dist = list(map(lambda i: list(map(lambda j: j, i)), graph))
    for k in range(V):
        for i in range(V):
            for j in range(V):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
# V - количество вершин в графе</code></pre></details></li></ul><ul id="f9cb75fd-973f-42fb-a22d-aaaecca5a39b" class="toggle"><li><details open=""><summary>33. Минимальное покрывающее дерево: свойство разреза.</summary><p id="a9331d2a-c946-481d-ab1e-af065a826ede" class=""><strong>Остовное дерево(</strong><strong>spanning</strong> <strong>tree</strong><strong>)</strong> графа G = (V, E) – ациклический связный подграф данного связного неориентированного графа, в который входят все его вершины.</p><p id="4683af2d-74c5-4198-a89a-aca1d2612870" class=""><strong>Минимальное остовное дерево(или минимальное покрывающее дерево)</strong> в (неориентированном) связном взвешенном графе – это остовное дерево этого графа, имеющее минимальный возможный вес, где под весом дерева понимается сумма весов входящих в него ребер.</p><p id="a2afe172-202f-49fa-a195-2357b7c67cf3" class="">Пусть G/ – подграф некоторого минимального остовного дерева графа G = (V, E)</p><p id="2578ddff-86e7-4dab-b090-ce1d1ef45152" class="">Ребро (u, v) не принадлежит G/ называется <strong>безопасным(</strong><strong>sage</strong> <strong>edge</strong><strong>), </strong>если при добавлении его в G/, G/ объединяется с (u, v) также является подграфом некоторого минимального остовного дерева графа G.</p><p id="fd7f2d0e-8acc-4b62-884d-dd17b6dd2de4" class="">Разрезом(cut) неориентированного графа G = (V, E) называется разбиение V на два непересекающихся подмножества: S и T = V \ S. Обозначается как &lt;S, T&gt;</p><p id="dd753adc-082f-4c18-8e10-651ea001b2cb" class="">Ребро(u, v) принадлежит E пересекает(crosses) разрез &lt;S, T&gt;, если один из его концов принадлежит множеству S, а другой – множеству T.</p><p id="6f272b97-07ec-47a1-a30e-7d7e16c23f7c" class=""><strong>Свойство разреза</strong></p><p id="8ca8e37a-83d9-4d7f-92cb-94864bba13ed" class=""><strong>Теорема:</strong> Рассмотрим связный неориентированный взвешенный граф G = (V, E) с весовой функцией w: E -&gt; R. Пусть G/ = (V, E/) – подграф некоторого минимального остовного дерева G, &lt;S, T&gt; - разрез G, такой, что ни одно ребро из E/ не пересекает разрез, а (u, v) – ребро минимального веса среди всех ребер, пересекающих разрез &lt;S, T&gt;. Тогда ребро e = (u, v) является безопасным для G/</p><p id="6fe27d92-af47-47de-b72f-211d94736275" class=""><strong>Доказательство: </strong>Достроим E/  до некоторого минимального остовного дерева, обозначим его Tmin. Если ребро e принадлежит Tmin , то лемма доказана, поэтому рассмотрим случай, когда ребро e не принадлежит Tmin. Рассмотрим путь в Tmin  от вершины u до вершины v. Так как эти вершины принадлежат разным долям разреза, то хотя бы одно ребро пути пересекает разрез, назовем его e/ . По условию леммы w(e) &lt;= w(e/). Заменим ребро e/ в Tmin на ребро e. Полученное дерево также является минимальным остовным деревом графа G, поскольку все вершины G по-прежнему связаны и вес дерева не увеличился. Следовательно E/ принадлежит е можно дополнить до минимального остовного дерева в графе G, то есть ребро е - безопасное</p></details></li></ul><ul id="795bd2af-251f-458d-a143-bdcd2a97bb2f" class="toggle"><li><details open=""><summary>34. Минимальное покрывающее дерево: жадная стратегия.</summary><p id="1317af61-78e4-4859-a707-57ad520be610" class=""><strong>Остовное дерево(</strong><strong>spanning</strong> <strong>tree</strong><strong>)</strong> графа G = (V, E) – ациклический связный подграф данного связного неориентированного графа, в который входят все его вершины.</p><p id="0657dd14-d341-4ab6-99b3-4b8316681c8f" class=""><strong>Минимальное остовное дерево(или минимальное покрывающее дерево)</strong> в (неориентированном) связном взвешенном графе – это остовное дерево этого графа, имеющее минимальный возможный вес, где под весом дерева понимается сумма весов входящих в него ребер.</p><p id="b2c775b9-3dcf-4844-a6a1-e9e6e94d060b" class="">Минимум остовных деревьев графа G = (V, E, W) может быть найден применяя процедуру исследования ребер в порядке возрастания их весов. Другими словами, на каждом шаге выбирается новое ребро с наименьшим весом, не образующее циклов с уже выбранными ребрами. Процесс продолжается до тех пор, пока не будет выбрано |V| - 1 ребро. Такая процедура называется <strong>жадным алгоритмом.</strong></p><p id="5183237c-f632-4513-bcfe-11d2fbd1f4dc" class="">Другое пояснение: Жадная стратегия (или жадный алгоритм) - это метод решения задач, при котором на каждом шаге выбирается локально оптимальное решение с надеждой, что в итоге будет найдено глобально оптимальное решение.</p></details></li></ul><ul id="55f845ea-2924-4732-b84f-f85e2429a7b6" class="toggle"><li><details open=""><summary>35. Алгоритм Прима.</summary><p id="233d7935-6599-430d-b90a-eacf33ad36d8" class=""><strong>Остовное дерево(</strong><strong>spanning</strong> <strong>tree</strong><strong>)</strong> графа G = (V, E) – ациклический связный подграф данного связного неориентированного графа, в который входят все его вершины.</p><p id="4e774707-0b02-42eb-8990-ddeecf41dd08" class=""><strong>Минимальное остовное дерево(или минимальное покрывающее дерево)</strong> в (неориентированном) связном взвешенном графе – это остовное дерево этого графа, имеющее минимальный возможный вес, где под весом дерева понимается сумма весов входящих в него ребер.</p><p id="91f6a057-9739-42e0-b3d1-f075a7aa3554" class=""><strong>Алгоритм Прима</strong> – алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе.</p><p id="ad166af2-55c2-421c-9270-7a37a055af84" class="">Данный алгоритм похож на алгоритм Дейкстры. Будет последовательно строить поддерево F ответа в графе G, поддерживая приоритетную очередь Q из вершин G \ F, в которой ключом для вершины v является min w(uv) – вес минимального ребра из вершин F в вершины G \ F</p><p id="69fad8e6-5bd2-41bc-94ea-b410a253937d" class="">u принадлежит V(F), uv принадлежит E(G)</p><p id="254e3bd6-4c8e-4e5f-a133-664f1e3a2949" class="">Также для каждой вершины в очереди будем хранить p(v) – вершину u, на которой достигается минимум в определении ключа. Дерево F поддерживается неявно, и его ребра – это пары (v, p(u)), где v принадлежит G\{r}\ Q, а r – корень F. Изначально F пусто и значения ключей у всех вершин равны плюс бесконечности. Выберем произвольную вершину r и присвоим ее ключу значение 0. На каждом шаге будем извлекать минимальную вершину v из приоритетной очереди и релаксировать все ребра vu, такие что u принадлежит Q, выполняя при этом операцию decreaseKey над очередью и обновление p(v). Ребро (v, p(v)) при этом добавляется к ответу.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="65d1ee93-99b9-415d-9f41-024a0b210c39" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def Graph():
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]

    def printMST(self, parent):
            print(&quot;Ребро \tВес&quot;)
            for i in range(1, self.V):
                print(parent[i], &quot;-&quot;, i, &quot;\t&quot;, self.graph[i][parent[i]])

    def minKey(self, key, mstSet):
        min = float(&#x27;inf&#x27;)

        for v in range(self.V):
            if key[v] &lt; min and mstSet[v] == False:
                min = key[v]
                min_index = v

        return min_index

    def primMST(self):
        key = [float(&#x27;inf&#x27;)] * self.V
        parent = [None] * self.V
        key[0] = 0
        mstSet = [False] * self.V

        parent[0] = -1

        for count in range(self.V):
            u = self.minKey(key, mstSet)
            for v in range(self.V):
                if self.graph[u][v] &gt; 0 and mstSet[v] == False and key[v] &gt; self.graph[u][v]:
                    key[v] = self.graph[u][v]
                    parent[v] = u
        self.printMST(parent)</code></pre></details></li></ul><ul id="83a45556-1711-416b-9364-9d4ce677a110" class="toggle"><li><details open=""><summary>36. Алгоритм Краскала.</summary><p id="e9028b5f-3b11-485c-9058-371467b226bc" class=""><strong>Алгоритм Краскала(Крускала)</strong> – алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе.</p><p id="9d769707-03f1-4a3b-a7db-1f82e204a51a" class="">Хотя оба(Краскала и Прима) алгоритма работают за O(MlogN), существуют константные различия в скорости их<br/>работы. На разреженных графах (количество рёбер примерно равно количеству вершин) быстрее<br/>работает алгоритм Крускала, а на насыщенных (количество рёбер примерно равно квадрату<br/>количеству вершин) - алгоритм Прима (при использовании матрицы смежности).<br/>На практике чаще используется алгоритм Крускала.<br/></p><p id="fe9b776a-432d-4296-99bd-7b49e03f3aee" class="">Будем последовательно строить подграф F графа G (“растущий лес”), пытаясь на каждом шаге достроить F до некоторого MST. Начнем с того, что включим в F все вершины графа G. Теперь будем обходить множество E(G) в порядке неубывания весов ребер. Если очередное ребро е соединяет вершины одной компоненты связности F, то добавление его в остов приведет к возникновению цикла в этой компоненте связности. В таком случае, е не может быть включено в F. Иначе е соединяет разные компоненты связности F, тогда существует &lt;S, T&gt; разрез такой.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a299aea2-ab7c-482e-a11b-bf84331585bd" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def Graph():
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    def addEdge(self, u, v, w):
        self.graph.append([u, v, w])

    def find(self, parent, i):
        if parent[i] != i:
            parent[i] = self.find(parent, parent[i])
        return parent[i]

    def union(self, parent, rank, x, y):
        if rank[x] &lt; rank[y]:
            parent[x] = y
        elif rank[x] &gt; rank[y]:
            parent[y] = x
        else:
            parent[y] = x
            rank[x] + 1

    def KruskalMST(self):
        result = []
        i = 0
        e = 0
        self.graph = sorted(self.graph, key=lambda item: item[2])
        parent = []
        rank = []

        for node in range(self.V):
            parent.append(node)
            rank.append(0)

        while e &lt; self.V - 1:
            u, v, w = self.graph[i]
            i = i + 1
            x = self.find(parent, u)
            y = self.find(parent, v)
            if x != y:
                e = e + 1
                result.append([u, v, w])
                self.union(parent, rank, x, y)
        minimumCost = 0
        print(&#x27;Ребра в MST&#x27;)
        for u, v, weight in result:
            minimumCost += weight
            print(f&quot;{u} -- {v} == {weight}&quot;)
        print(&quot;MST&quot;, minimumCost)

</code></pre></details></li></ul><ul id="448124a1-1a36-403e-b1f7-df12a86cb71a" class="toggle"><li><details open=""><summary>37. Система непересекающихся множеств.</summary><p id="37d891c5-90b6-477f-926b-b4507c0d623d" class=""><strong>Система непересекающихся множеств (</strong><strong>disjoint</strong> <strong>или </strong><strong>union</strong><strong>-</strong><strong>find</strong> <strong>data</strong> <strong>structure</strong>) – структура данных, которая позволяет администрировать множество элементов, разбитое на непересекающиеся подмножества. Абстрактная структура данных определяется множеством трех операций:</p><p id="20f7d236-56f3-42e3-b7eb-c651a839a628" class="">{Union, Find, MakeSet}</p><ul id="96300e8a-8f50-4a22-90b9-13eb82fcafe5" class="bulleted-list"><li style="list-style-type:disc">make_set(x) – добавляет новый элемент x, помещая его в новое множество, состоящее из одного него.</li></ul><ul id="e9fc8da2-0880-4d0b-bbc2-f1a01c0a211c" class="bulleted-list"><li style="list-style-type:disc">union_sets(x, y) – объединяет два указанных множества(множество, в котором находится элемент x, и множество, в котором находится элемент y)</li></ul><ul id="522e8cfe-fcfa-4926-9ad2-4b7d2bad1fc4" class="bulleted-list"><li style="list-style-type:disc">find_set(x) – возвращает, в каком множестве находится указанный элемент x. На самом деле при этом возвращается один из элементов множества(называемый представителем или лидером. Этот представитель выбирается в каждом множестве самой структурой данных (и может меняться с течением времени, после вызовов union_sets())</li></ul><p id="901714aa-cede-4f09-bb64-e20026899f0f" class="">Например, если вызов find_set() для каких-то двух элементов вернул одно и то же значение, то это означает, что эти элементы находятся в одном и том же множестве, а в противном случае – в разных множествах.</p></details></li></ul><ul id="0b89c220-95d6-485d-a2c9-7b17fdb75aa2" class="toggle"><li><details open=""><summary>38. Представление множеств с помощью деревьев, две эвристики.</summary><p id="62c54f95-226f-42f6-b2c2-0b9b11a4c387" class=""><strong>Система непересекающихся множеств (</strong>disjoint <strong>или union-find</strong> <strong>data</strong> <strong>structure</strong>) – структура данных, которая позволяет администрировать множество элементов, разбитое на непересекающиеся подмножества.</p><p id="9b0de8ee-cb28-4696-a314-7be49dcb83b1" class="">Множества элементов будем хранить в виде деревьев: одно дерево соответствует одному множеству. Корень дерева – это представитель(лидер) множества.</p><p id="2dc956fb-7905-459b-9593-9f31742ee00a" class="">При реализации это означает, что мы заводим массив parent, в котором для каждого элемента мы храним ссылку на его предка в дереве. Для корней деревьев будем считать, что их предок – они сами. (т.е. ссылка зацикливается в этом месте)</p><p id="d269a989-36d5-4919-9be2-28aabc52c031" class=""><strong>Представление множеств с помощью деревьев. Наивная реализация.</strong></p><p id="b774b9ae-c4be-41dd-8d46-dd9101d00e59" class="">Вся информация о множествах элементов хранится с помощью массива parent.</p><p id="c06f63ed-9d31-4755-b9aa-a15a6eddfbb7" class="">Чтобы создать новый элемент (операция make_set(v)), просто создаем дерево с корнем в вершине v, отмечая, что ее предок – она сама.</p><p id="b34efea6-cc14-4ee0-a5b3-012a5c39d74e" class="">Чтобы объединить два множества(операция union_sets(a,b)), сначала найдем лидеров множества, в котором находится a, и множества, в котором находится b. Если лидеры совпали, то ничего не делаем – это значит, что множества уже были объединены. В противном случае можно указать, что предок вершины b равен a(или наоборот) – тем самым присоединив одно дерево к другому.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7c2b7aaf-6b61-4fe2-bdea-f1423c358e64" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def union(parent, rank, i, j):
    irep = find(parent, i)
    jrep = find(parent, j)
    parent[irep] = jrep</code></pre><p id="811ff2f6-8bf0-4d1e-864c-fe7c651989a7" class="">Реализация операции поиска лидера(find_set(v)) проста: поднимаемся по предкам от вершины v, пока не дойдем до корня, т.е. пока ссылка на предка не ведет в себя. Эту операцию удобнее реализовать рекурсивно.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1b7ef73e-00c0-4a0b-891d-f281028d66f4" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def find(i, parent):
    if (parent[i] == i):
        return i
    else:
        return find(parent[i], parent)</code></pre><p id="fd79bfc0-95d7-4d83-8da1-463993117778" class="">Такая реализация непересекающихся множеств весьма неэффективна. Легко построить пример, когда после нескольких объединений получится ситуация, что множество – это дерево, выродившееся в длинную цепочку. В результате каждый вызов find_set() будет работать в таком тесте за время порядка глубины дерева, т.е. за O(n)</p><p id="ea8513ea-e6b8-48b2-8535-9046a13f54b5" class=""><strong>Первая эвристика – Эвристика сжатия пути</strong></p><p id="0d24a163-7ebc-4c14-b72f-87cca5739943" class="">Эта эвристика предназначена для ускорения работы find_set().</p><p id="93fdc2ff-14e9-4e3f-81b2-7d0fe99f92c1" class="">Она заключается в том, что когда после вызова find_set(v) мы найдем искомого лидера p множества, то запомним, что у вершины  v и всех пройденных до пути вершин – именно это лидер p. Проще всего это сделать, перенаправив их parent[] на эту вершину p. Таким образом, у массива предков parent[] смысл несколько меняется: теперь это сжатый массив предков, т.е. для каждой вершины там может храниться предок предка, предок предка предка и т.д.</p><p id="741170da-6174-4de7-911a-ad6fe0d65c8b" class="">С другой стороны, нельзя сделать, чтобы эти указатели parent всегда указывали на лидера: иначе при выполнении операции union_sets() пришлось бы обновлять лидеров у O(n) элементов. Таким образом, к массиву parent[] следует подходить именно как к массиву предков, возможно, частично сжатому.</p><p id="49080fee-8935-420a-bdb2-479cd1e90002" class=""><strong>Вторая эвристика – Эвристика объединения по рангу.</strong></p><p id="2d3ff4ae-1e2c-4c83-aa82-6b5720ddfc5d" class="">Она ускоряет время работы алгоритма, а в сочетании с эвристикой сжатия путей и вовсе способна достигнуть практически константного времени работы на один запрос в среднем.</p><p id="5209d1fc-4fb5-403d-9271-c5e70065196f" class="">Эта эвристика заключается в небольшом изменении работы union_sets: если в наивной реализации то, какое дерево будет присоединено к какому, определяется случайно, то теперь мы будет делать это на основе рангов.</p><p id="4e43ab8a-01d8-4475-b6c4-4ae795f68608" class="">Два варианта ранговой эвристики: В одном варианте рангом дерева называется количество вершин в нем, а в другом – глубина дерева(точнее – верхняя глубина дерева может уменьшаться)</p><p id="28161f80-a4a7-4a6b-a6bb-8dbceeb6898e" class="">В обоих вариантах суть эвристики одна и та же: при выполнении unions_sets будем присоединять дерево с меньшим рангом к дереву с большим рангом.</p><p id="2ad0be0a-ea73-4857-bc12-8738b377a4c7" class=""><strong>Объединение эвристик</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3277d422-2b54-4842-98d9-f12aed25d7fd" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">class DisjSet:
    def __init__(self, n):
        self.rank = [1] * n
        self.parent = [i for i in range(n)]

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def Union(self, x, y):
        xset = self.find(x)
        yset = self.find(y)
        if xset == yset:
            return
        if self.rank[xset] &lt; self.rank[yset]:
            self.parent[xset] = yset
        elif self.rank[xset] &gt; self.rank[yset]:
            self.parent[xset] = xset
        else:
            self.parent[yset] = xset
            self.rank[xset] = self.rank[xset] + 1</code></pre></details></li></ul><ul id="75b1f898-eef9-4a54-8f16-f7892aa700bb" class="toggle"><li><details open=""><summary>39. Сети.</summary><p id="cdd02d95-bc73-437e-8fdb-ea13bd73535b" class=""><strong>Сеть (</strong><strong>flow</strong> <strong>network</strong><strong>)</strong> G = (V, E) представляет собой ориентированный граф, в котором каждое ребро (u, v) принадлежит E имеет положительную пропускную способность (capacity) c(u, v) &gt; 0. Если в транспортной сети выделяются две вершины: исток s и сток t</p><p id="ab7ca506-bdaf-4b27-a2da-016de4eade37" class=""><strong>Потоком(</strong><strong>flow</strong><strong>)</strong> f в G является действительная функция f: VxV -&gt; R, удовлетворяющая условия:</p><ol type="1" id="056ad1b1-819b-4b90-a751-c260de41c42b" class="numbered-list" start="1"><li>f(u,v) = -f(v, u) (антисимметричность)</li></ol><ol type="1" id="f1c677cd-0cd0-4aaa-b988-1079e8c0352e" class="numbered-list" start="2"><li>f(u,v) &lt;=c(u, u) (ограничение пропускной способности), если ребра нет, то f(u, v) = 0</li></ol><ol type="1" id="11330098-23c5-4a16-87b2-f38f1de77f48" class="numbered-list" start="3"><li>Сумма для всех v(вершин) f(u, v) = 0 для всех вершин u, кроме s и t (закон сохранения потока)</li></ol><figure id="927a7893-8b41-442d-9fcd-385c79fadeab" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%202.png"><img style="width:974px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%202.png"/></a></figure><p id="bbaec7ef-69da-4cf9-9f80-39956a64275c" class="">Первое число означает величину потока, второе – пропускную способность ребра. Отрицательные величины потока не указаны(так как они мгновенно получаются из антисиммитричности: f(u, v) = -f(v, u). Сумма входящих ребер везде(кроме источника и стока) равна сумме исходящих и на то, что в общем c(u, v) != c(v, u). Кроме того, величина потока на ребре никогда не превышает пропускную способность этого ребра. Величина потока в этом примере равна 3+2 = 5(считаем от вершины s)</p><figure id="7915c2c6-5a02-4dbd-a6bf-37372ae1598a" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%203.png"><img style="width:690px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%203.png"/></a></figure></details></li></ul><ul id="cf497b65-cea5-4c08-836a-9bd3a1f17900" class="toggle"><li><details open=""><summary>40. Максимальный поток.</summary><p id="3226e6a2-22ab-4d85-8f9d-831d00729450" class="">Весь билет “Сети” плюс это: В теории оптимизации и теории графов, <strong>задача о максимальном потоке</strong> заключается в нахождении такого потока по транспортной сети, что сумма потоков из истока, или, что то же самое, сумма потоков в сток максимальна.</p></details></li></ul><ul id="2d584a8c-8237-4de9-a509-84532e43a5d0" class="toggle"><li><details open=""><summary>41. Алгоритм Форда – Фалкерсона.</summary><p id="198091f9-492b-4165-9f89-4390958098f1" class="">Метод предназначен <strong>для распределенной системы динамического управления потоками информации в сетях связи</strong>, позволяет найти кратчайшие пути от всех узлов сети к одному общему входящему узлу</p><ol type="1" id="dcf1e1d8-9c2f-4424-9062-4a7bdb9303f4" class="numbered-list" start="1"><li>Обнуляем все потоки. Остаточная сеть изначально совпадает с исходной сетью.</li></ol><ol type="1" id="9dbdd97b-c8f0-4489-8fa1-527a2616a3d0" class="numbered-list" start="2"><li>В остаточной сети находим любой путь из источника в сток. Если такого пути нет, останавливаемся.</li></ol><ol type="1" id="f46f7957-6844-4206-88d5-5c18185ad2c3" class="numbered-list" start="3"><li>Пускаем через найденный путь(он называется увеличивающим путем или увеличивающей цепью) максимально возможный поток:</li></ol><p id="964ad1d8-c480-4051-8f2f-3baa61dbc3eb" class="">i. На найденном пути в остаточной сети ищем ребро с минимальной пропускной способностью cmin</p><p id="7f5ec7bc-18dc-4b3b-804d-e904ba4eb945" class="">ii. Для каждой ребра на найденном пути увеличиваем поток на c, а в противоположном ему – уменьшаем на cmin.</p><p id="745f0b9e-683b-48cd-b912-66fbf0d915ba" class="">iii. Модифицируем остаточную сеть. Для всех ребер на найденном пути, а также для противоположных (антипараллельных) им ребер, вычисляем новую пропускную способность. Если она стала ненулевой, добавляем ребро к остаточной сети, а если обнулилась, стираем его.</p><ol type="1" id="2d2e25c9-7840-482b-9e07-451e9f429be8" class="numbered-list" start="4"><li>Возвращаемся на шаг 2.</li></ol><p id="82554513-d1c0-4aa8-b9e2-382128b2e3c8" class="">Важно, что алгоритм не конкретизирует, какой именно путь мы ищем на шаге 2 или как мы это делаем. По этой причине алгоритм гарантированно сходится только для целых пропускных способностей, но даже для них при больших значениях пропускных способностей он может работать очень долго. Если пропускные способности вещественны, алгоритм может работать бесконечно долго, не сходясь к оптимальному решению.</p><p id="e01f3177-7c72-42a6-9229-366c36d1011a" class="">Если искать не любой путь, а кратчайший, то получится алгоритм Эдмондса-Карпа или алгоритм Диница. Эти алгоритмы сходятся для любых вещественных весов за время O(|V||E|2) и O(|V|2|E|) соответственно.</p><p id="e5826f96-f250-4e80-86de-3fa37b942690" class="">
</p><p id="913ea359-208c-4e36-8a1a-dc8edef959df" class=""><strong>Алгоритм Эдмундса-Карпа.</strong></p><p id="7a03ca2f-1fca-4b89-a67e-42eaadb947bb" class="">Зачем он здесь? Да потому что это вариант алгоритма Форда-Фалкерсона, при котором на каждом шаге выбирают кратчайший дополняющий путь из s в t в остаточной сети(полагая, что каждое ребро имеет единичную длину). Кратчайший путь находится поиском в ширину, то есть BFS (пример алгоритма Эдмунда-Карпа на картинках вы можете посмотреть в 10 лекции на 9 и 10 страницах)</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b4d02313-c225-47aa-98d8-a8ea5ae54f42" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">from collections import defaultdict
class Graph:
    def __init__(self, graph):
        self.graph = graph
        self.ROW = len(graph)

    def BFS(self, s, t, parent):
        visited = [False] * self.ROW
        queue = []

        queue.append(s)
        visited[s] = True

        while queue: u = queue.pop(0)
        for ind, val in enumerate(self.graph[u]):
            if visited[ind] == False and val &gt; 0:
                queue.append(ind)
                visited[ind] = True
                parent[ind] = u
                if ind == t:
                    return True
        return False

    def FordFulkerson(self, source, sink):
        parent = [-1]*(self.ROW)
        max_flow = 0

        while self.BFS(source, sink, parent):
            path_flow = float(&#x27;Inf&#x27;)
            s = sink
            while s != source:
                path_flow = min(path_flow, self.graph[parent[s][s]])
                s = parent(s)
            max_flow += path_flow
            v = sink
            while v != source:
                u = parent[v]
                self.graph[u][v] -= path_flow
                self.graph[v][u] += path_flow
                v = parent[v]
        return max_flow</code></pre></details></li></ul><ul id="50dc434c-7061-4717-b0e2-2fb06cef7649" class="toggle"><li><details open=""><summary>42. Деревья. Бинарные деревья.</summary><p id="af896e51-4023-47ad-8fab-93c05b7031b4" class=""><strong>Дерево</strong> — это связный ациклический граф. Связность означает наличие маршрута между любой парой вершин, ацикличность — отсутствие циклов. Отсюда, в частности, следует, что число рёбер в дереве на единицу меньше числа вершин, а между любыми парами вершин имеется один и только один путь.</p><p id="e4b87aad-97dc-48cb-b55a-248818a22585" class=""><strong>Ориентированное (направленное) дерево</strong> — ацикличный орграф, в котором только одна вершина имеет нулевую степень захода (в неё не ведут дуги), а все остальные вершины имеют степень захода 1 (в них ведёт ровно по одной дуге). Вершина с нулевой степенью захода называется корнем дерева, вершины с нулевой степенью исхода (из которых не исходит ни одна дуга) называются концевыми вершинами или листьями.</p><p id="c82a0107-f90d-42a7-937c-14d90ee63db1" class=""><strong>Двоичное дерево (Бинарное дерево)</strong> — иерархическая структура данных, в которой каждый узел имеет не более двух потомков (детей). Как правило, первый называется родительским узлом, а дети называются левым и правым наследниками. Двоичное дерево является упорядоченным ориентированным деревом. Для практических целей обычно используют два подвида двоичных деревьев — двоичное дерево поиска и двоичная куча.</p><p id="93b1d2aa-386c-42f2-b535-97a7fb5ea482" class=""><strong>Бинарные деревья. Представление в виде списка.</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="54c37635-ef37-4458-8113-6d8aa0f48f97" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">tree = [None] * 10
def root(key):
    if tree[0] != None:
        print(&#x27;Дерево уже содержит корень&#x27;)
    else:
        tree[0] = key

def set_left(key, parent):
    if tree[parent] == None:
        print(&#x27;Невозможно установить потомка в&#x27;, (parent * 2) + 1, &#x27;,родитель не найден&#x27;)
    else:
        tree[(parent * 2) + 1] = key

def set_right(key_parent):
    if tree[parent] = None:
        print(&#x27;Невозможно установить потомка в&#x27;, (parent * 2) + 2), &#x27;,родитель не найден&#x27;
    else:
        tree[(parent * 2) + 2] = key
</code></pre><p id="f246e2e1-28f2-47e2-a902-0cd17a19feaf" class=""><strong>Динамическое представление узлов бинарного дерева</strong></p><p id="a0597ee3-e2fb-4a32-8b0f-924c734b0325" class="">Каждый узел дерева содержит следующую информацию:</p><ul id="d705788f-2cfa-446c-8140-b501e945abd0" class="bulleted-list"><li style="list-style-type:disc">Данные</li></ul><ul id="c2398804-b4a4-4a9f-9da4-8007a9606d69" class="bulleted-list"><li style="list-style-type:disc">Указатель на левого потомка</li></ul><ul id="c4ffecc9-f804-4933-8ba6-d611b8295694" class="bulleted-list"><li style="list-style-type:disc">Указатель на правого потомка</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e4613f01-49ba-4638-862e-11a32536f470" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.data = key</code></pre><p id="9697ea23-fdd7-481c-87a5-380d9c3e2688" class=""><strong>Основные операции с бинарным деревом:</strong></p><ul id="5065e7c9-c663-4300-bf4f-a7f35b2f4573" class="bulleted-list"><li style="list-style-type:disc">Вставка элемента</li></ul><ul id="bddc9e99-9ecd-415f-b82f-3881912c213c" class="bulleted-list"><li style="list-style-type:disc">Удаление элемента</li></ul><ul id="db8fdcd9-b780-470e-90a6-b3c0def1199f" class="bulleted-list"><li style="list-style-type:disc">Поиск элемента</li></ul><ul id="4c9baf41-7160-4d44-9080-0bfb96de222a" class="bulleted-list"><li style="list-style-type:disc">Удаление элемента по значению</li></ul><ul id="1331b088-2faf-4ad7-aae7-16d76543bdeb" class="bulleted-list"><li style="list-style-type:disc">Обход дерева</li></ul><p id="94ecf004-fec7-462e-abb7-519c9082a49d" class="">Дополнительные операции с бинарным деревом:</p><ul id="1a103a33-6245-47f4-a412-14e3919c45fe" class="bulleted-list"><li style="list-style-type:disc">Нахождение высоты дерева</li></ul><ul id="e372e903-4aff-4443-8ccb-f061b3df0adf" class="bulleted-list"><li style="list-style-type:disc">Нахождение слоя дерева</li></ul><ul id="662f8721-f147-4615-9966-925d5d0399b3" class="bulleted-list"><li style="list-style-type:disc">Нахождение размера дерева</li></ul><p id="d3af5cd6-aa63-44b3-a45e-e31d5ca29a7d" class=""><strong>Применение бинарных деревьев</strong><strong>:</strong></p><ul id="c11df3df-f468-4d7e-9a87-46fc181ec62b" class="bulleted-list"><li style="list-style-type:disc">В компиляторах, в частности для выполнения арифметических выражений</li></ul><ul id="cf2ccfd6-6f2d-43fa-960f-a540898c0f4c" class="bulleted-list"><li style="list-style-type:disc">Деревья кодирования Хаффмана в алгоритмах сжатия</li></ul><ul id="ae1cdbc8-5dab-494a-928d-fabe17a863ad" class="bulleted-list"><li style="list-style-type:disc">Очереди с приоритетом</li></ul><ul id="09dc9d28-e3f1-4ce8-a811-18be1543d745" class="bulleted-list"><li style="list-style-type:disc">Представления иерархических данных</li></ul><ul id="76a0ea0a-6359-46a3-97ac-290be0212f03" class="bulleted-list"><li style="list-style-type:disc">В табличных редакторах</li></ul><ul id="8fb7d6cf-5f47-4b87-a82e-ea4241945e09" class="bulleted-list"><li style="list-style-type:disc">Для индексирования баз данных и кэша</li></ul><ul id="b0f1f4e2-ba3e-46b4-b894-32ede0d7043f" class="bulleted-list"><li style="list-style-type:disc">Для быстрого поиска</li></ul><ul id="888a6596-50e0-4577-8ea9-a4ea1a752ace" class="bulleted-list"><li style="list-style-type:disc">Выделения памяти в компьютерах</li></ul><ul id="e6c86452-a610-4769-8903-11e18954b24a" class="bulleted-list"><li style="list-style-type:disc">Операций кодирования и декодирования</li></ul><ul id="22b07215-d53f-470c-9e81-ffd510af3c06" class="bulleted-list"><li style="list-style-type:disc">Для получения и организации информации из больших объемов данных</li></ul><ul id="98937032-8d85-4808-9720-6fd3f3bbbf50" class="bulleted-list"><li style="list-style-type:disc">В моделях принятия решений</li></ul><ul id="90afb398-0d37-4108-a521-e84dfca7219a" class="bulleted-list"><li style="list-style-type:disc">В алгоритмах сортировки</li></ul><p id="ac1065c9-d215-452d-968d-f547001b297e" class=""><strong>Обход бинарных деревьев</strong></p><p id="b4f48a11-eba5-4246-9d6b-9505f24c5f9f" class="">Обход осуществляется на основе двух алгоритмов: BFS, DFS</p><p id="4e4587b1-6869-46de-b305-66de5d9e38d7" class="">Обход дерева с использованием поиска в глубину(DFS) может быть разбит на 3 вида:</p><ul id="ecdd3673-ed5e-44e1-a12b-c51924f86b51" class="bulleted-list"><li style="list-style-type:disc"><strong>Прямой обход(</strong><strong>NLR</strong><strong>)</strong></li></ul><ol type="1" id="c52fe4a4-b264-4e4b-8ca5-d8c880f95c4e" class="numbered-list" start="1"><li>Проверяем, не является ли текущий узел пустым или None</li></ol><ol type="1" id="ec249b6b-0673-4bba-99e8-164cf45e1217" class="numbered-list" start="2"><li>Показываем поле данных корня(или текущего узла)</li></ol><ol type="1" id="7c465795-59a6-4480-aac3-60d3cf18ad08" class="numbered-list" start="3"><li>Обходим левое поддерево рекурсивно, вызвав функцию прямого обхода</li></ol><ol type="1" id="118b55d7-ab16-4621-8c74-94604f10bd48" class="numbered-list" start="4"><li>Обходим правое поддерево рекурсивно, вызвав функцию прямого обхода.</li></ol><ul id="03e5eb28-f84e-4e43-a998-873d4c895657" class="bulleted-list"><li style="list-style-type:disc"><strong>Центрированный обход(</strong><strong>LNR</strong><strong>)</strong></li></ul><ol type="1" id="62d234b0-c24e-4d01-9294-4e15e757b051" class="numbered-list" start="1"><li>Проверяем, не является ли текущий узел пустым или None</li></ol><ol type="1" id="f404bb04-cec4-442a-b2d5-743aa2e84629" class="numbered-list" start="2"><li>Обходим левое поддерево рекурсивно, вызвав функцию центрированного обхода</li></ol><ol type="1" id="d9e309c2-2f48-4a13-ae76-2e169998040c" class="numbered-list" start="3"><li>Показываем поле данных корня(или текущего узла)</li></ol><ol type="1" id="ee1315cd-e270-4281-9a05-a5183914a3f1" class="numbered-list" start="4"><li>Обходим правое поддерево рекурсивно, вызвав функцию центрированного обхода</li></ol><ul id="211518aa-a3ae-48a4-a95c-bb7b94eb9be5" class="bulleted-list"><li style="list-style-type:disc"><strong>Обратный обход(</strong><strong>LRN</strong><strong>)</strong></li></ul><ol type="1" id="26b82a2a-a2be-43b8-8882-9ee0abb145c2" class="numbered-list" start="1"><li>Проверяем, не является ли текущий узел пустым или None</li></ol><ol type="1" id="e94b27f5-d5c8-43d3-8920-f6e194c15e80" class="numbered-list" start="2"><li>Обходим левое поддерево рекурсивно, вызвав функцию обратного обхода</li></ol><ol type="1" id="d45c6947-57aa-457f-9b2f-ea43f39da5f9" class="numbered-list" start="3"><li>Обходим правое поддерево рекурсивно, вызвав функцию обратного обхода</li></ol><ol type="1" id="5c3d0978-e3eb-4a87-9391-ba12386f924c" class="numbered-list" start="4"><li>Показываем поле данных корня(или текущего узла)</li></ol><p id="8bb2ffb4-161b-45a9-a2b9-9f66bc879254" class="">
</p><p id="db6539c0-18cf-434b-a9e0-24e999594e56" class="">При обходе поиском в ширину (BFS) посещаются все узлы в порядке уровней, где сначала посещается каждый узел на уровне, прежде чем выполнить переход на следующий уровень.</p><p id="6afc5ac8-65bb-4d94-a396-9ed43372adc3" class=""><strong>Прямой обход</strong><strong>:</strong> 1-2-4-3-6-7</p><p id="b20292f8-0a0f-4d08-a44e-a93d3aefd39c" class=""><strong>Центрированный обход</strong>: 4-2-5-1-6-3-7</p><p id="de83a1af-df01-4061-b956-9eb4e53eabef" class=""><strong>Обратный обход</strong>: 4-5-2-6-7-3-1</p><p id="f17a79c7-9282-4e9c-8212-91775847ed9d" class=""><strong>Уровневый порядок обхода</strong>: 1-2-3-4-5-6-7</p><figure id="fc4af261-0082-4904-abb8-74a55d3aa7cc" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%204.png"><img style="width:847px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%204.png"/></a></figure><p id="3d69b3de-a0d1-4e07-ab78-71f1779a9cf6" class="">
</p></details></li></ul><ul id="998f2c55-2a9e-40f8-81b3-ff67f82f9e14" class="toggle"><li><details open=""><summary>43. Деревья поиска.</summary><p id="da490ff5-e415-4fac-99cf-5ffcb8580c14" class=""><strong>Бинарное дерево поиска (binary search tree, BST)</strong> — структура данных для работы с упорядоченными множествами</p><p id="9255dd2b-47f1-43a5-b8ab-f8911dab538b" class="">Бинарное дерево поиска обладает следующим свойством: если x – узел бинарного дерева с ключом k, то все узлы в левом поддереве должны иметь ключи меньше k, а в правом больше k.</p><p id="7f78cc09-6314-4803-ad8a-d5d063b1b290" class="">Основным преимуществом двоичного дерева поиска перед другими структурами данных является возможная высокая эффективность реализации основанных на нем алгоритмов поиска и сортировки.</p><p id="91f588ea-8f64-4092-9792-b47db5d4fc4c" class=""><strong>Применение бинарных деревьев поиска</strong><strong>:</strong></p><ul id="14c3768f-85d2-4864-a795-ab660450b635" class="bulleted-list"><li style="list-style-type:disc">Для индексации</li></ul><ul id="26bcbe88-5d07-4dee-83aa-a8a78f3af059" class="bulleted-list"><li style="list-style-type:disc">Для реализации алгоритмов поиска</li></ul><ul id="9eb9c344-4c4f-447a-a856-4e9c406033ea" class="bulleted-list"><li style="list-style-type:disc">Для реализации других структур данных</li></ul><ul id="4e53544d-ba0f-4c67-a8b1-c838765ddccf" class="bulleted-list"><li style="list-style-type:disc">Как часть систем принятия решения, компьютерных симуляций для хранения и быстрого доступа к данным</li></ul><ul id="318168c4-9944-48d4-97e4-aae2b038417a" class="bulleted-list"><li style="list-style-type:disc">Для реализации систем автодополнения и проверки орфографии.</li></ul><p id="19be4c90-0c3c-43b1-9a44-13fc6fc0f9b7" class=""><strong>Преимущества</strong><strong>:</strong></p><ul id="a80a491a-1c9f-4a0e-af68-2487a0a2b1f8" class="bulleted-list"><li style="list-style-type:disc">Высокая скорость вставки и удаления на сбалансированном дереве (O(logn))</li></ul><ul id="a01a1e8b-355c-4754-81c6-6d8c633d8e6a" class="bulleted-list"><li style="list-style-type:disc">Высокая скорость поиска (O(logn))</li></ul><ul id="13abdcc1-98d4-4921-b848-a66cf5f168a3" class="bulleted-list"><li style="list-style-type:disc">Эффективное использование памяти</li></ul><ul id="1f838726-11fa-467a-856d-7e901e7bc79b" class="bulleted-list"><li style="list-style-type:disc">Позволяют искать значения из диапазона</li></ul><ul id="5fe41e8f-a7c5-45fb-a585-7a7c38cb493f" class="bulleted-list"><li style="list-style-type:disc">Простая реализация</li></ul><ul id="416706a3-8456-4c85-96dd-2fe2ae3a74ae" class="bulleted-list"><li style="list-style-type:disc">Автоматическая сортировка элементов при добавлении</li></ul><p id="2f941be9-e74c-45de-bcd7-ca4d5a6baeeb" class=""><strong>Недостатки</strong><strong>:</strong></p><ul id="90c575ac-081b-4265-b693-14e8946e18e8" class="bulleted-list"><li style="list-style-type:disc">Всегда необходимо реализовывать сбалансированное бинарное дерево поиска, иначе дерево может выродиться в список, что увеличивает время выполнения операций.</li></ul><ul id="498f6011-0510-4189-8852-4cef1ca2ef45" class="bulleted-list"><li style="list-style-type:disc">Плохо подходят для случайного доступа к элементам.</li></ul><ul id="0ce3278d-0014-4516-bf74-2a3e740e9c3e" class="bulleted-list"><li style="list-style-type:disc">Не поддерживают некоторые операции.</li></ul></details></li></ul><ul id="433615af-3f5a-44ac-b128-e8bc435752e5" class="toggle"><li><details open=""><summary>44. Красно-чёрные деревья.</summary><p id="a415b33f-5650-446f-81ca-1b1a1809c8ff" class=""><strong>Бинарное дерево поиска (binary search tree, BST)</strong> — структура данных для работы с упорядоченными множествами</p><p id="cf396dd4-45f0-47fd-899c-2d48cd4f7727" class="">Бинарное дерево поиска обладает следующим свойством: если x – узел бинарного дерева с ключом k, то все узлы в левом поддереве должны иметь ключи меньше k, а в правом больше k.</p><p id="a06d09c9-eeaf-42bb-8465-a702fb7f86cb" class="">Основным преимуществом двоичного дерева поиска перед другими структурами данных является возможная высокая эффективность реализации основанных на нем алгоритмов поиска и сортировки.</p><p id="cfd55df5-b545-42ec-9a1d-20d2ac6a6a7b" class=""><strong>Красно-чёрное дерево (англ. red-black tree) </strong>— двоичное дерево поиска, в котором баланс осуществляется на основе &quot;цвета&quot; узла дерева, который принимает только два значения: &quot;красный&quot; (англ. red) и &quot;чёрный&quot; (англ. black).</p><p id="bac8f983-c95d-4179-a343-c5e9d389af3f" class="">При этом все листья дерева являются фиктивными и не содержат данных, но относятся к дереву и являются чёрными.</p><p id="d465d029-4ced-41c6-bfd4-f93b667095c1" class="">Для экономии памяти фиктивные листья можно сделать одним общим фиктивным листом.</p><p id="81c8e75f-9d65-46c4-a020-555787f0d0dc" class="">Красно-черным называется бинарное поисковое дерево, у которого каждому узлу сопоставлен дополнительный атрибут – цвет и для которого выполняются следующие свойства:</p><ol type="1" id="8fda60bd-8049-4135-abda-475e64f73cc4" class="numbered-list" start="1"><li>Каждый узел промаркирован красным или черным цветом</li></ol><ol type="1" id="f65ef2ff-f12e-4afe-b881-63a6a0e21d76" class="numbered-list" start="2"><li>Корень и конечные узлы(листья) дерева – черные</li></ol><ol type="1" id="07b78ee0-e559-4acd-8886-93309a6cf3da" class="numbered-list" start="3"><li>У красного узла родительский узел – черный</li></ol><ol type="1" id="f40dc852-9b41-4855-b11b-e3e7d023a8b4" class="numbered-list" start="4"><li>Все простые пути из любого узла х до листьев содержат одинаковое количество черных узлов</li></ol><ol type="1" id="8a64bf4b-6e6f-4896-84f7-cd04ac4319d9" class="numbered-list" start="5"><li>Черный узел может иметь черного родителя</li></ol><p id="4633f665-b55d-4bc3-ba03-a1d0c1ae8ed8" class=""><strong>Вставка элемента в красно-черных деревьях</strong></p><p id="49bf5d96-c684-4a58-aac4-1f3507727a48" class="">Каждый элемент вставляется вместо листа, поэтому для выбора места вставки идём от корня до тех пор, пока указатель на следующего сына не станет None (то есть этот сын — лист). Вставляем вместо него новый элемент с нулевыми потомками и красным цветом. Теперь проверяем балансировку. Если отец нового элемента черный, то никакое из свойств дерева не нарушено. Если же он красный, то нарушается свойство 3, для исправления достаточно рассмотреть два случая:</p><ol type="1" id="d4ef108e-9244-4bfb-a861-dad5c3bcbdec" class="numbered-list" start="1"><li>“Дядя” этого узла тоже красный. Тогда, чтобы сохранить свойства 3 и 4, просто перекрашиваем “отца” в “дядю” в черный цвет, а “деда” – в красный. В таком случае черная высота в этом поддереве одинакова для всех листьев и у всех красных вершин “отцы” черные. Проверяем, не нарушена ли балансировка. Если в результате этих перекрашиваний мы дойдем до корня, то в нем в любом случае ставим черный цвет, чтобы дерево удовлетворяло свойству 2.</li></ol><figure id="4be339ff-1964-4194-b222-b77437397119" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%205.png"><img style="width:518px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%205.png"/></a></figure><ol type="1" id="bb348bca-d84f-4e17-b26e-a76375741d9b" class="numbered-list" start="2"><li>“Дядя” черный. Если выполнить только перекрашивание, то может нарушиться постоянство черной высоты дерева по всем ветвям. Поэтому выполняем поворот. Если добавляемый узел был правым потомком, то необходимо сначала выполнить левое вращение, которое сделает его левым потомком. Таким образом, свойство 3 и постоянство черной высоты сохраняются.</li></ol><figure id="18a17b3a-0209-470e-969c-ec7f22cb6b0d" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%206.png"><img style="width:467px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%206.png"/></a></figure><p id="40b5acd7-ee3c-4817-a342-f167128352ec" class=""><strong>Удаление вершины</strong></p><p id="b030740e-0452-4181-a9bb-4a2bbe3f1c29" class="">При удалении вершины могут возникнуть три случая в зависимости от количества её детей:</p><ol type="1" id="4db0aea7-73d7-4f3b-b250-3e5c0fc5f34a" class="numbered-list" start="1"><li>Если у вершины нет детей, то изменяем указатель на неё у родителя на None .</li></ol><ol type="1" id="0d1f73b4-bb3a-44ba-a37f-120a5245be38" class="numbered-list" start="2"><li>Если у неё только один ребёнок, то делаем у родителя ссылку на него вместо этой вершины.</li></ol><ol type="1" id="f6127305-cfee-4b8b-afa2-e90b8f00906f" class="numbered-list" start="3"><li>Если же имеются оба ребёнка, то находим вершину со следующим значением ключа. У такой вершины нет левого ребёнка (так как такая вершина находится в правом поддереве исходной вершины и она самая левая в нем, иначе бы мы взяли ее левого ребенка. Иными словами сначала мы переходим в правое поддерево, а после спускаемся вниз в левое до тех пор, пока у вершины есть левый ребенок). Удаляем уже эту вершину описанным во втором пункте способом, скопировав её ключ в изначальную вершину.</li></ol><p id="a549b2a4-b609-4d2c-a69a-a07b5039e130" class="">Проверим балансировку дерева. Так как при удалении красной вершины свойства дерева не нарушаются, то восстановление балансировки потребуется только при удалении чёрной. Рассмотрим ребёнка удалённой вершины.</p><p id="c2475cdd-377a-45d6-b824-4b5518cbdd1c" class="">Если брат этого ребенка красный, то делаем вращение вокруг ребра между отцом и братом, тогда брат становится родителем отца. Красим его в черный, а отца – в красный цвет, сохраняя таким образом черную высоту дерева. Хотя все пути по-прежнему содержат одинаковое количество черных узлов, сейчас х имеет черного брата и красного отца. Таким образом, можно перейти к следующему шагу</p><figure id="6e7737c5-4a03-44a7-b356-7c5731b6f394" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%207.png"><img style="width:1027px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%207.png"/></a></figure><p id="f88102aa-daf9-4fd9-a67e-773df3c2b021" class="">Оба ребёнка у брата чёрные. Красим брата в красный цвет и рассматриваем далее отца вершины. Делаем его черным, это не повлияет на количество чёрных узлов на путях, проходящих через b, но добавит один к числу чёрных узлов на путях, проходящих через x, восстанавливая тем самым влияние удаленного чёрного узла. Таким образом, после удаления вершины черная глубина от отца этой вершины до всех листьев в этом поддереве будет одинаковой.</p><figure id="ee5402fb-291b-49ac-a159-48b8608d7929" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%208.png"><img style="width:1012px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%208.png"/></a></figure><p id="01f7bb0d-9aca-4c1b-99da-3306e28f38fa" class="">Если у брата правый ребёнок чёрный, а левый красный, то перекрашиваем брата и его левого сына и делаем вращение. Все пути по-прежнему содержат одинаковое количество чёрных узлов, но теперь у x есть чёрный брат с красным правым потомком, и мы переходим к следующему случаю. Ни x, ни его отец не влияют на эту трансформацию.</p><figure id="c1b03678-868c-4402-a429-8876cefcc08d" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%209.png"><img style="width:868px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%209.png"/></a></figure><p id="85c03c99-ac44-4933-bbfe-121549245e2e" class="">Если у брата правый ребёнок красный, то перекрашиваем брата в цвет отца, его ребёнка и отца — в чёрный, делаем вращение. Поддерево по-прежнему имеет тот же цвет корня, поэтому свойство 3 и 4 не нарушаются. Но у x теперь появился дополнительный чёрный предок: либо a стал чёрным, или он и был чёрным и b был добавлен в качестве чёрного дедушки. Таким образом, проходящие через x пути проходят через один дополнительный чёрный узел. Выходим из алгоритма.</p><figure id="a0a0809e-1742-4cfa-afb3-e27eeb4cdfe6" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2010.png"><img style="width:1184px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2010.png"/></a></figure><p id="b98e13ed-d73f-42fc-986f-38866865850d" class=""><strong>Преимущества красно-черных деревьев</strong>:</p><ol type="1" id="25cd81d6-8959-4a0f-a47c-81260f15157b" class="numbered-list" start="1"><li>Самое главное преимущество красно-черных деревьев в том, что при вставке выполняется не более O(1) вращений.</li></ol><ol type="1" id="6d730673-7ce0-4571-b87d-fd5f26f24a2b" class="numbered-list" start="2"><li>Процедуру балансировки практически всегда можно выполнять параллельно с процедурами поиска, так как алгоритм поиска не зависит от атрибута цвета узлов.</li></ol><ol type="1" id="cc52b0fa-6f5b-4a09-bae2-e31dac6de4a9" class="numbered-list" start="3"><li>Сбалансированность этих деревьев хуже, чем у АВЛ, но работа по поддержанию сбалансированности в красно-черных деревьях обычно эффективнее. Для балансировки красно-черного дерева производится минимальная работа по сравнению с АВЛ-деревьями.</li></ol><ol type="1" id="1b4eb2e9-98a2-4efc-8f56-ceae710b5e4b" class="numbered-list" start="4"><li>Использует всего 1 бит дополнительной памяти для хранения цвета вершины.</li></ol><p id="bfcee6bf-2456-4c42-91bb-a9ceef87e1e4" class="">Красно-чёрные деревья являются наиболее активно используемыми на практике самобалансирующимися деревьями поиска. В частности, ассоциативные контейнеры библиотеки STL(map, set, multiset, multimap) основаны на красно-чёрных деревьях. TreeMap в Java тоже реализован на основе красно-чёрных деревьев</p></details></li></ul><ul id="a2eb7037-3dda-4dad-8e20-9653eaab0d08" class="toggle"><li><details open=""><summary>45. AVL-деревья.</summary><p id="f57f9de0-ab87-4500-b7cc-2b7ab8eebb9b" class=""><strong>Бинарное дерево поиска (binary search tree, BST)</strong> — структура данных для работы с упорядоченными множествами</p><p id="fe8d626f-e41e-4b86-9eb3-b3fe56d65049" class="">Бинарное дерево поиска обладает следующим свойством: если x – узел бинарного дерева с ключом k, то все узлы в левом поддереве должны иметь ключи меньше k, а в правом больше k.</p><p id="2f8265a2-dc54-4a45-beba-37bca1021b4b" class="">Основным преимуществом двоичного дерева поиска перед другими структурами данных является возможная высокая эффективность реализации основанных на нем алгоритмов поиска и сортировки.</p><p id="ce8f6cd2-57e6-45d0-b5b3-9840de7adcb1" class=""><strong>АВЛ-дерево (англ. AVL-Tree)</strong> — сбалансированное двоичное дерево поиска, в котором поддерживается следующее свойство: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.</p><p id="7bff1fcd-fcc4-4889-b4b9-2da172d6f4de" class="">АВЛ-деревья названы по первым буквам фамилий их изобретателей, Г. М. Адельсона-Вельского и Е. М. Ландиса, которые впервые предложили использовать АВЛ-деревья в 1962 году</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0764b5f8-6808-47d6-9a1f-6f6ae4424495" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
        self.height = 1</code></pre><p id="7ea9ab02-dc66-45a2-9a45-a2625b986d88" class="">Балансировкой вершины называется операция, которая в случае разницы высот левого и правого поддеревьев  |h(L) – h(R)| = 2, изменяет связи предок-потомок в поддереве данной вершины так, чтобы восстановилось свойство дерева |h(L) – h(R)| &lt;= 1, иначе ничего не меняет. Для балансировки будем хранить для каждой вершины разницу между высотой ее левого и правого поддерева diff[i] = h(L) – h(R)</p><p id="5f82d510-31ab-424c-a05d-520ad95a7995" class=""><strong>Для балансировки вершины используются один из 4 типов вращений:</strong></p><ul id="d948697c-7c15-4ca7-b2d1-9507a8c861ff" class="bulleted-list"><li style="list-style-type:disc">Малое левое вращение</li></ul><ul id="e6b5a6ac-ca74-472c-a159-ac310f3cf7fb" class="bulleted-list"><li style="list-style-type:disc">Большое левое вращение(Правое-левое вращение)</li></ul><ul id="07b250bc-2b8d-4f53-98c5-335734d72298" class="bulleted-list"><li style="list-style-type:disc">Малое правое вращение</li></ul><ul id="ea4128a2-cc0c-4840-b1e9-509248b05b13" class="bulleted-list"><li style="list-style-type:disc">Большое правое вращение(Левое правое)</li></ul><p id="197e373f-f326-4469-8283-1641548c223a" class=""><strong>Добавление вершины</strong></p><p id="eb8671b2-7695-4d6b-bcde-08d96bb0aa95" class="">Пусть нам надо добавить ключ t. Будем спускаться по дереву, как при поиске ключа t. Если мы стоим в вершине a и нам надо идти в поддерево, которого нет, то делаем ключ t листом, а вершину a его корнем. Дальше поднимаемся вверх по пути поиска и пересчитываем баланс у вершин. Если мы поднялись в вершину i из левого поддерева, то diff[i] увеличивается на единицу, если из правого, то уменьшается на единицу. Если пришли в вершину и её баланс стал равным нулю, то это значит высота поддерева не изменилась и подъём останавливается. Если пришли в вершину и её баланс стал равным 1 или -1 , то это значит высота поддерева изменилась и подъём продолжается. Если пришли в вершину и её баланс стал равным 2 или -2, то делаем одно из четырёх вращений и, если после вращения баланс стал равным нулю, то останавливаемся, иначе продолжаем подъём.</p><p id="fc0790a7-be50-41f5-ae34-fa6737e4faaf" class="">Так как в процессе добавления вершины мы рассматриваем не более, чем O(h) вершин дерева, и для каждой запускаем балансировку не более одного раза, то суммарное количество операций при включении новой вершины в дерево составляет O(logn) операций.</p><p id="87e0d826-bb7f-4e8d-9571-6362fed7b447" class=""><strong>Удаление вершины</strong></p><p id="be46c4e7-d1c0-4bbf-9de5-052c5f480826" class="">Для простоты опишем рекурсивный алгоритм удаления. Если вершина — лист, то удалим её, иначе найдём самую близкую по значению вершину a, переместим её на место удаляемой вершины и удалим вершину a. От удалённой вершины будем подниматься вверх к корню и пересчитывать баланс у вершин. Если мы поднялись в вершину из левого поддерева, то diff[i] уменьшается на единицу, если из правого, то увеличивается на единицу. Если пришли в вершину и её баланс стал равным 1 или -1, то это значит, что высота этого поддерева не изменилась и подъём можно остановить. Если баланс вершины стал равным нулю, то высота поддерева уменьшилась и подъём нужно продолжить. Если баланс стал равным 2 или -2, следует выполнить одно из четырёх вращений и, если после вращений баланс вершины стал равным нулю, то подъём продолжается, иначе останавливается.</p><p id="be985a53-25b0-4ece-8308-a36465e70e14" class="">В результате указанных действий на удаление вершины и балансировку суммарно тратится, как и ранее, O(h) операций. Таким образом, требуемое количество действий —  O(logn).</p></details></li></ul><ul id="66fdac3a-d55f-421a-b507-905c2c51a391" class="toggle"><li><details open=""><summary>46. B деревья.</summary><p id="e7d8172e-c0d3-4217-8ed1-ab79aac98f3e" class=""><strong>В-дерево</strong> — структура данных, дерево поиска. С точки зрения внешнего логического представления — сбалансированное, сильно ветвистое дерево. Часто используется для хранения данных во внешней памяти.</p><p id="265b939d-302d-4430-90cc-b79f2ca32eb4" class="">Использование B-деревьев впервые было предложено Р. Бэйером и Э. МакКрейтом в 1970 году.</p><p id="6f2a491d-1a32-445c-a93f-3453f4ccb260" class="">С точки зрения физической организации B-дерево представляется как мультисписочная структура страниц памяти, то есть каждому узлу дерева соответствует блок памяти (страница). Внутренние и листовые страницы обычно имеют разную структуру. Структура B-дерева применяется для организации индексов во многих современных СУБД.</p><p id="213c17d1-5f33-44f6-b14d-029bbc6928ac" class="">В-деревом называется дерево, удовлетворяющее следующим свойствам:</p><ol type="1" id="f5d0a6d4-4a69-4789-9105-9aeea2ead88e" class="numbered-list" start="1"><li>Ключи в каждом узле обычно упорядочены для быстрого доступа к ним. Корень содержит от 1 до 2t-1 ключей. Любой другой узел содержит от t-1 до 2t-1 ключей. Листья не являются исключением из этого правила. Здесь t — параметр дерева, не меньший 2 (и обычно принимающий значения от 50 до 2000).</li></ol><ol type="1" id="618b6a25-7605-4226-9585-5fee033c9be9" class="numbered-list" start="2"><li>У листьев потомков нет. Любой другой узел, содержащий ключи K, …, Kсодержит n+1 потомков. При этом:</li></ol><p id="b89dbc53-8a23-4122-9dac-2e74814b3398" class="">i. Первый потомок и все его потомки содержат ключи из интервала (-бесконечность, K)</p><p id="a12c5853-9e1b-4802-872b-116ffbea902d" class="">ii.  Для 2&lt;=i&lt;=n, i-й потомок и все его потомки содержат ключи из интервала (K, K)</p><p id="7b57d28b-255c-4106-9203-0b2a0e20539d" class="">iii. (n+1)-й потомок и все его потомки содержат ключи из интервала (K, бесконечность)</p><ol type="1" id="c22eb067-ed2a-499c-8cfe-8e110d118086" class="numbered-list" start="3"><li>Глубина всех листьев одинакова.</li></ol><p id="38a1b4d6-efde-4925-8f07-3e4c5c984be8" class="">Свойство 2 можно сформулировать иначе: каждый узел B-дерева, кроме листьев, можно рассматривать как упорядоченный список, в котором чередуются ключи и указатели на потомков.</p><ul id="282d1941-ad28-49e8-a17d-60bc354293d3" class="bulleted-list"><li style="list-style-type:disc">Во всех случаях полезное использование пространства вторичной памяти составляет свыше 50 %. С ростом степени полезного использования памяти не происходит снижения качества обслуживания.</li></ul><ul id="86501c39-3c1d-4309-ac64-624c5eaaf852" class="bulleted-list"><li style="list-style-type:disc">Произвольный доступ к записи реализуется посредством малого количества подопераций (обращения к физическим блокам).</li></ul><ul id="0daf05e8-024a-44ad-bfc3-f34880bdb4a1" class="bulleted-list"><li style="list-style-type:disc">В среднем достаточно эффективно реализуются операции включения и удаления записей; при этом сохраняется естественный порядок ключей с целью последовательной обработки, а также соответствующий баланс дерева для обеспечения быстрой произвольной выборки.</li></ul><ul id="ca19d69a-4c16-4f3f-89ad-9ba17affeced" class="bulleted-list"><li style="list-style-type:disc">Неизменная упорядоченность по ключу обеспечивает возможность эффективной пакетной обработки</li></ul><p id="d47f799c-537a-4338-be13-05d47ca64034" class="">Основной недостаток B-деревьев состоит в отсутствии для них эффективных средств выборки данных(то есть метода обхода дерева), упорядоченных по свойству, отличному от выбранного ключа.</p><p id="3df363b6-9e12-489f-a746-5ae56ac189b4" class=""><strong>Вставка в В-деревьях.</strong></p><ol type="1" id="cb41d6e9-a2e1-46a3-b024-228f492ebd8c" class="numbered-list" start="1"><li>Если дерево пустое, добавить корень и вставить значение.</li></ol><ol type="1" id="8bca5f27-c5ec-4c92-a245-9598e64e44a3" class="numbered-list" start="2"><li>Обновить количество ключей в узле.</li></ol><ol type="1" id="55487b71-40a6-424a-8bac-abd2d2b66d6e" class="numbered-list" start="3"><li>Найти подходящий для вставки узел.</li></ol><ol type="1" id="f6eeb6b8-b07e-4a67-83fb-dc61fadbbf60" class="numbered-list" start="4"><li>Если узел полон, то:</li></ol><p id="4428f153-5ae3-4663-a269-34b72e49879b" class="">i. Вставить элемент в порядке возрастания.</p><p id="00e5a28c-0769-4486-8ddc-575692e3135c" class="">ii. Так как количество элементов больше предела, разбить узел по медиане.</p><p id="8068eb03-366f-44c1-98ae-829073f3b07d" class="">iii. Сместить медианный ключ вверх и сделать ключи слева левым потомком, а ключи справа – правым.</p><ol type="1" id="bc54d318-45d8-4150-9316-5c3a0eab01ee" class="numbered-list" start="5"><li>Если узел не полон, то:</li></ol><p id="05b81702-f326-4634-9cee-8ca531e19bf7" class="">i. Вставить элемент в порядке возрастания.</p><p id="128ffab9-9556-41d7-bce7-b9812de15f9f" class="">
</p><p id="a7de8823-9720-40ab-a69f-f4f352e21e1c" class=""><strong>B* деревья</strong></p><p id="32add76c-89dd-4792-b3d1-5816a6e12684" class="">Что они делают здесь? Да, я, если честно, тоже слегка в шоке. Итак, да потому, что это разновидность B-дерева, в которой каждый узел дерева заполнен не менее чем на 2/3(в отличие от B-дерева, где этот показатель составляет ½).<br/>B* - деревья предложили Рудольф Байер и Эдвард МакКрейт, изучавшие проблему компактности В-деревьев. В*-дерево относительно компактнее, так как каждый узел используется полнее. В остальном этот вид деревьев не отличается от простого В-дерева.<br/>Для выполнения требования “заполненность узла не менее 2/3” приходится отказываться от простой процедуры разделения переполненного узла. Вместо этого происходит “переливание” в соседний узел. Если же соседний узел заполнен, то ключи приблизительно поровну разделяются на 3 новых узла.<br/>В+-дерево, удовлетворяющее таким требованиям, называется B*+ деревом<br/></p></details></li></ul><ul id="cfdb05d2-5b0f-4472-a15b-f570302b9bad" class="toggle"><li><details open=""><summary>47. B+ деревья.</summary><p id="cd28c979-10b4-4c44-bf8e-4ff3bf4b3af0" class=""><strong>B</strong><strong>+-дерево – </strong>структура данных на основе В-дерева, сбалансированное n-aрное дерево поиска с переменным, но зачастую большим количеством потомков в узле. В+-дерево состоит из корня, внутренних узлов и листьев, корень может быть либо листом, либо узлом с двумя и более потомками.</p><p id="e798fcb8-46a5-4ab4-8878-bbaba328bf5a" class="">Изначально структура предназначалась для хранения данных в целях эффективного поиска в блочно-ориентированной среде хранения — в частности, для файловых систем; применение связано с тем, что в отличие от бинарных деревьев поиска, B⁺-деревья имеют очень высокий коэффициент ветвления (число указателей из родительского узла на дочерние — обычно порядка 100 или более), что снижает количество операций ввода-вывода, требующих поиска элемента в дереве. Структура широко применяется в файловых системах — NTFS, ReiserFS, NSS, XFS, JFS, ReFS и BFS используют этот тип дерева для индексирования метаданных; BeFS также использует B⁺-деревья для хранения каталогов. Реляционные системы управления базами данных, такие как DB2, Informix, Microsoft SQL Server, Oracle Database (начиная с версии 8), Adaptive Server Enterprise и SQLite поддерживают этот тип деревьев для табличных индексов.</p><p id="f949a93f-3e37-41fd-9548-bd9fe635ab64" class=""><strong>В+-деревом называется дерево, удовлетворяющее следующим свойствам:</strong></p><ol type="1" id="5694146d-aa1f-4655-81e2-3c7a323c8643" class="numbered-list" start="1"><li>Ключи в каждом узле обычно упорядочены для быстрого доступа к ним. Корень содержит от 1 до 2t-1 ключей. Любой другой узел содержит от t-1 до 2t-1 ключей. Листья не является исключением из этого правила. Здесь t – параметр дерева, не меньший 2 (и обычно принимающий значения от 50 до 200)</li></ol><ol type="1" id="4eded6ad-1a01-4ecd-b97c-8bcc3b5396d0" class="numbered-list" start="2"><li>У листьев потомков нет. Любой другой узел, содержащий ключи K, …, K содержит n+1 потомков. При этом<p id="b4f1f5bd-9c26-4bd7-ba7e-4f79db726a57" class="">i.Первый потомок и все его потомки содержат ключи из интервала (-бесконечность, K)</p><p id="50f7b660-c4d3-4298-a166-4d3105d57199" class="">ii.Для 2&lt;=n&lt;=n, i-й потомок и все его потомки содержат ключи из интервала (K, K)</p><p id="a9332ef6-5510-41a6-98cf-462350b46fa7" class="">iii.(n+1)-й потомок и все его потомки содержат ключи из интервала (K, бесконечность)</p></li></ol><ol type="1" id="4e10dbc5-85f1-42bd-967e-d87a9657c073" class="numbered-list" start="3"><li>Глубина всех листьев одинакова</li></ol><ol type="1" id="1d4290c4-2fc8-4202-8700-1afdd47b248d" class="numbered-list" start="4"><li>Листья имеют ссылку на соседа, позволяющую быстро обходить дерево в порядке возрастания ключей, и ссылки на данные.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a104c83d-4d06-41b1-ac88-ed14121bc18b" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">class Node:
    def __init__(self, order):
        self.order = order
        self.values = []
        self.keys = []
        self.nextKey = None
        self.parent = None
        self.check_leaf = False</code></pre></details></li></ul><ul id="37321a46-2c91-4326-b653-665922c306f1" class="toggle"><li><details open=""><summary>48. Поиск, вставка, удаление, поиск следующего и предыдущего элемента за время, пропорциональное высоте.</summary><p id="86c43e78-57f5-4ec3-b94a-bd939a6152e3" class="">В деревьях:</p><p id="1dcb0bb3-5837-43bb-a87b-15de028bfb63" class=""><strong>Поиск элемента за время, пропорциональное высоте.</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="fca74f1b-bb6d-4757-a726-5a6245440ec8" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def search(node, key):
    if not node or node.data == key:
        return node
    if node.data &gt; key:
        return search(node.left, key)
    return search(node.right, key)</code></pre><p id="d580916e-89da-4479-a603-e959f6fa8906" class=""><strong>Поиск следующего и предыдущего элемента за время, пропорциональное высоте.</strong></p><p id="c3a7bb4a-51c4-4823-8703-ca7e029e76c0" class="">Найти элемент со следующим значением ключа, относительно ключа некоторого узла.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="58e95829-6d26-4ae5-b53d-707315f88248" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">def searchNext(node, key):
    if not node:
        return None
    if node.data == key:
        if node.right:
            current = node.right
            while current.left:
                current = current.left
            return current
        return None
    if node.data &gt; key:
        return search(node.left, key)
    return search(node.right, key)</code></pre><p id="56b45173-279b-4086-ad8a-dfc36857e0f6" class="">Поиск предыдущего элемента осуществляется аналогично.</p><p id="9edeb939-ffd2-4c20-8681-5aa36c1e2daa" class=""><strong>Вставка элемента за время, пропорциональное высоте</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="89a6cfc6-dd7d-4632-a3cf-5f24d91d7a7f" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def insert(node, key):
    if node is None:
        return Node(key)
    if key &lt; node.data:
        node.left = insert(node.left, key)
    else:
        node.right = insert(node.right, key)
    return node</code></pre><p id="ba886ce4-20ae-4f7e-b799-d2772af946e0" class=""><strong>Удаление элемента за время, пропорциональное высоте.</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3862caf9-a793-4f69-af59-5ad119c2f1b8" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def deleteNode(root, key):
    if root is None:
        return root

    if key &lt; root.data:
        root.left = deleteNode(root.left, key)
    elif key &gt; root.data:
        root.tight = deleteNode(root.right, key)
    else:
        if root.left is None:
            temp = root.right
            root = None
            return temp
        elif root.right is None:
            temp = root.left
            root = None
            return temp
        temp = searchPrev(root, key)
        root.data = temp.data
        root.right = deleteNode(root.right, temp.data)
    return root</code></pre></details></li></ul><ul id="4eaa1124-d8b2-4e5f-b8e7-1a7165c72e5f" class="toggle"><li><details open=""><summary>49. Декартово дерево: split, merge, реализация операций вставки и удаления через split и merge.</summary><p id="dde73365-a82b-4bef-8777-80d7ce27d0a2" class=""><strong>Декартово дерево или дерамида (Treap) </strong>— это структура данных, объединяющая в себе бинарное дерево поиска и бинарную кучу (отсюда и второе её название: treap (tree + heap) и дерамида (дерево + пирамида), также существует название курево (куча + дерево).</p><p id="4bf43671-f578-48f7-aa6e-16e3b783a236" class="">Более строго, это бинарное дерево, в узлах которого хранятся пары(x, y), где х – ключ, а y – приоритет. Также оно является двоичным деревом поиска по х и пирамидой по у. Предполагая, что все х и все у является различными, получаем, что если некоторый элемент дерева содержит (x0, y0), то у всех элементов в левом поддереве x&lt;x0, у всех элементов в правом поддереве x&gt;x0,  а также и в левом, и в правом поддереве имеем: y &lt; y0</p><figure id="70823c4d-30a1-449e-b7e2-43cd65fa58a5" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2011.png"><img style="width:634px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2011.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e2106900-a3a9-42ae-9eb8-c769b334c3f9" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">class Node:
    def __init__(self, value, prior):
        self.value = value
        self.prior = prior
        self.left = None
        self.right = None</code></pre><p id="f475f400-b7e5-4daf-9b73-a97c153280a2" class=""><strong>Декартово дерево</strong><strong>: split</strong></p><p id="753dcfb4-46dc-4536-89dd-476ffc08a47e" class="">Операция split (разрезать) позволяет сделать следующее: разрезать исходное дерево T по ключу k. Возвращать она будет такую пару деревьев &lt;T1, T2&gt;, что в дереве T1 ключи меньше k, а в дереве T2 все остальные: split(T,k) -&gt; &lt;T1, T2&gt;</p><p id="0a13f067-c5dd-47b9-916a-a2d3b92e1eae" class="">Эта операция устроена следующим образом:</p><p id="3e2eef52-0e42-4998-ba0a-c2cf00ecb6aa" class="">Рассмотрим случай, в котором требуется разрезать дерево по ключу, большему ключа корня. Посмотрим, как будут устроены результирующие деревья T1 и T2:</p><ul id="077f4981-a44f-4b8e-978e-a2d825292913" class="bulleted-list"><li style="list-style-type:disc">T1: левое поддерево T1 совпадает с левым поддеревом Т. Для нахождения правого поддерева T1, нужно разрезать правое поддерево Т на Т1^R и T2^R по ключу k и взять T1^R</li></ul><ul id="6a04a2c1-d8e9-48c0-bcd0-90a71ae1de20" class="bulleted-list"><li style="list-style-type:disc">T2 совпадает с T2^R</li></ul><p id="a0ca8d1d-2513-477e-aca5-fbe482f2a778" class="">Случай, в котором требуется разрезать дерево по ключу, меньше либо равно ключу в корне, рассматривается симметрично.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b1237575-1f0f-4126-b8f9-323eea698782" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def split(root, value):
    if root is None:
        return (None, None)
    elif root.value is None:
        return (None, None)
    else:
        if value &lt; root.value:
            left, root.left = split(root.left, value)
            return (left, root)
        else:
            root.right, right = split(root.right, value)
            return (root, right)</code></pre><p id="0b7151d8-faf2-48bb-9639-26f7dec8bc3f" class=""><strong>Декартово дерево</strong><strong>: merge</strong></p><p id="1d3f8661-eb7b-4a61-8d72-fa7f19910f04" class="">Рассмотрим вторую операцию с декартовыми деревьями – merge(слить)</p><p id="21e416d1-b736-4e2d-bc5a-a3bb4d0b882a" class="">С помощью этой операции можно слить два декартовых дерева в одно. Причём, все ключи в первом(левом) дереве должны быть меньше, чем ключи во втором(правом). В результате получается дерево, в котором есть все ключи из первого и второго деревьев: merge(T1, T2) -&gt; T</p><p id="b19eaef7-381b-46d9-ac7b-3510f3495e9b" class="">Рассмотрим принцип работы этой операции. Пусть нужно слить деревья T1 и T2. Тогда, очевидно, у результирующего дерева T есть корень. Корнем станет вершина из T1 или T2 с наибольшим приоритетом y. Но вершина с самым большим y из всех вершин деревьев T1 и T2 может быть только либо корнем T1, либо корнем T2. Рассмотрим случай, в котором корень T1 имеет больший y, чем корень T2. Случай, в котором корень T2 имеет больший y, чем корень T1, симметричен этому.</p><p id="665378ba-060a-4cc0-8a28-de6bd9b76651" class="">Если у корня T1 больше у корня T2, то он и будет являться корнем. Тогда левое поддерево Т совпадет с левым поддеревом Т1. Справа же нужно подвесить объединение правого поддерева T1 и дерева T2</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9c5b5618-18dd-4f20-b0f6-64b2499d20f0" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def merge(left, right):
    if (not left) or (not right):
        return left or right
    elif left.prior &lt; right.prior:
        left.right = merge(left.right, right)
        return left
    else:
        right.left = merge(left, right.left)
        return right</code></pre><p id="6464277e-7de9-4934-ac10-7c613997c76b" class=""><strong>Декартово дерево</strong><strong>: insert</strong></p><p id="ce97311b-946b-4705-ab98-3d914debf0bd" class="">Операция insert(T, k) добавляет в дерево T элемент k, где k.x – ключ, а k.y – приоритет.</p><p id="8a804761-c040-4e02-ac53-f3f8db5d2d55" class="">Представим что элемент k, это декартовое дерево из одного элемента, и для того чтобы его добавить в наше декартово дерево T, очевидно, нам нужно их слить. Но Т может содержать ключи как меньше, так и больше ключа k.x, поэтому сначала нужно разрезать T по ключу k.x.</p><ul id="6d62c1b8-22c7-47e3-8a03-66c8049ecb87" class="bulleted-list"><li style="list-style-type:disc">Реализация №1</li></ul><ol type="1" id="ab46ec9b-0116-42f4-b330-5c0ab6495d42" class="numbered-list" start="1"><li>Разобьем наше дерево по ключу, который мы хотим добавить, то есть split(T, k.x) -&lt;T1, T2&gt;</li></ol><ol type="1" id="3a31649e-c7ae-4628-90e6-5d9f872ba919" class="numbered-list" start="2"><li>Сливаем первое дерево с новым элементом, то есть merge(T1, k) -&gt; T1</li></ol><ol type="1" id="d5ecd14f-a529-4c3e-8b3e-c60eef6c5276" class="numbered-list" start="3"><li>Сливаем получившиеся дерево со вторым, то есть merge(T1, T2) -&gt; T</li></ol><ul id="a96ecab8-8172-4d42-9ba8-d0972c3b7ec8" class="bulleted-list"><li style="list-style-type:disc">Реализация №2</li></ul><ol type="1" id="1c400c6e-ae6b-4485-820a-26be14557769" class="numbered-list" start="1"><li>Сначала спускаемся по дереву(как в обычном бинарном дереве поиска по k.x), но останавливаемся на первом элементе, в котором значение приоритета оказалось меньше k.y</li></ol><ol type="1" id="221f46c6-d483-446d-bfd6-b5b830af528d" class="numbered-list" start="2"><li>Теперь вызываем split(T, k.x) -&gt; &lt;T1, T2&gt; от найденного элемента (от элемента вместе со всем его поддеревом)</li></ol><ol type="1" id="db074618-7aff-4f12-9204-f0ea21923deb" class="numbered-list" start="3"><li>Полученные T1 и T2 записываем в качестве левого и правого сына добавляемого элемента</li></ol><ol type="1" id="a4af3f0f-110f-445c-8a07-aae5126bebc4" class="numbered-list" start="4"><li>Полученное дерево ставим на место элемента, найденного в первом пункте</li></ol><p id="4cecf418-288e-4e7f-819b-a46c81edc9d7" class="">В первой реализации два раза используется merge, а во второй реализации слияние вообще не используется.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="197402f7-027f-4ab4-b63a-7bf55f8b9b5a" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def insert(root, value):
    node = Node(value)
    left, right = split(root, value)
    return merge(merge(left, node), right)
</code></pre><p id="5a987d68-9b77-4925-8d10-8ce48418ddcb" class=""><strong>Декартовое дерево</strong><strong>: remove</strong></p><p id="29d2dc72-1e65-4512-a080-3f3c939eed21" class="">Операция remove(T, x) удаляет из дерева  T элемент с ключом x.</p><ul id="db73c68c-3e2e-4e35-a727-04a9616c47b0" class="bulleted-list"><li style="list-style-type:disc">Реализация №1</li></ul><ol type="1" id="c5650933-fb8f-497a-8c76-437adc3c408a" class="numbered-list" start="1"><li>Разобьем наше дерево по ключу, который мы хотим удалить, то есть split(T, k.x) -&gt; &lt;T1, T2&gt;</li></ol><ol type="1" id="2bc5d960-59a9-4b29-938e-38d1052a3d84" class="numbered-list" start="2"><li>Теперь отделяем от первого дерева элемент x, то есть самого левого ребенка дерева T2</li></ol><ol type="1" id="003b2744-c27c-4dc6-b270-4cd4d40d2deb" class="numbered-list" start="3"><li>Сливаем первое дерево со вторым, то есть merge(T1, T2) -&gt; T</li></ol><ul id="8c8033d7-1af7-4118-9454-6f3c03ac87d2" class="bulleted-list"><li style="list-style-type:disc">Реализация №2</li></ul><ol type="1" id="e72b9436-46af-49ca-8f92-27466373e839" class="numbered-list" start="1"><li>Спускаемся по дереву (как в обычном бинарном дереве поиска по х), и ищем удаляемый элемент</li></ol><ol type="1" id="ec81192e-1f2d-4222-9bc1-14883bdb8d07" class="numbered-list" start="2"><li>Найдя элемент, вызываем merge его левого и правого сыновей</li></ol><ol type="1" id="4fd93856-c79b-4a1d-8e30-0065a8d71243" class="numbered-list" start="3"><li>Результат процедуры merge ставим на место удаляемого элемента</li></ol><p id="35eb142d-985f-4827-9c78-2b5c38ef7871" class="">В первой реализации один раз используется split, а во второй реализации разрезание вообще не используется.</p><p id="3571e2ec-b711-454b-b7e7-ff314423bb08" class=""><strong>Реализация операций вставки и удаления через </strong><strong>split</strong> <strong>и </strong><strong>merge</strong><strong>:</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9bcd7ac3-f9c7-43ef-b421-a19c37a7a1da" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def insert(root, value):
    node = Node(value)
    left, right = split(root, value)
    return merge(merge(left, node), right)

def remove(root, value):
    left, right = split(root, value - 1)
    _, right = split(right, value)
    return merge(left, right)</code></pre></details></li></ul><ul id="dc00acd7-61da-4087-af81-5b79b0682568" class="toggle"><li><details open=""><summary>50. Использование неявного ключа, rope.</summary><p id="00438842-5ccc-4c64-aabb-4c2684e97522" class="">В стандартной реализации структуру данных динамический массив мы умеем добавлять элемент в конец вектора, узнавать значение элемента, стоящего на определенной позиции, изменять элемент по номеру и удалять последний элемент. Предположим, что нам необходима структура данных с вышеуказанными свойствами, а также с операциями: добавить элемент в любое место (с соответствующим изменением нумерации элементов) и удалить любой элемент (также с соответствующим изменением нумерации). Такую структуру можно реализовать на базе декартового дерева, результат часто называют <strong>декартово дерево по неявному ключу (Treap with implicit key).</strong></p><p id="c7018779-d4f0-452b-a4e2-f0d5efa331d8" class="">При реализации декартова дерева по неявному ключу модифицируем эту структуру. А именно, оставим в нем только приоритет Y, а вместо ключа X будем использовать следующую величину: <strong>количество элементов в нашей структуре, находящихся левее нашего элемента. </strong>Иначе говоря, будем считать ключом порядковый номер нашего элемента в дереве, уменьшенный на единицу.</p><p id="cfed66a6-ece7-4655-aabe-e778c5615898" class="">Но при этом сохранится структура двоичного дерева поиска по этому ключу (то есть модифицированное декартово дерево так и останется таким же). Однако, с этим подходом появляется проблема: операции добавления и удаления элемента могут поменять нумерацию, и при наивной реализации на изменение всех ключей потребуется O(n) времени, где n – количество элементов в дереве.</p><p id="a20b4e98-58c9-4e12-a485-8efb7b418134" class="">Решается эта проблема довольно просто. Основная идея заключается в том, что такой ключ X сам по себе нигде не хранится. Вместо него будем хранить вспомогательную величину C: <strong>количество вершин в поддереве нашей вершины</strong> (в поддерево включается и сама вершина). Обратим внимание, что все операции с обычным декартовым деревом делались сверху. Также заметим, что если по пути от корня до некой вершины просуммировать все такие величины в левых поддеревьях, в которые мы не пошли, увеличенные на единицу, то придя в саму вершину и добавив к этой величине количество элементов в её левом поддереве, мы получим как раз ее ключ X.</p><p id="7f0a896b-9008-4dcd-8543-92e971f2faa7" class=""><strong>Использование неявного ключа</strong><strong>: split</strong></p><p id="e529cd52-9108-4213-9467-5df0c444bd71" class="">Пусть процедура split запущена в корне дерева с требованием отрезать от дерева k вершин. Также известно, что в левом поддереве вершины находится l вершин, а в правом r. Рассмотрим все возможные случаи:</p><ul id="41afaa51-d5e9-41a0-a6a4-19d46e26252c" class="bulleted-list"><li style="list-style-type:disc">l &gt;= k. В этом случае нужно рекурсивно запустить процедуру split от левого сына с тем же параметром k. При этом новым левым сыном корня станет правая часть ответа рекурсивной процедуры, а правой частью ответа станет корень</li></ul><ul id="0abde43a-0d83-416e-a98b-caed9525fa4e" class="bulleted-list"><li style="list-style-type:disc">l&lt;k. Случай симметричен предыдущему. Рекурсивно запустим процедуру split от правого сына с параметром k – l -1. При этом новым правым сыном корня станет левая часть ответа рекурсивной процедуры, а левой частью ответа станет корень.</li></ul><p id="6f144bf5-bd5d-4318-93b4-293cf6ea5d7c" class=""><strong>Использование неявного ключа</strong><strong>: merge</strong></p><p id="6605cce3-9999-47a2-9d52-687e22668e49" class="">Посмотрим любую из реализаций процедуры merge. Заметим, что в ней программа ни разу не обращается к ключу X. Поэтому реализация процедуры merge для декартова дерева по неявному ключу вообще не будет отличаться от реализации той же процедуры в обычном декартовом дереве.</p><p id="d797b3b9-a19c-4373-bba5-d3946ab519a8" class=""><strong>Использование неявного ключа</strong><strong>: применение</strong></p><p id="344cd35a-92fc-4359-89c5-0ead47efe6d9" class="">Таким образом, описана структура, от которой можно отрезать слева часть произвольной длины и слить две любые части в одну в нужном порядке. Теперь мы имеем возможность:</p><ul id="8429c9ad-2b68-48d1-bc42-af097f97c721" class="bulleted-list"><li style="list-style-type:disc">вставить элемент в любое место (отрежем нужное количество элементов слева, сольем левое дерево с деревом из одного добавленного элемента и результат — с правым деревом)</li></ul><ul id="ab230407-3e1d-4ffc-ac97-9fafe0dac4b8" class="bulleted-list"><li style="list-style-type:disc">переставить любой кусок массива куда угодно (сделаем нужные разрезы и слияния в правильном порядке)</li></ul><ul id="cadd2e3f-e0a2-45b8-b39f-876633ae3b15" class="bulleted-list"><li style="list-style-type:disc">совершать групповые операции с элементами. Вспомним реализацию таких операций в дереве отрезков и поймем, что ничего не помешает нам сделать то же самое с описанным деревом. В групповые операции включается, естественно, и взятие функции от отрезка</li></ul><ul id="23b1ca38-1097-4f92-aba6-e19b72e8e243" class="bulleted-list"><li style="list-style-type:disc">сделав на одном исходном массиве два дерева из элементов разной четности, можно решить задачу про смену мест четных и нечетных на отрезке</li></ul><p id="fd8f3a20-1193-4631-ba63-f4cc3a66ccd2" class=""><strong>Rope</strong></p><p id="16854eb7-4e4e-441b-ad06-4fb6ebfc5c99" class=""><strong>Rope (веревка</strong>) — структура данных для хранения строки, представляющая из себя двоичное сбалансированное дерево и позволяющая делать операции вставки, удаления и конкатенации с логарифмической асимптотикой.</p><p id="a9f8ff8e-2ba7-4c5e-a57e-fd061e80747f" class="">Иногда при использовании строк нам нужны следующие свойства:</p><ul id="9dac5ccf-6f0f-48c6-8e6c-5fc90476a8a7" class="bulleted-list"><li style="list-style-type:disc">Операции, которые часто используются на строках, должны быть более эффективными. Например: конкатенация, взятие подстроки.</li></ul><ul id="72e47e73-250e-4365-8f4d-86ed0a61efa7" class="bulleted-list"><li style="list-style-type:disc">Также эти операции должны эффективно работать и с длинными строками. Не должно быть прямой зависимости от длины строк.</li></ul><ul id="6a0e7512-a8fb-4ddc-adb4-8e85402b2f25" class="bulleted-list"><li style="list-style-type:disc">Персистентность. Иногда необходимо при изменении строки сохранить ее состояние перед изменением и вернуться к нему, если необходимо.</li></ul><p id="ce73f30c-8b21-4723-aad0-73c89adbe714" class="">В данном случае Rope удовлетворяет всем этим свойствам.</p><p id="c090f722-2ea9-453d-95ad-c5afc70ede09" class="">Для хранения Rope создадим структуру, похожую на декартово дерево по неявному ключу. В каждом листе будем хранить последовательную часть строки и ее длину, а в промежуточных вершинах будем хранить сумму длин всех листьев в поддереве. Изначально дерево состоит из одной вершины — самой строки. Используя информацию в промежуточных вершинах, можно получать символы строки по индексу. Также заметим, что для отметки листа не обязательно хранить дополнительную информацию: все внутренние вершины имеют ровно двух детей, а листы — ни одного. Поэтому для проверки вершины на то, что она является листом, достаточно проверить, есть ли у неё дети.</p><p id="85115166-9a63-4b59-b775-2a8869e340f2" class=""><strong>Rope: merge</strong></p><p id="78490ef9-ca4c-445a-9090-68772397fbd9" class="">Когда приходит запрос на конкатенацию с другой строкой, мы объединяем оба дерева, создав новый корень и подвесив к нему обе строки. Пример результата конкатенации двух строк:</p><figure id="070ca9ed-ef23-4318-961a-796ccfa7b6c6" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2012.png"><img style="width:494px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2012.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4e02e504-ec0e-434c-bf8a-afdf5ab089fc" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def merge(n1, n2):
    return Node(n1, n2, n1.w + n2.w)</code></pre><p id="fdccab3a-d684-43b6-b950-f9a6fd182034" class="">Асимптотика выполнения операции конкатенации двух строк, очевидно, O(1)</p><p id="0f0e626b-9c70-4f4f-9faa-b73d8bb8f204" class=""><strong>Rope: получение символа по индексу</strong></p><p id="6e491380-3d04-4369-8bd5-5787d1d347a8" class="">Чтобы получить символ по некоторому индексу , будем спускаться по дереву из корня, используя веса, записанные в вершинах, чтобы определить, в какое поддерево пойти из текущей вершины. Алгоритм выглядит следующим образом:</p><ul id="ded6811e-7631-4651-9eec-7293d6584e4a" class="bulleted-list"><li style="list-style-type:disc">Текущая вершина – не лист, тогда возможно два варианта:</li></ul><ol type="1" id="411008b0-ddef-470b-95c9-1ce7d55c9deb" class="numbered-list" start="1"><li>Вес левого поддерева больше либо равен i, тогда идем в левое поддерево.</li></ol><ol type="1" id="85da1ad9-98c8-4d92-b6e0-722cae1ff515" class="numbered-list" start="2"><li>Иначе идем в правое поддерево и ищем там i – w символ, где w вес левого поддерева.</li></ol><ul id="1a1a09b0-938a-4868-96ad-c86753ffdf65" class="bulleted-list"><li style="list-style-type:disc">Текущая вершина – лист, тогда в этом листе хранится ответ; необходимо взять символ с соответствующим номером у строки, которая там хранится.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="745b3667-ee33-412a-9e39-1067ea649987" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def get(i, node):
    if node.left:
        if node.left.w &gt;= i:
            return get(i, node.left)
        else:
            return get(i - node.left.w, node.right)
    else:
        return node.s[i]</code></pre><p id="4e1a92ea-2853-4bef-b082-45da545dbc12" class="">Асимптотика выполнения одного такого запроса O(h), где h – высота дерева.</p><p id="f34979e0-4ef1-41b7-a087-520d72199dea" class=""><strong>Rope: split</strong></p><p id="8e893eb2-988e-43de-b34c-831fe043f2c0" class="">Чтобы разбить строку на две по некоторому индексу i, необходимо, спускаясь по дереву (аналогично операции get), каждую вершину на пути поделить на две, каждая из которых будет соответствовать одной из половинок строк, при этом необходимо после деления пересчитать вес этих вершин. Пускай дано дерево:</p><figure id="81399a5a-38ff-468c-9991-926000ff1918" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2013.png"><img style="width:857px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2013.png"/></a></figure><p id="8110ef70-78eb-4dd4-9e4c-0a043b183eee" class="">Тогда результатом выполнения операции split по индексу 16 будет:</p><figure id="d6193bc2-17fd-46bf-80d4-2e81bd04cc6f" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2014.png"><img style="width:930px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2014.png"/></a></figure><p id="b8f4a1f3-0a01-4143-8c87-110553a5fd17" class="">Заметим, что появляются лишние вершины, у которых есть только один потомок. От них можно легко избавиться, просто заменив их на этого потомка. Тогда результатом той же операции split будет:</p><figure id="1d3d84fa-deb3-4fbe-b60f-0ac648e4217a" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2015.png"><img style="width:951px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2015.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a48014b6-2b66-4cc6-b9be-afa5bf06919a" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def split(node, i):
    if node.left:
        if node.left.w &gt;= i:
            res = split(node.left, i)
            tree1 = res[0]
            tree2.left = res[1]
            tree2.right = node.right
            tree2.w = tree2.left.w + tree2.right.w
        else:
            res = split(node.right, i - node.left.w)
            tree1.left = node.left
            tree1.right = res[0]
            tree1.w = tree1.left.w + tree1.right.w
            tree2 = res[1]

    else:
        tree1.s = node.s[:i+1]
        tree2.s = node.s.[i+1:]
        tree1.w = i
        tree2.w = len(node.s) - i
    return tree1, tree2</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4f08e1d1-db06-42f3-936b-c4d43b9ce12a" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def split(node, i):
    if node.left:
        if node.left.w &gt;= i:
            res = split(node.left, i)
            tree1 = res[0]
            tree2.left = res[1]
            tree2.right = node.right
            tree2.w = tree2.left.w + tree2.right.w
        else:
            res = split(node.right, i - node.left.w)
            tree1.left = node.left
            tree1.right = res[0]
            tree1.w = tree1.left.w + tree1.right.w
            tree2 = res[1]

    else:
        tree1.s = node.s[:i+1]
        tree2.s = node.s.[i+1:]
        tree1.w = i
        tree2.w = len(node.s) - i
    return tree1, tree2
</code></pre><p id="6374fa3c-84d2-4543-b05b-aa5532af1e32" class=""><strong>Rope: операции удаления и вставки</strong></p><p id="f9acb7b9-0ff6-4cef-8754-3d19caeab20f" class="">Нетрудно понять, что имея операции merge и split, можно легко через них выразить операции delete и insert по аналогии с другими деревьями поиска.</p><p id="cd288882-e9e1-4567-95df-a1284f7315ea" class="">Операция delete удаляет из строки подстроку, начиная с индекса beginIndex и заканчивая(не включая) индексом endIndex</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="70deef34-4d08-477b-a90f-2629280b061d" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def delete(node, beginIndex, endIndex):
    tree1, tree2 = split(node, beginIndex)
    tree3 = split(tree2, endIndex - beginIndex)[1]
    return merge(tree1, tree3)</code></pre><p id="9ab1ee44-f4b7-4b30-91aa-0909a6d9dccc" class="">
</p><p id="8fed0069-a70f-4f89-9a80-d8db1a91b45d" class="">Так как данные операции используют только split и merge, то асимптотика времени их работы – O(h), где h – высота дерева.</p><p id="2d729968-fe6c-4598-938a-c5b5cde5cd04" class="">Операция insert вставляет данную строку s в исходную, начиная с позиции insertIndex<br/><br/>Так как данные операции используют только split и merge, то асимптотика времени их работы – O(h), где h – высота дерева.<br/></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bceb1f95-d772-429a-8a65-865e27976b86" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">def insert(node, insertIndex, s):
    tree1, tree3 = split(node, insertIndex)
    tree2 = Node(s)
    return merge(merge(tree1, tree2), tree3)</code></pre><p id="32c3d70d-6e9b-4b4c-ba3e-a92a5cb7c6f2" class=""><strong>Rope: </strong><strong>балансировка</strong></p><p id="1d17fdbc-b153-49bc-88cc-418652d480fc" class="">Для того, чтобы дерево не превращалось в бамбук</p><figure id="3f73cddf-201d-498d-964a-bab131a31798" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2016.png"><img style="width:355px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2016.png"/></a></figure><p id="db826a0b-dcc5-4e12-a0fb-85a4567551f4" class="">Предлагается хранить его как АВЛ-дерево и делать соответствующие балансировки. Тогда, так как высота АВЛ-дерева h = logn, то асимптотика операций get, split, delete, insert, merge будет равна O(logn), где  n – количество сконкатенированных строк.</p></details></li></ul><ul id="906c6d3a-9ee1-4622-8344-e4f80a3295d8" class="toggle"><li><details open=""><summary>51. Поиск подстроки в строке. Наивный алгоритм.</summary><p id="3d177655-2943-4dbf-a617-b11454fdfd88" class=""><strong>Поиск подстроки в строке</strong> — одна из простейших задач поиска информации. Применяется в виде встроенной функции в текстовых редакторах, СУБД, поисковых машинах, языках программирования и т. п.<br/><br/><strong>Поиск подстроки в строке (String searching algorithm) </strong>— класс алгоритмов над строками, которые позволяют найти паттерн (pattern) в тексте (text).<br/><br/><strong>Формулировка задачи:</strong> Дан текст <em>t[0…n-1]</em> и паттерн <em>p[0…m-1]</em> такие, что <em>n ≥ m</em> и элементы этих строк — символы из конечного алфавита <em>E</em>. Требуется проверить, входит ли паттерн в текст <em>t</em>.</p><p id="cec2433f-3693-4ba1-a8e0-2baf705b7da9" class=""><strong>Наивный алгоритм.</strong></p><p id="01bf95f7-0129-405c-97f0-fa2bd1d65266" class="">Будем говорить, что паттерн <em>p</em> встречается в тексте <em>t</em> со сдвигом <em>s</em>, если <em>0 ≤ s ≤ n-m</em> и<br/><br/><em>t[s…s + m - 1] = p</em>. Если строка <em>p</em> встречается в строке <em>t</em>, то <em>p</em> является подстрокой <em>t</em>.<br/>В наивном алгоритме поиск всех допустимых сдвигов производится с помощью цикла, в котором проверяется условие <br/><em>t[s…s + m - 1] = p</em> для каждого <em><em>n - m + 1</em></em> из возможных значений <em>s</em>.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9e07812d-1e08-49ed-9804-cc7b6fcd0f2e" class="code"><code class="language-Python">def naiveStringMatcher(t, p):
	n = len(t)
	m = len(p)
	ans = []
		for i in range(0, n - m):
		if t[
i : i + m - 1] == p:
			ans.append(i)
	return ans</code></pre><p id="24de1b56-8dcb-47c7-8007-a7b07bd14f28" class=""><strong>Преимущества</strong></p><ul id="d4953820-f42b-44a7-be1b-0211e212ef78" class="bulleted-list"><li style="list-style-type:disc">Требует <em><em><em><em>O(1)</em></em></em></em> памяти.</li></ul><ul id="ebe3fe67-2ac9-4446-a59a-b339c6827db9" class="bulleted-list"><li style="list-style-type:disc">Приемлемое время работы на практике. Благодаря этому алгоритм применяется, например, в браузерах и текстовых редакторах (при использовании Ctrl + F), потому что обычно паттерн, который нужно найти, очень короткий по сравнению с самим текстом. </li></ul><ul id="8255f880-7453-4941-aa21-1fcc6a77bd9c" class="bulleted-list"><li style="list-style-type:disc">Также наивный алгоритм<br/>используется в стандартных библиотеках языков высокого уровня (C++, Java), потому что он не требует дополнительной памяти.<br/></li></ul><ul id="9a28c10f-c4d7-4133-9a8f-a298dba9456e" class="bulleted-list"><li style="list-style-type:disc">Простая и понятная реализация.</li></ul><p id="1b2f2ffc-4099-4157-bf52-15ed852ba995" class=""><strong>Недостатки</strong></p><ul id="0222da32-2260-4e53-a4a5-a584f35d8f0f" class="bulleted-list"><li style="list-style-type:disc">Требует операций, вследствие чего алгоритм работает медленно в случае, когда<br/>длина паттерна достаточно велика.<br/></li></ul></details></li></ul><ul id="1704885a-bccf-4ec3-b905-bee6ff9838f2" class="toggle"><li><details open=""><summary>52. Поиск подстроки в строке. Z-функция</summary><p id="582a419f-48c3-432a-8292-8818570e6fcc" class=""><strong>Z-функция (Z-function)</strong> от строки <em>S</em> и позиции <em>x</em> — это длина максимального префикса подстроки,<br/>начинающейся с позиции <br/><em>x</em> в строке <em>S</em>, который одновременно является и префиксом всей строки <em>S</em>. Более формально, <em><em>Z[i](s) = max k | s[i…i + k] = s[0…k]</em></em>.<br/>Иными словами <br/><em>z[i]</em>, — это длина наибольшего общего префикса строки <em>s</em> и её <em>i</em>-го суффикса.<br/>Значение Z-функции от первой позиции не определено, поэтому его обычно приравнивают к нулю или к длине строки.<br/>&quot;aaaaa&quot; - <br/><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[0, 4, 3, 2, 1]</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em><br/>&quot;aaabaab&quot; - <br/><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[0, 2, 1, 0, 2, 1, 0]</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em><br/>&quot;abacaba&quot; - <br/><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[0, 0, 1, 0, 3, 0, 1]</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></p><p id="3a3f2394-6831-4034-9698-266c5a2b6c61" class="">Наивный алгоритм: сравнение всех возможных подстрок за <em><em><em><em><em>O(n^2)</em></em></em></em></em>.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="785cdc9d-3da9-4a1c-b825-93d2fdea175a" class="code"><code class="language-Python">def z_func(s, n):
		z = [0] * n
		for i in range(1, n - 1):
				while i + z[i] &lt; n and s[z[i]] == s[i + z[i]]:
						z[i] += 1
		return z</code></pre><figure id="d6ad0c5e-736d-4204-9e06-32fe75b33a00" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2017.png"><img style="width:528px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2017.png"/></a></figure><p id="3e7efc78-1d01-4cb9-9cc2-aff70606561a" class="">Я не знаю как удалить кота. Вот вам кот.</p><p id="6d1a87a4-accb-461d-b468-e90868dae1ee" class="">Эффективный алгоритм - описание в <a href="https://github.com/zernovga/Algorithms_and_Data_Structures_Course/blob/main/Lections/Lection_13.pdf">лекции 13</a> на слайдах 8-12. Вкратце, к изначальному он добавляет две переменные - <em>l</em> и <em>r</em>, которые хранят в себе начало и конец последнего мемоизированного отрезка. Если текущий рассматриваемый индекс <em>i </em>находится между ними, то можно посмотреть элемент из префикса строки (отрезок с началом в начале строки) и проинициализировать его значением текущий <em><em><em><em><em><em><em><em><em><em><em><em><em><em>z[i]</em></em></em></em></em></em></em></em></em></em></em></em></em></em>, а далее - снова использовать тривиальный алгоритм. Если <em><em><em><em><em><em><em><em><em>i + z[i] &gt; r,</em></em></em></em></em></em></em></em></em> то <em><em><em><em><em><em><em><em><em>l = i </em></em></em></em></em></em></em></em></em>и<em><em><em><em><em><em><em><em><em> r = i + z[i].</em></em></em></em></em></em></em></em></em></p><figure id="816e80e4-632a-4b9f-82e0-d301c1c79dee" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2018.png"><img style="width:1267px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2018.png"/></a><figcaption>Небольшая визуализация примера</figcaption></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8ae1f98b-eaf4-4a59-b0dd-4d804de20864" class="code"><code class="language-Python">def z_func(s):
		n = len(s)
		z = [0] * n
		l = 0
		r = 0
		for i in range(1, n):
				if i &lt; r:
						z[i] = min(r - i, z[i - l])
				while i + z[i] &lt; n and s[z[i]] == s[i + z[i]]:
						z[i] += 1
				if i + z[i] &gt; r:
						l = i
						r = i + z[i]
		return z</code></pre><p id="9bc5700b-e5f1-4f73-8f0b-4913f25cf770" class=""><strong>Применение для поиска подстроки в строке</strong></p><p id="66d084a5-6e24-41aa-a269-294075d639da" class=""><em>n </em>— длина текста. <em>m </em>— длина образца.<br/>Образуем строку <br/><em>s = pattern + # + text</em> , где <em>#</em> — символ, не встречающийся ни в <em>text</em> , ни в<br/><br/><em>pattern</em> . Вычисляем Z-функцию от этой строки. В полученном массиве, в позициях в которых значение Z-функции равно <em>|pattern|</em> , по определению начинается подстрока, совпадающая с<em><em><em><em><em><em><em><em><em> pattern</em></em></em></em></em></em></em></em></em>.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e47c5bf7-ff2d-44b1-a1a3-651fd9008343" class="code"><code class="language-Python">def substringSearch(text, pattern):
		zf = z_func(pattern + &#x27;#&#x27; + text)
				for i in range(m + 1, n + 1):
						if zf[i] == m
								return i</code></pre></details></li></ul><ul id="84b86b05-0966-4641-ac0f-c3e2ac86786a" class="toggle"><li><details open=""><summary>53. Поиск подстроки в строке. Префикс функция</summary><p id="8f7d87c0-65be-4b88-8878-22002b1c53dc" class="">Префикс-функция строки - это массив чисел длиной <strong>n </strong>(длина строки <strong>s</strong>), в котором каждый элемент это наибольшая длина наибольшего собственного суффикса подстроки <strong>s</strong>, совпадающего с её префиксом.</p><table id="dc2eaa40-8746-4663-9cb6-5a6e1dfea453" class="simple-table"><tbody><tr id="f61f0933-af90-40b2-b987-a3a5b903ff33"><td id="vi\E" class="">Строка</td><td id="GXQZ" class="">Префикс-функция</td></tr><tr id="23a9face-e6a4-41f9-8246-a8a453c53a85"><td id="vi\E" class="">abababcab</td><td id="GXQZ" class="">0 0 1 2 3 4 0 1 2</td></tr><tr id="32d1e193-8488-4911-a722-f8f522423b2e"><td id="vi\E" class="">abcabcd</td><td id="GXQZ" class="">0 0 0 1 2 3 0</td></tr><tr id="e8c5ff02-fd4b-4e42-a6d8-76c2ff8a9043"><td id="vi\E" class="">aabaaab</td><td id="GXQZ" class="">0 1 0 1 2 2 3</td></tr></tbody></table><p id="78584777-0421-4a66-a2b9-25765f526cb1" class=""><strong>Наивный алгоритм за O(n^3)</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8b80f6a4-ec53-4604-8e35-e645bb4ed35a" class="code"><code class="language-Python">def prefix_func(s):
		n = len(s)
		pi = [0] * n
		for i in range(n - 1):
				for k in range(1, i + 1):
						equal = True
						for j in range(k):
								if s[j] != s[i - k + 1 + j]:
										equal = False
										break
						if equal:
								pi[i] = k
		return pi</code></pre><p id="ef154aed-b9ca-41ff-a7ac-9be0f669def8" class=""><strong>Эффективный алгоритм за O(n)</strong></p><p id="ff7ef3a2-0877-429a-926a-7030fc081a36" class="">Вносятся несколько важных замечаний:</p><ul id="4f904dc9-f58b-4f44-b842-a96c309d1029" class="bulleted-list"><li style="list-style-type:disc">Заметим, что <em>p</em>[<em>i </em>+ 1] ⩽ <em>p</em>[<em>i</em>] + 1. Чтобы показать это, рассмотрим суффикс,оканчивающийся на позиции <em>i </em>+ 1 и имеющий длину <em>p</em>[<em>i </em>+ 1], удалив из него последний символ, мы получим суффикс, оканчивающийся на позиции <em>i </em>и имеющий длину <em>p</em>[<em>i</em>+1]−1, следовательно неравенство <em>p</em>[<em>i</em>+1]&gt;<em>p</em>[<em>i</em>]+1 неверно.</li></ul><ul id="82ebbfaa-60f9-42fc-aa0d-db5c5ebfb149" class="bulleted-list"><li style="list-style-type:disc">Избавимся от явных сравнений строк. Пусть мы вычислили <em>p</em>[<em>i</em>], тогда, если <em>s</em>[<em>i </em>+ 1] = <em>s</em>[<em>p</em>[<em>i</em>]], то <em>p</em>[<em>i </em>+ 1] = <em>p</em>[<em>i</em>] + 1. Если окажется, что <em>s</em>[<em>i </em>+ 1] ≠ <em>s</em>[<em>p</em>[<em>i</em>]], то нужно попытаться попробовать подстроку меньшей длины. Хотелось бы сразу перейти к такому <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%B5%D1%80%D0%B8%D0%BE%D0%B4_%D0%B8_%D0%B1%D0%BE%D1%80%D0%B4%D0%B5%D1%80,_%D0%B8%D1%85_%D1%81%D0%B2%D1%8F%D0%B7%D1%8C#.D0.9E.D0.BF.D1.80.D0.B5.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F">бордеру</a> наибольшей длины, для этого подберем такое <em>k</em>, что <em>k </em>= <em>p</em>[<em>i</em>] − 1. Делаем это следующим образом. За исходное <em>k </em>необходимо взять <em>p</em>[<em>i </em>− 1], что следует из первого пункта. В случае, когда символы <em>s</em>[<em>k</em>] и <em>s</em>[<em>i</em>] не совпадают, <em>p</em>[<em>k </em>− 1] — следующее потенциальное наибольшее значение <em>k</em>, что видно из рисунка. Последнее утверждение верно, пока <em>k </em>&gt; 0, что позволит всегда найти его следующее значение. Если <em>k</em>=0, то <em>p</em>[<em>i</em>] = 1 при <em>s</em>[<em>i</em>] = <em>s</em>[1], иначе <em>p</em>[<em>i</em>]=0.</li></ul><figure id="7b251fa6-fa8f-4261-ab04-79d511d4507c" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2019.png"><img style="width:800px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2019.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ba10a0ab-723d-43ec-b824-3656397af015" class="code"><code class="language-Python">def prefixFunction(s):
    p = [0] * len(s)
    p[0] = 0
    for i in range(1, len(s)):
        k = p[i - 1]
        while k &gt; 0 and s[i] != s[k]:
            k = p[k - 1]
        if s[i] == s[k]:
            k += 1
        p[i] = k
    return p</code></pre><p id="7a390649-5db0-4311-8995-244b2ce1f247" class="">Здесь если каждый следущий символ не дополняет результат, полученный в предыдущем шаге, то значение <em>k</em> как бы сдвигается на один элемент назад внутри префикса, пока символы не совпадут (что будет означать успешный подбор значения префикс-функции).</p></details></li></ul><ul id="6f75a530-4737-4406-9c34-d41f7a0fddb5" class="toggle"><li><details open=""><summary>54. Поиск подстроки в строке. Алгоритм Кнута-Морриса-Пратта.</summary><p id="33587dea-f427-4785-9ccf-d7e1b5427c6a" class=""><strong>Дан текст </strong><strong><em>t</em></strong><strong> и строка </strong><strong><em>s</em></strong><strong>, требуется найти и вывести позиции всех вхождений строки </strong><strong><em>s</em></strong><strong> в текст </strong><strong><em>t</em></strong><strong>.</strong></p><ul id="4761a959-d589-40bc-ad7e-f37ebec6da93" class="bulleted-list"><li style="list-style-type:disc">Обозначим для удобства через <em>n</em> длину строки <em>s</em>, а через <em>m</em> — длину текста <em>t</em>.</li></ul><ul id="bf85b772-f0c4-4800-be57-f8c4190265f2" class="bulleted-list"><li style="list-style-type:disc">Образуем строку <em>s+#+t</em> , где символ # — это разделитель, который не должен нигде более<br/>встречаться. Посчитаем для этой строки префикс-функцию. <br/></li></ul><ul id="943c0958-8d17-4ad5-a880-e58af6f43a85" class="bulleted-list"><li style="list-style-type:disc">Теперь рассмотрим её значения, кроме первых <em>n + 1</em> (которые, как видно, относятся к строке <em>s</em> и разделителю). По определению, значение <em>p[i]</em> показывает наидлиннейшую длину подстроки, оканчивающейся в позиции <em>i</em> и совпадающего с префиксом. Но в нашем случае это <em><em><em><em><em>p[i] </em></em></em></em></em>— фактически длина наибольшего блока совпадения со строкой <em><em><em><em>s[i]</em></em></em></em> и оканчивающегося в позиции <em>i</em>. Больше, чем <em>n</em>, эта длина быть не может, за счёт разделителя. А вот равенство <em><em><em><em>p[i] = n</em></em></em></em> (там, где оно достигается), означает, что в позиции <em>i </em>оканчивается искомое вхождение строки <em>s</em> (только не надо забывать, что все позиции отсчитываются в склеенной строке <em>s+#+t</em> ).</li></ul><ul id="140434d6-1e6d-4619-89ff-2af224aa98ee" class="bulleted-list"><li style="list-style-type:disc">Таким образом, если в какой-то позиции <em>i</em> оказалось <em>p[i] = n</em>, то в позиции <em><em><em><em><em><em><em><em><em><em><em><em>i - (n + 1) - n + 1 = i - 2n </em></em></em></em></em></em></em></em></em></em></em></em>строки <em>t</em> начинается очередное вхождение строки <em>s</em> в текст <em>t</em>.</li></ul><p id="72d04485-936b-4407-a5e6-e05196c6be41" class="">Как уже упоминалось при описании алгоритма вычисления префикс-функции, если известно, что значения префикс-функции не будут превышать некоторой величины, то достаточно хранить не всю строку и префикс-функцию, а только её начало. В нашем случае это означает, что нужно хранить в памяти лишь строку <em>s+#</em> и значение префикс-функции на ней, а потом уже считывать по одному символу строку <em>t</em> и пересчитывать текущее значение префикс-функции. Алгоритм Кнута-Морриса-Пратта решает эту задачу за <em><em><em><em><em><em><em><em>O(n + m)</em></em></em></em></em></em></em></em> времени и <em><em><em><em>O(n)</em></em></em></em> памяти.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="600efc91-8335-4783-ad3c-c23beac80810" class="code"><code class="language-Python">def kmp(s, t):
		n = len(s)
		m = len(t)
		answer = []
		p = prefix_func(s + &quot;#&quot; + t)
		count = 0
				for i in range(0, m - 1)
						if p[n + i + 1] == n:
								count += 1
								answer[count] = i - n
		return answer</code></pre></details></li></ul><ul id="3f23ea38-4370-4729-b742-fed4a1154f57" class="toggle"><li><details open=""><summary>55. Поиск подстроки в строке. Полиномиальный хеш </summary><p id="42c0aa07-af72-4ba2-bac7-8b608a580c4f" class=""><strong>Хеширование (hashing)</strong> — класс методов поиска, идея которого состоит в вычислении хеш-кода, однозначно определяемого элементом с помощью хеш-функции, и использовании его, как основы для поиска (индексирование в памяти по хеш-коду выполняется за ). В общем случае, однозначного соответствия между исходными данными и хеш-кодом нет в силу того, что количество значений хеш-функций меньше, чем вариантов исходных данных, поэтому существуют элементы, имеющие одинаковые хеш-коды — так называемые коллизии, но если два элемента имеют разный хеш-код, то<br/>они гарантированно различаются. Вероятность возникновения коллизий играет немаловажную роль в оценке качества хеш-функций. Для того чтобы коллизии не замедляли работу с таблицей существуют методы для борьбы с ними.<br/></p><p id="9828f11b-4098-4490-88a2-0e98bfec18d9" class=""><strong>Полиномиальный хэш</strong></p><figure id="76367670-3538-460f-9ed0-9dd557f0aab6" class="image"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2020.png"><img style="width:1466px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2020.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e2c287f7-158f-4c52-99f6-a9ff90be592c" class="code"><code class="language-Python"># здесь использовал оптимизации из модульной арифметики (5 билет)
def phash(s: str, p: int, base: int = 2 ** 32) -&gt; int:
    result = 0
    for i in range(len(s)):
        result += ((ord(s[i]) % base) * (((p % base) ** i) % base)) % base
    return result


print(phash(&quot;sirius&quot;, 3))  # 41713</code></pre></details></li></ul><ul id="c9817491-3438-45cb-b754-66be2a26b99f" class="toggle"><li><details open=""><summary>56. Поиск подстроки в строке. Алгоритм Рабина-Карпа.</summary><p id="a5a63f16-f009-4fcb-999a-382b7fe81341" class="">Алгоритм начинается с подсчета <em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>hash(s[0…m - 1])</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em> и <em><em><em><em><em><em><em><em><em><em><em>hash(p[0…m-1])</em></em></em></em></em></em></em></em></em></em></em>, а также с подсчета <em><em><em>p^m</em></em></em>, для ускорения ответов на запрос.</p><p id="e9c70358-da56-43b0-8098-df5924cd892b" class="">Для <em><em><em><em><em><em><em><em><em><em><em><em><em><em>i in [0…n - m]</em></em></em></em></em></em></em></em></em></em></em></em></em></em> вычисляется <em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>hash(s[i…i + m - 1])</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em> и сравнивается с <em><em><em><em><em><em>hash(p[0…m-1])</em></em></em></em></em></em>. Если<br/>они оказались равны, то образец <br/><em><em>p </em></em>скорее всего содержится в строке начиная с позиции <em>i</em>, хотя возможны и ложные срабатывания алгоритма. Если требуется свести такие срабатывания к минимуму или исключить вовсе, то применяют сравнение некоторых символов из этих строк, которые выбраны случайным образом, или применяют явное сравнение строк, как в наивном алгоритме поиска подстроки в строке. В первом случае проверка произойдет быстрее, но вероятность ложного срабатывания, хоть и небольшая, останется. Во втором случае проверка займет время, равное длине образца, но полностью исключит возможность ложного срабатывания. </p><p id="0c09c1e9-5257-4c2d-9104-f5dd4f109401" class="">Если требуется найти индексы вхождения нескольких образцов, или сравнить две строки − выгоднее будет предпосчитать все степени <em>p</em>, а также хеши всех префиксов строки <em>s</em>.</p><p id="123feb8f-e062-408f-94c7-ac7373d22fd3" class=""><strong>Реализация</strong></p><p id="354c3a8a-d77b-4eb7-a059-55a098d58c62" class="">Алгоритм находит все вхождения строки <em>w</em> в строку <em><em>s </em></em>и возвращает массив позиций, откуда начинаются вхождения.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0c02ecec-e87d-4cae-8dcb-78c19b3cedc2" class="code"><code class="language-Python">def rabinKarp (s, w, r):
		answer = []
		n = len(s)
		m = len(w)
		hashS = hash(s[:m])
		hashW = hash(w[:m])
		for i in range(n - m):
				if hashS == hashW:
						answer.append(i)
				hashS = (p * hashS - (p ** m) * hash(s[i]) + hash(s[i + m])) % r
		return answer</code></pre><p id="f528293f-2eda-42aa-b3b6-7ba9156bcdd6" class="">Новый хеш <em><em><em><em><em><em>hashS </em></em></em></em></em></em>был получен с помощью быстрого пересчёта. Для сохранения корректности<br/>алгоритма нужно считать, что <br/><em>s[n + 1]</em> — пустой символ.</p></details></li></ul><ul id="c72a8e70-80ec-4bd8-b977-a273991b0691" class="toggle"><li><details open=""><summary>57. Хеш-таблицы. Коллизии.</summary><p id="b4c00bc2-8fc4-4c59-80da-dc0fdd487300" class=""><strong>Коллизия (collision): </strong>- существует x не равный y, такой что h(x) = h(y).</p><p id="24d787a3-106b-46f7-b3e7-87f5a39f8c9c" class=""><strong>Разрешение коллизий (collision resolution) </strong>в хеш-таблице, задача, решаемая несколькими способами: метод цепочек, открытая адресация и т.д. Очень важно сводить количество коллизий к минимуму, так как это увеличивает время работы с хеш-таблицами.</p><p id="35c38797-3726-4322-bd4a-65c1078d6358" class=""><strong>Разрешение коллизий с помощью цепочек</strong></p><ul id="aaf3d1da-3d97-4af7-89af-2f4999e6c429" class="bulleted-list"><li style="list-style-type:disc">Каждая ячейка <em>i </em> массива <em>H</em> содержит указатель на начало списка всех элементов, хеш-код которых равен <em>i</em>, либо указывает на их отсутствие. Коллизии приводят к тому, что появляются списки размером больше одного элемента.</li></ul><ul id="75a73891-c9f7-445b-bd3b-e1864039dec1" class="bulleted-list"><li style="list-style-type:disc">В зависимости от того нужна ли нам уникальность значений операция вставки у нас будет работать за разное время. Если не важна, то мы используем список, время вставки в который будет в худшем случае равна <em><em><em><em><em>O(1)</em></em></em></em></em>. Иначе мы проверяем есть ли в списке данный элемент, а потом в случае его отсутствия мы его добавляем. В таком случае вставка элемента в худшем случае будет выполнена за <em><em><em><em><em>O(n).</em></em></em></em></em></li></ul><ul id="5403ad70-82c5-4457-96c8-c6f14492b10b" class="bulleted-list"><li style="list-style-type:disc">Время работы поиска в наихудшем случае пропорционально длине списка, а если все <em><em>n </em></em>ключей захешировались в одну и ту же ячейку (создав список длиной <em>n</em>) время поиска будет равно <em><em><em><em><em>O(n) </em></em></em></em></em>плюс время вычисления хеш-функции, что ничуть не лучше, чем использование связного списка для хранения всех <em>n</em> элементов.</li></ul><ul id="733f64e7-2e0e-4396-b0cc-bcf004db3136" class="bulleted-list"><li style="list-style-type:disc">Удаления элемента может быть выполнено за <em><em><em>O(1)</em></em></em>, как и вставка, при использовании двухсвязного списка.</li></ul><figure id="bfd77130-97a8-40a7-aa8f-eb92351e81ab" class="image" style="text-align:center"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2021.png"><img style="width:485px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2021.png"/></a></figure><p id="31253dd1-5d80-4262-9dd5-448087d9a190" class="">К слову, на этом методе основаны словарь в Python и хэш-таблицы или отображения (map) в других языках. Так, в словаре в Python изначально содержится 8 корзин (bucket), каждая из которых представляет собой связный список. При необходимости создания новой корзины их количество (как правило) удваивается.</p><p id="5372ec74-cbc5-400f-9140-2636c222c26d" class=""><strong>Открытая адресация</strong></p><p id="7350eee4-2c89-446c-a1f8-d6362cab26dd" class="">Все элементы хранятся непосредственно в хеш-таблице, без использования связных списков. В отличие от хеширования с цепочками, при использовании этого метода может возникнуть ситуация, когда хеш-таблица окажется полностью заполненной, следовательно, будет невозможно добавлять в неё новые элементы. Так что при возникновении такой ситуации решением может быть динамическое увеличение размера хеш-таблицы, с одновременной её перестройкой.</p><ul id="37f08a45-5397-4c4f-ad2c-a927427e19b1" class="bulleted-list"><li style="list-style-type:disc">Последовательный поиск</li></ul><p id="f87700a4-de70-4e24-baef-6c014974e329" class="">При попытке добавить элемент в занятую ячейку <em><em>i </em></em>начинаем последовательно просматривать ячейки <em><em>i + 1, i + 2, i + 3 </em></em>и так далее, пока не найдём свободную ячейку. В неё и запишем элемент.</p><figure id="5bbdf792-926a-43fa-8a53-8d2fa4440e51" class="image" style="text-align:center"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2022.png"><img style="width:446px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2022.png"/></a></figure><ul id="48e33745-264e-4e51-afc6-4ea3cf1c76b1" class="bulleted-list"><li style="list-style-type:disc"><strong>Линейный поиск</strong></li></ul><p id="199998e4-e068-41f1-9e53-632e9c384c84" class="">Выбираем шаг <em>q</em>. При попытке добавить элемент в занятую ячейку <em>i</em> начинаем последовательно просматривать ячейки <em><em><em><em><em><em><em><em>i + (1 * q), i + (2 * q), i + (3 * q)</em></em></em></em></em></em></em></em> и так далее, пока не найдём свободную ячейку. В неё и запишем элемент. По сути последовательный поиск - частный случай линейного, где <em><em><em>q = 1</em></em></em>.</p><figure id="b0f84f57-4bb4-4cdc-aa4c-2eac5d784c34" class="image" style="text-align:center"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2023.png"><img style="width:328px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2023.png"/></a></figure><ul id="fb08ae83-9b7c-42c7-8c2e-33f6785bc4dd" class="bulleted-list"><li style="list-style-type:disc"><strong>Квадратичный поиск</strong></li></ul><p id="60b093a0-ecdf-4831-9505-49c5096a611d" class="">Шаг  <em>q</em> не фиксирован, а изменяется квадратично: <em><em><em><em><em><em><em><em>q = 1, 4, 9, 16</em></em></em></em></em></em></em></em>. Соответственно при попытке добавить элемент в занятую ячейку <em>i</em> начинаем последовательно просматривать ячейки <em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>i + 1, i + 4, i + 9 </em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>и так далее, пока не найдём свободную ячейку.</p><figure id="b6a987e2-d344-461f-8dc5-619dd89a65e5" class="image" style="text-align:center"><a href="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2024.png"><img style="width:371px" src="%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%20%D0%B8%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%200b86ba2ef4604a52bc9137c655b29632/Untitled%2024.png"/></a></figure></details></li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>