<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>ООП</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(249, 228, 188, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="b327b853-e594-47b6-b455-e9de1dff0c58" class="page sans"><header><img class="page-cover-image" src="https://i.pinimg.com/originals/9f/85/0a/9f850aaeba4288a615793c6045360cea.jpg" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">👨‍💻</span></div><h1 class="page-title">ООП</h1><p class="page-description"></p></header><div class="page-body"><ul id="be37fa94-5162-4f36-be09-15581070afc2" class="toggle"><li><details open=""><summary>1. Объекты и классы. Атрибуты, свойства, методы. Агрегация и композиция.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="eda26d0b-d2db-4018-b7d2-ce43b5978792"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Класс</strong></span> — шаблон или чертеж объектов (экземпляров), только их описание<br/><br/><span style="border-bottom:0.05em solid"><strong>Объект или экземпляр</strong></span><strong> </strong>— что-то конкретное, созданное по шаблону класса<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6df04e92-cc64-4117-9706-88e69d999097" class="code"><code class="language-Python"># пример
class Human:  # человек - класс, шаблон
		pass      # пустой для упрощения примера

# Вася Пупкин - объект или экземпляр класса человек (конкретный человек)
vasyaPupkin = Human()</code></pre></div></figure><h3 id="4ad73e24-2ec9-4335-ac51-bf47c12e112a" class=""><span style="border-bottom:0.05em solid">Атрибуты, свойства и методы</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="61e81b18-09cd-4834-9826-f2e3a0e30e2b"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Атрибут или поле</strong></span> — переменная, которая хранит данные класса (общие данные для всех экземпляров) или конкретного экземпляра</div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="dfb88343-f74b-439b-9bc0-19a026b16784" class="code"><code class="language-Python">class Triangle:
		# атрибут класса
		sides_count = 3

		def __init__(self, a: int, b: int, c: int) -&gt; None:
				&quot;&quot;&quot;Triangle constructor. 

				Args:
						a (int): first side length.
						b (int): second side length.
						c (int): third side length.
				&quot;&quot;&quot;
				# атрибуты экземпляра
				self.a = a
				self.b = b
				self.c = c


triangle = Triangle(a=1, b=2, c=3)
# обращаться к атрибутам класса и экземпляра можно через точку
print(triangle.a, triangle.b, triangle.c)  # 1 2 3
print(triangle.sides_count)                # 3

# в атрибуте __dict__ находится словарь из всех атрибутов и методов
print(Triangle.__dict__)
# {&#x27;__module__&#x27;: &#x27;__main__&#x27;, 
# &#x27;sides_count&#x27;: 3, 
# &#x27;__init__&#x27;: &lt;function Triangle.__init__ at 0x1005a5580&gt;, 
# &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Triangle&#x27; objects&gt;, 
# &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Triangle&#x27; objects&gt;, 
# &#x27;__doc__&#x27;: None}
print(triangle.__dict__)
# {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3}</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="18dfa1ad-d8e3-4d90-a419-877d63b39954"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Свойство</strong></span> — атрибут, у которого изменён механизм получения (геттер) и установки/изменения (сеттер) значения<br/><br/>Свойство может:<br/>- запретить получение значения<br/>- запретить установку/изменение значения<br/>- сделать проверку значения перед его установкой/изменением<br/>- сделать значение по умолчанию<br/></div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bc675979-2662-4bf0-b015-fc3704d04595" class="code"><code class="language-Python">class Triangle:
		sides_count = 3

		def __init__(self, a: int, b: int, c: int) -&gt; None:
				&quot;&quot;&quot;Triangle constructor. 

				Args:
						a (int): first side length.
						b (int): second side length.
						c (int): third side length.
				&quot;&quot;&quot;
				# обычные атрибуты экземпляра, можно получать и устанавливать
				self.a = a
				self.b = b
				self.c = c

		# свойство perimeter, позволяет получать, но запрещает устанавливать
		@property
		def perimeter(self):
				return self.a + self.b + self.c


triangle = Triangle(a=1, b=2, c=3)

try:
		triangle.perimeter = 1
except AttributeError as ae:
		print(ae)  # property &#x27;perimeter&#x27; of &#x27;Triangle&#x27; object has no setter

print(triangle.perimeter)  # 6, до изменения сторон
triangle.a, triangle.b, trianble.c = 4, 7, 8
print(triangle.perimeter)  # 19, после изменения сторон</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="af4b121c-bd99-4fc1-9510-659851f11289"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Метод</strong></span> — функция, объявленная внутри класса<br/><br/>Метод может быть (см. билет 7):<br/>- абстрактный<br/>- статический<br/>- метод класса<br/>- метод экземпляра<br/></div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="664e4ebe-7d56-4c81-9f7d-f9efb2105661" class="code"><code class="language-Python">class Triangle:
		sides_count = 3

		def __init__(self, a: int, b: int, c: int) -&gt; None:
				&quot;&quot;&quot;Triangle constructor. 

				Args:
						a (int): first side length.
						b (int): second side length.
						c (int): third side length.
				&quot;&quot;&quot;
				self.a = a
				self.b = b
				self.c = c

		# метод экземпляра
		def is_equilateral(self) -&gt; bool:
				&quot;&quot;&quot;Check if triangle is equilateral.

				Returns:
						True if triangle is equilateral else False
				&quot;&quot;&quot;
				return self.a == self.b == self.c


triangle = Triangle(a=1, b=2, c=3)
print(triangle.is_equilateral())  # False</code></pre><h3 id="67f9ea29-3f64-464c-884b-193db842b865" class=""><span style="border-bottom:0.05em solid">Агрегация и композиция</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="832d09fe-0ced-4076-af77-6cf23a1f7bff"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Агрегация</strong></span> — тип отношений между классами, когда в одном классе используются независимые объекты другого класса (через внедрение зависимостей в метод или прямое присваивание)</div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="78c79f04-d56e-4ecf-8a68-3788f9362d7a" class="code"><code class="language-Python">class Book:
		def __init__(self, title: str, author: str) -&gt; None:
				self.title = title
				self.author = author

		def __repr__(self):
				return f&quot;&#x27;{self.title}&#x27; by {self.author}&quot;


class Library:
		def __init__(self, books: Optional[list[Book]] = None) -&gt; None:
				self.books = books
				if books is None:
						self.books = []

b1 = Book(&#x27;The story of success&#x27;, &#x27;Albert Tenigin&#x27;)
b2 = Book(&#x27;It&#x27;, &#x27;Stephen King&#x27;)
b3 = Book(&#x27;Harry Potter&#x27;, &#x27;Joanne Rowling&#x27;)

# внедрение зависимостей в конструктор (__init__)
lib = Library([b1, b2, b3])
print(lib.books)
# [&#x27;The story of success&#x27; by Albert Tenigin,
#  &#x27;It&#x27; by Stephen King, &#x27;Harry Potter&#x27; by Joanne Rowling]

# прямое присваивание
lib = Library()
lib.books = [b1, b2, b3]
print(lib.books)
# [&#x27;The story of success&#x27; by Albert Tenigin,
#  &#x27;It&#x27; by Stephen King, &#x27;Harry Potter&#x27; by Joanne Rowling]</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="f20fc8ce-63a2-4504-bba4-15f47be5574f"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Композиция</strong></span> — тип отношений между классами, когда в одном классе создаются зависимые объекты другого класса</div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4151e29b-5347-405e-bc11-d91b3ab1c9a1" class="code"><code class="language-Python"># В этом примере предпочтительней использовать агрегацию для большей гибкости
class Book:
		def __init__(self, title: str, author: str) -&gt; None:
				self.title = title
				self.author = author

		def __repr__(self):
				return f&quot;&#x27;{self.title}&#x27; by {self.author}&quot;


class Library:
		def __init__(self) -&gt; None:
				self.books = [
						Book(&#x27;The story of success&#x27;, &#x27;Albert Tenigin&#x27;),
						Book(&#x27;It&#x27;, &#x27;Stephen King&#x27;),
						Book(&#x27;Harry Potter&#x27;, &#x27;Joanne Rowling&#x27;),
				]

lib = Library()
print(lib.books)
# [&#x27;The story of success&#x27; by Albert Tenigin,
#  &#x27;It&#x27; by Stephen King, &#x27;Harry Potter&#x27; by Joanne Rowling]</code></pre></details></li></ul><ul id="0aee93c9-cbf7-421e-aad8-ff07687b1d4c" class="toggle"><li><details open=""><summary>2. Принципы ООП. Принципы проектирования DRY, KISS, и SOLID.</summary><h3 id="f9b0fd1c-2f11-4d06-8b48-2329aea2e10e" class=""><span style="border-bottom:0.05em solid">Принципы ООП</span></h3><figure id="434abae1-d88e-40bb-80c7-be277541709f" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled.png"/></a><figcaption>мЭм by Алина</figcaption></figure><ul id="30209802-cb19-47f4-82e1-325ae7f7461e" class="bulleted-list"><li style="list-style-type:disc"><em>инкапсуляция</em> — вся информация, необходимая для работы конкретного объекта, должна скрыто храниться внутри него. Для внешних объектов доступны только публичные атрибуты и методы.<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="21ff6b92-e5e7-42b0-afe7-e293aead89e2" class="code"><code class="language-Python"># в Python есть 3 модификатора доступа к атрибутам и методам (см. билет 4)
class Book:
		def __init__(self, title, price):
				# доступ к названию книги и цене есть у всех
				self.title = title
				self.price = price
				# доступ к жанру имеют только дочерние классы (Roman)
				self._genre = None
				# доступ к серийному номеру книги есть только внутри класса
				self.__serial = title + str(price)

class Roman(Book):
		def __init__(self, title, price):
				super().__init__(title, price)
				self._genre = &#x27;Roman&#x27;</code></pre></li></ul><ul id="6837fa79-4c96-40e9-81c6-f08cc6aa9257" class="bulleted-list"><li style="list-style-type:disc"><em>наследование</em> — создание нового класса (дочернего) на основе существующего (родительского), дочерний класс перенимает атрибуты и методы родительского<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2675a46c-ce66-45b3-bb4d-a9ffe07f54d7" class="code"><code class="language-Python">class Book:
		def __init__(self, title, price):
				self.title = title
				self.price = price
				self._genre = None
				self.__serial = title + str(price)
		
		def print_info(self):
				print(f&#x27;Title: {self.title}&#x27;)
				print(f&#x27;Price: {self.price}&#x27;)

# роман наследует свойства и методы книги
class Roman(Book):
		def __init__(self, title, price, type):
				super().__init__(title, price)
				# добавляем новые атрибуты к родительским
				self.type = type
				self._genre = &#x27;Roman&#x27;
		
		# дополняем родительский метод print_info()
		def print_info(self):
				super().print_info()
				print(f&#x27;Type: {self.type}&#x27;)

my_book = Book(&#x27;My first book&#x27;, 100)
my_roman = Roman(&#x27;My first roman&#x27;, 200, &#x27;Historical&#x27;)

my_book.print_info()
# Title: My first book
# Price: 100
my_roman.print_info()
# Title: My first roman
# Price: 200
# Type: Historical</code></pre></li></ul><ul id="2e9b39a5-b191-41d8-a9f1-15a91140c6a9" class="bulleted-list"><li style="list-style-type:disc"><em>полиморфизм</em> — у разных объектов метод с одной целью и одним названием (например, delete), но работает он по-разному<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="81f99a5e-07d4-432f-8e94-3d80908398e5" class="code"><code class="language-Python">class Book:
		def __init__(self, title, price):
				self.title = title
				self.price = price
				self._genre = None
				self.__serial = title + str(price)
		
		# методы делают одно (выводят информацию), но по-разному
		def print_info(self):
				print(f&#x27;Title: {self.title}&#x27;)
				print(f&#x27;Price: {self.price}&#x27;)

class Computer:
		def __init__(self, cpu, gpu):
				self.cpu = cpu
				self.gpu = gpu
		
		# методы делают одно (выводят информацию), но по-разному
		def print_info(self):
				print(f&#x27;CPU: {self.cpu}&#x27;)
				print(f&#x27;GPU: {self.gpu}&#x27;)

my_book = Book(&#x27;My first book&#x27;, 100)
my_computer = Computer(&#x27;i9 13900K&#x27;, &#x27;RTX 4090&#x27;)

my_book.print_info()
# Title: My first book
# Price: 100
my_computer.print_info()
# CPU: i9 13900K
# GPU: RTX 4090</code></pre></li></ul><ul id="2fce8209-ede9-45e1-a446-abf90914cbe8" class="bulleted-list"><li style="list-style-type:disc"><em>абстракция </em>— создание минимального количества классов, методов и атрибутов, которые необходимы для выполнения задачи. Например, для программы, работающей с графическими объектами, можно создать абстрактный класс Shape (фигура) и от него наследовать расширяющие классы конкретных фигур: квадрат, круг, треугольник. Подробнее в билете 7</li></ul><h3 id="65d4d907-754c-42f6-b07b-81a83c2d8697" class=""><span style="border-bottom:0.05em solid">Принципы проектирования</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="eff8dd42-6103-4492-a9bd-cd535e10be48"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>DRY (Don’t Repeat Yourself)</strong></span> — “не повторяйся” — если код повторяется, то лучше вынести его в отдельный класс или функцию<br/><br/><span style="border-bottom:0.05em solid"><strong>KISS (Keep it simple, stupid)</strong></span> — “делай это проще, тупица” — если код класса/функции слишком сложный, лучше разбить его/её на несколько более простых<br/><br/><span style="border-bottom:0.05em solid"><strong>SOLID</strong></span> — 5 букв, 5 принципов более гибкого и масштабируемого кода</div></figure><h3 id="13afcbcc-c121-4bcb-a7f0-a34fc562d869" class=""><span style="border-bottom:0.05em solid">SOLID (бля, тут не всем понятно..)</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6233040b-93c5-4cc8-93a3-f8a2142be583"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%">Код написан очень упрощённо для простого понимания принципа</div></figure><ul id="5e713543-c3e3-41e6-a259-e5310e366689" class="bulleted-list"><li style="list-style-type:disc"><em>S (single responsibility principle)</em> — принцип единственной ответственности</li></ul><blockquote id="8eab01ce-4315-4a13-966f-fbf9827123f3" class=""><em>каждый класс должен выполнять ровно одну определенную задачу<br/>у него должна быть одна ”ответственность”<br/></em></blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="345d79ad-3932-42df-8283-5d891da4ba99" class="code"><code class="language-Python"># нарушает принцип
# класс, выполняющий 2 задачи: управление файлом (чтение и запись)
# и управление ZIP-архивом (сжать и распаковать)
class FileManager:
		def read():
				pass

		def write():
				pass
		
		def compress():
				pass
	
		def decompress():
				pass


# не нарушает принцип
# лучше разбить на 2 класса: управление файлом и управление ZIP-архивом
# у каждого из них одна ответственность (задача) 
class FileManager:
		def read():
				pass

		def write():
				pass

class ZipFileManager:
		def compress():
				pass
	
		def decompress():
				pass
</code></pre><figure id="36ffce12-2875-41af-bd85-2348a59ef287" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%201.png"><img style="width:672px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%201.png"/></a></figure><ul id="a3df4fff-d531-44a4-bfa1-2506426ad15e" class="bulleted-list"><li style="list-style-type:disc"><em>O (open-closed principle)</em><strong> </strong>— принцип открытости-закрытости</li></ul><blockquote id="d1200166-7e30-40b3-9631-7364ac5d6400" class=""><em>сущности программы (классы, модули, функции и т.д.) должны быть </em><mark class="highlight-teal"><em>открыты</em></mark><em> для расширения, но </em><mark class="highlight-red"><em>закрыты</em></mark><em> для модификации (изменения)</em></blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0199d177-1fdc-464e-a755-748146d8c108" class="code"><code class="language-Python"># нарушает принцип
# класс должен быть закрыт для модификации
from math import pi
class Shape:
    def __init__(self, shape_type, **kwargs):
				# если появится новая фигура - нужно будет модифицировать:
				# добавлять новый elif в конструктор
        self.shape_type = shape_type
        if self.shape_type == &quot;rectangle&quot;:
            self.width = kwargs[&quot;width&quot;]
            self.height = kwargs[&quot;height&quot;]
        elif self.shape_type == &quot;circle&quot;:
            self.radius = kwargs[&quot;radius&quot;]

    def calculate_area(self):
				# точно также в этом методе
        if self.shape_type == &quot;rectangle&quot;:
            return self.width * self.height
        elif self.shape_type == &quot;circle&quot;:
            return pi * self.radius**2


# не нарушает принцип
# класс открыт только для расширения
# если захотим добавить новую фигуру - создадим новый класс
# с собственным методом calculate_area
from abc import ABC, abstractmethod
from math import pi

class Shape(ABC):
    def __init__(self, shape_type):
        self.shape_type = shape_type

		# теперь этот метод закрыт для модификации (изменения)
		# его не нужно менять при добавлении новой фигуры,
		# нужно только расширить в соответствующем классе
    @abstractmethod
    def calculate_area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        super().__init__(&quot;circle&quot;)
        self.radius = radius

		# метод расширяется в дочернем классе
    def calculate_area(self):
        return pi * self.radius**2

class Rectangle(Shape):
    def __init__(self, width, height):
        super().__init__(&quot;rectangle&quot;)
        self.width = width
        self.height = height

		# метод расширяется в дочернем классе
    def calculate_area(self):
        return self.width * self.height</code></pre><figure id="af668447-170a-4aa7-8260-b58c79f9522e" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%202.png"><img style="width:750px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%202.png"/></a><figcaption>Левый робот был изменён, а не расширен как правый</figcaption></figure><ul id="b0a94f32-680e-4b20-b0b1-ec99fd97e018" class="bulleted-list"><li style="list-style-type:disc"><em>L (Liskov Substitution)</em> — принцип подстановки Барбары Лисков</li></ul><blockquote id="e89c1d35-0296-4476-98f3-347c367cdfb8" class=""><em>объекты родительского класса должны легко заменяться объектами дочернего класса</em></blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="49556130-4b6f-4651-91d2-19710e02fce8" class="code"><code class="language-Python"># нарушает принцип
# объект дочернего класса не может заменить объект родительского класса
class Car:
		def __init__(self, type):
				self.type = type

class PetrolCar(Car):
		def __init__(self, type):
				self.type = type

# стандарта для атрибута properties нет
my_car = Car(&#x27;SUV&#x27;)
my_car.properties = {&#x27;Color&#x27;: &#x27;Red&#x27;, &#x27;Gear&#x27;: &#x27;Auto&#x27;, &#x27;Capacity&#x27;: 6}
my_petrol_car = PetrolCar(&#x27;Sedan&#x27;)
my_petrol_car.properties = (&#x27;Blue&#x27;, &#x27;Manual&#x27;, 4)

cars = [my_car, my_petrol_car]
for car in cars:
		# ошибка, ведь my_petrol_car.properties - кортеж,
		# к которому нельзя обратиться по ключу как в родительском классе
		print(f&#x27;Car color: {car.properties[&quot;Color&quot;]}&#x27;)


# не нарушает принцип
# объект дочернего класса может заменить объект родительского класса
class Car:
		def __init__(self, type):
				self.type = type
				self.car_properties = {}
		
		# создали геттер и сеттер, теперь у properties единый вид
		def get_properties(self):
				return self.car_properties

		def set_properties(self, color, gear, capacity):
				self.car_properties = \
						{&#x27;Color&#x27;: color, &#x27;Gear&#x27;: gear, &#x27;Capacity&#x27;: capacity}

class PetrolCar(Car):
		def __init__(self, type):
				self.type = type

my_car = Car(&#x27;SUV&#x27;)
my_car.set_properties (&#x27;Red&#x27;, &#x27;Auto&#x27;, 6)
my_petrol_car = PetrolCar(&#x27;Sedan&#x27;)
my_petrol_car.set_properties(&#x27;Blue&#x27;, &#x27;Manual&#x27;, 4)

cars = [my_car, my_petrol_car]
for car in cars:
		# теперь ошибки не будет и дочерний класс может заменить родительский
		print(f&#x27;Car color: {car.get_properties()[&quot;Color&quot;]}&#x27;)</code></pre><figure id="074110d7-8d35-48eb-bae9-976ce096ef6c" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%203.png"><img style="width:752px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%203.png"/></a><figcaption>Сверху показана работа родительского робота Сэма — он готовит кофе по просьбе<br/>Слева его сын Иден нарушает принцип, ведь он не может заменить своего родителя Сэма<br/>А справа — не нарушает принцип, ведь он может заменить своего родителя Сэма<br/></figcaption></figure><ul id="52cbb4d6-6ad9-42b4-9023-bf0b8a92d130" class="bulleted-list"><li style="list-style-type:disc"><em>I (interface segregation)</em> — принцип разделения интерфейсов</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="fbe7613c-1c45-4b8a-ba52-2c3f9d9ed4f9"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Интерфейс</strong></span> — набор методов без реализации (пустых методов) для дочерних классов, которые обязаны их реализовать</div></figure><blockquote id="2a68576d-c813-4a6b-a74b-f3b306e551d2" class=""><em>не следует заставлять клиентов (то есть классов и подклассов) зависеть от интерфейсов, которые они не используют<br/>не следует создавать и полагаться на огромные БЛЯТЬ интерфейсы<br/></em></blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8756999d-e5a4-49d5-9d52-1ad63af209f7" class="code"><code class="language-Python"># нарушает принцип, 
from abc import ABC, abstractmethod

# интерфейс, описывает методы, которые должны реализовать дочерние классы
class Printer(ABC):
    @abstractmethod
    def print(self, document):
        pass

    @abstractmethod
    def fax(self, document):
        pass

    @abstractmethod
    def scan(self, document):
        pass

# OldPrinter зависит от методов fax и scan, которые он не использует,
# поскольку старые принтеры не поддерживают эти функции
class OldPrinter(Printer):
    def print(self, document):
        print(f&quot;Printing {document} in black and white...&quot;)

    def fax(self, document):
        raise NotImplementedError(&quot;Fax functionality not supported&quot;)

    def scan(self, document):
        raise NotImplementedError(&quot;Scan functionality not supported&quot;)

class ModernPrinter(Printer):
    def print(self, document):
        print(f&quot;Printing {document} in color...&quot;)

    def fax(self, document):
        print(f&quot;Faxing {document}...&quot;)

    def scan(self, document):
        print(f&quot;Scanning {document}...&quot;)


# не нарушает принцип
from abc import ABC, abstractmethod

# разделили один огромный интерфейс на 3 маленьких
class Printer(ABC):
    @abstractmethod
    def print(self, document):
        pass

class Fax(ABC):
    @abstractmethod
    def fax(self, document):
        pass

class Scanner(ABC):
    @abstractmethod
    def scan(self, document):
        pass

# OldPrinter больше не зависит от неиспользуемых интерфейсов
class OldPrinter(Printer):
    def print(self, document):
        print(f&quot;Printing {document} in black and white...&quot;)

class NewPrinter(Printer, Fax, Scanner):
    def print(self, document):
        print(f&quot;Printing {document} in color...&quot;)

    def fax(self, document):
        print(f&quot;Faxing {document}...&quot;)

    def scan(self, document):
        print(f&quot;Scanning {document}...&quot;)</code></pre><figure id="7167c4fc-73fb-49ad-8e3f-882def419abb" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%204.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%204.png"/></a><figcaption>Левые роботы зависят от методов, которые они не используют/не умеют<br/>Правые роботы не зависят от методов, которые они не используют<br/></figcaption></figure><ul id="27a86289-7569-4b30-9a85-739424075323" class="bulleted-list"><li style="list-style-type:disc"><em>D (dependency inversion)</em> — инверсия зависимостей</li></ul><blockquote id="70fc9951-6d14-4038-ae1c-5d50801467df" class=""><em>Классы не должны полагаться на другие классы, а должны зависеть от абстракций<br/>Абстракции не должны зависеть от деталей (специфических характеристик классов). Детали должны зависеть от абстракций.<br/></em></blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="804f74c6-0420-4c07-bc38-ccc54ca668ef" class="code"><code class="language-Python"># нарушает принцип
# FrontEnd зависит от методов BackEnd
class FrontEnd:
    def __init__(self, back_end):
        self.back_end = back_end

    def display_data(self):
				# если методы BackEnd изменяться или добавятся, 
				# то придётся менять FrontEnd, 
				# что не соответствует принципу открытости-закрытости
        data = self.back_end.get_data_from_database()
        print(&quot;Display data:&quot;, data)

class BackEnd:
    def get_data_from_database(self):
        return &quot;Data from the database&quot;


# не нарушает принцип
# FrontEnd и BackEnd зависят от абстракций, а не друг от друга
from abc import ABC, abstractmethod

class FrontEnd:
    def __init__(self, data_source):
        self.data_source = data_source

    def display_data(self):
				# теперь зависит от абстракции, а не от BackEnd
        data = self.data_source.get_data()
        print(&quot;Display data:&quot;, data)

# абстракция, от которой зависят BackEnd и FrontEnd
# абстракция никак не зависит от деталей BackEnd и FrontEnd
class DataSource(ABC):
    @abstractmethod
    def get_data(self):
        pass

# добавили получение данных из API, кроме базы данных
class Database(DataSource):
    def get_data(self):
        return &quot;Data from the database&quot;

class API(DataSource):
    def get_data(self):
        return &quot;Data from the API&quot;</code></pre><figure id="4d655ff1-a82c-45de-9031-f254e1b7cf9c" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%205.png"><img style="width:1560px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%205.png"/></a><figcaption>Левый робот зависит от руки-пилы, чтобы порезать пиццу<br/>Правый робот не зависит от руки-пилы, он через абстракцию (место для инструмента) берёт инструмент, которым уже режет пиццу. Абстракция не зависит от инструмента, а инструмент зависит от абстракции, должен подходить к ней <br/></figcaption></figure></details></li></ul><ul id="f5548a10-507c-40d1-b012-9d532015f1b3" class="toggle"><li><details open=""><summary>3. Объекты и классы. Конструкторы и деструкторы. Счётчик ссылок и сборщик мусора.</summary><h3 id="1a2e481b-9656-498b-a237-f2580db3506f" class=""><span style="border-bottom:0.05em solid">Объекты и классы</span></h3><p id="887281ec-2e64-4925-aac4-6550b2b14d74" class="">См. билет 1.</p><h3 id="6b1bad74-ca72-40f1-917e-440351f764c2" class=""><span style="border-bottom:0.05em solid">Конструкторы и деструкторы</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="deddb64a-ee03-464d-af08-edd92063cdd7"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Конструктор</strong></span> — метод, который автоматически вызывается при создании нового экземпляра класса<br/>В Python это магический метод <br/><code>__init__</code></div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d5323322-abf1-4afd-9425-fc5fd956d1fe" class="code"><code class="language-Python">class Message:
		# конструктор
		def __init__(self, author, text):
				# обычно используют для присваивания атрибутов экземпляру
				self.author = author
				self.text = text</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a7e77194-a157-4ca9-98f2-cf29c625bd3b"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Деструктор</strong></span> — метод, который автоматически вызывается при уничтожении экземпляра класса сборщиком мусора<br/>В Python это магический метод <br/><code>__del__</code></div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="be585a87-e5db-4b64-88c3-897fadb3a24e" class="code"><code class="language-Python">class Message:
		def __init__(self, author, text):
				self.author = author
				self.text = text

		def __del__(self):
				print(&#x27;Message deleted&#x27;)</code></pre><h3 id="2de9b401-07c4-4afc-acd4-17ee9522cd37" class=""><span style="border-bottom:0.05em solid">Счётчик ссылок и сборщик мусора (механизмы освобождения памяти)</span></h3><p id="05d1e828-e271-423a-881f-73f5a5721294" class="">Как выглядит создание переменной:</p><ul id="6ca85897-f1e8-4096-b128-53942d8843cb" class="bulleted-list"><li style="list-style-type:disc">создаётся объект со значением в памяти</li></ul><ul id="a5c89894-d663-49dd-a959-5e8ec844896d" class="bulleted-list"><li style="list-style-type:disc">в переменную кладётся ссылка на этот объект в памяти</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="63f8c788-fbb3-40bd-9e73-71e65d06b7dc"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Счётчик ссылок</strong></span> — специальный атрибут у каждого объекта, хранящий количество ссылок на него<br/><br/>Счётчик <br/><mark class="highlight-teal"><strong>увеличивается</strong></mark>, когда объект присваивается переменной или становится частью списка. Счётчик <mark class="highlight-red"><strong>уменьшается</strong></mark>, когда удаляется переменная или функция с переменной завершает свою работу.<br/><br/>Однако механизм не умеет определять циклические ссылки, когда объекты ссылаются друг на друга, а значит счётчик у объектов никогда не будет равен 0<br/></div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="025e3b7c-20b0-4b6e-a3ef-bbf28336cef4" class="code"><code class="language-Python"># getrefcount() позволяет получить значение счётчика ссылок
from sys import getrefcount

class Message:
		pass

# создаём объект Message, ссылка на него кладётся в m1
m1 = Message()
# 2, так как m1 как аргумент функции - тоже ссылка на объект
print(getrefcount(m1))

all_messages = [m1, m1]
# 4, так как в списке 2 ссылки на объект
print(getrefcount(m1))

del all_messages
# 2, так как удалили список с 2 ссылками на объект
print(getrefcount(m1))</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="f96a71bd-d952-4aca-a5f4-786694d41e87"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Сборщик мусора</strong></span> — механизм, удаляющий неиспользуемые объекты (объекты со счётчиком ссылок = 0) и объекты с циклическими ссылками из памяти во время выполнения программы<br/><br/>Сборщик мусора, в отличие от счётчика ссылок, работает не всё время, а периодически. Каждый его запуск создаёт микропаузы, поэтому у него специальный алгоритм:<br/><ul id="6bbf96ad-5072-47f7-b292-b18ff1adb879" class="bulleted-list"><li style="list-style-type:disc">всего существует 3 поколения</li></ul><ul id="6e585a61-f141-415f-9509-84378d45c59d" class="bulleted-list"><li style="list-style-type:disc">новые объекты попадают в первое поколение, ведь часто у них маленький срок жизни (временные объекты)</li></ul><ul id="a14b07dc-070b-49f4-ba85-cb16d6c6b39a" class="bulleted-list"><li style="list-style-type:disc">если объект выживает процесс сборки мусора, он перемещается в следующее поколение, которое реже сканируется</li></ul></div></figure></details></li></ul><ul id="e7bcd1d7-9546-46ca-9336-963e51d96edd" class="toggle"><li><details open=""><summary>4. <mark class="highlight-default">Модификаторы доступа.</mark><mark class="highlight-yellow"> </mark>Геттеры и сеттеры. Property.</summary><h3 id="31a85604-ea8b-4d76-be03-3d27612b8e94" class=""><span style="border-bottom:0.05em solid">Модификаторы доступа</span></h3><p id="8051e621-ab2a-4f77-9237-a0c6546aac20" class="">Модификаторы доступа используются для модификации доступа к атрибутам и методам класса/экземпляра:</p><ul id="020fd4df-1240-48e8-ae18-79837fc925b6" class="bulleted-list"><li style="list-style-type:disc"><em>public</em> — публичные атрибуты, можно использовать вне класса</li></ul><ul id="d9c58fd6-5c93-4e32-bc90-054908f1e920" class="bulleted-list"><li style="list-style-type:disc"><em>protected</em> — защищенные атрибуты, можно использовать внутри класса, дочерних классов и ТОЛЬКО при необходимости вне класса</li></ul><ul id="a5d68e0c-9cfc-437e-9111-cc2b99d67621" class="bulleted-list"><li style="list-style-type:disc"><em>private</em> — закрытые атрибуты, можно использовать ТОЛЬКО внутри класса</li></ul><p id="c3f2ebbe-0ba0-4461-9c60-4961f6ce1b4e" class="">Python не предоставляет системы строгой инкапсуляции и поэтому у объектов в нем существуют только публичные атрибуты. Однако существует общепринятое соглашение называть атрибуты и методы, предназначенные для внутреннего использования, с нижнего подчеркивания (например, <code>_penis</code>).</p><h3 id="6b824769-cdc2-41dd-a70a-08bf76de64ba" class=""><span style="border-bottom:0.05em solid"><strong>Геттеры и сеттеры</strong></span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="5c2d36d9-92e2-4f7e-99b5-a2b9af2c78f8"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Геттер</strong></span> — метод, позволяющий получить значение атрибута<br/><br/><span style="border-bottom:0.05em solid"><strong>Сеттер</strong></span> — метод, позволяющий установить/изменить значение атрибута</div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8c95bb86-adc8-4990-b8e8-ab3153f86abe" class="code"><code class="language-Python">class Book:
		def __init__(self, title: str):
				self.set_title(title)

		# простой геттер, можно усложнить
		def get_title(self) -&gt; str:
				# закрытый атрибут, доступ к нему только через геттер и сеттер
				return self._title
	
	# простой сеттер, можно усложнить
		def set_title(self, new_title: str) -&gt; None:
				if not isinstance(new_title, str):
						raise ValueError(&#x27;New title is not str&#x27;)
				# закрытый атрибут, доступ к нему только через геттер и сеттер
				self._title = new_title


my_book = Book(&#x27;Hello world&#x27;)
# получить доступ или изменить title напрямую нельзя из-за модификатора
print(my_book._title)         # AttributeError
my_book._title = &#x27;My book 2&#x27;

# но можно через геттер и сеттер
print(my_book.get_title())     # Hello World
my_book.set_title(&#x27;My book 2&#x27;)
print(my_book.get_title())     # My book 2</code></pre><h3 id="579a9c7b-b1ee-49b1-a302-e5059c82806d" class=""><span style="border-bottom:0.05em solid">Property</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="b1949732-d7c0-49b9-bf9a-4ed6d69ae1f8"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Property</strong></span> — класс и декоратор, который используется для создания методов доступа к атрибутам класса. Например, можно определить геттер и сеттер для атрибута класса.</div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="fcb59401-562a-44a9-bb41-ab0d0f248f7a" class="code"><code class="language-Python"># геттер и сеттер с помощью класса
class Book:
		def __init__(self, title: str):
				self.title = title

		def get_title(self) -&gt; str:
				return self._title
	
		def set_title(self, new_title: str) -&gt; None:
				if not isinstance(new_title, str):
						raise ValueError(&#x27;New title is not str&#x27;)
				self._title = new_title
 
		title = property(get_title, set_title)

# геттер и сеттер с помощью декоратора
class Book:
		def __init__(self, title: str):
				self.title = title

		# название атрибута и функции должны совпадать
		@property
		def title(self) -&gt; str:
				return self._title
		
		# название атрибута, функции и декоратора должны совпадать
		@title.setter
		def title(self, new_title: str) -&gt; None:
				if not isinstance(new_title, str):
						raise ValueError(&#x27;New title is not str&#x27;)
				self._title = new_title

# теперь геттер и сеттер работают автоматически
my_book = Book(&#x27;Hello world&#x27;)
print(my_book.title)   # Hello world
my_book.title = &#x27;My book 2&#x27;
print(my_book.title)   # My book 2</code></pre></details></li></ul><ul id="dc80c9fb-60a6-4d6a-a498-0a11bd30fc10" class="toggle"><li><details open=""><summary>5. Объектная модель программирования в python. Классовая иерархия и организация наследования. Множественное наследование. <mark class="highlight-default">super</mark>.</summary><h3 id="aac7b087-7967-455e-b4fb-d0f871c9c0e1" class=""><span style="border-bottom:0.05em solid">Объектная модель программирования в Python</span></h3><p id="cad9dd97-cdcd-4f64-b1eb-c62105e1eeda" class="">Python — объектно-ориентированный язык программирования. В нём всё (переменная, функция и т.д.) является объектом определённого класса. Даже, например, целое число является экземпляром класса целых чисел <code>int</code>.</p><h3 id="22b63344-30f9-43d6-b7cb-6d0d74a3c57f" class=""><span style="border-bottom:0.05em solid">Классовая иерархия и организация наследования</span></h3><p id="3b2d254e-9feb-4f97-85e5-5027f03b9e3b" class="">Базовым классом в Python для всех классов является <code>object</code>. Именно в нём содержатся все основные готовые методы для корректной работы класса: <code>__new__</code>, <code>__init__</code>, <code>__getattr__</code>, <code>__setattr__</code>, <code>__repr__</code> и другие. При создании собственного класса он по умолчанию будет наследоваться от <code>object</code>.</p><h3 id="7d104bd6-1061-464e-852f-ba57fa42a130" class=""><span style="border-bottom:0.05em solid">Множественное наследование</span></h3><p id="2e478d2f-754d-4550-940d-bd084d687366" class="">В Python можно наследоваться сразу от нескольких классов. У каждого класса есть специальный атрибут <code>__mro__</code>, в котором находится порядок поиска метода в родительских классах. </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6d13df40-c53c-488e-b3f0-a624ac81e38e" class="code"><code class="language-Python">class Base1:
		def foo(self):
				print(&#x27;Called in Base1&#x27;)

class Base2:
		def foo(self):
				print(&#x27;Called in Base2&#x27;)

# этот класс наследуется от двух классов: Base1 и Base2
class MultiDerived(Base1, Base2):
		pass

m = MultiDerived()
m.foo()  # Called in Base1, по MRO первым нашли foo() в Base1

# по MRO сначала ищем вызванный метод в MultiDerived,
# если не нашли переходим в Base1, затем в Base2 и наконец в object
print(MultiDerived.__mro__)
# (&lt;class &#x27;__main__.MultiDerived&#x27;&gt;, &lt;class &#x27;__main__.Base1&gt;, 
#  &lt;class &#x27;__main__.Base2&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</code></pre><h3 id="4464e7a3-07bb-4d9c-96c7-84c1435e1ce7" class=""><span style="border-bottom:0.05em solid">Super</span></h3><p id="6371c888-6cc7-4dc7-8649-333c6bf342e8" class="">Функция <code>super</code> даёт доступ к оригиналам наследованных методов. Она возвращает объект-посредник, через который можно обращаться к методам следующего по очереди класса в MRO. Функция полезна, когда нужно дополнить метод родительский класс, а не изменить его целиком.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a4000bae-276a-4a8a-9953-a71fe2345f0b" class="code"><code class="language-Python"> class Book:
		def __init__(self, title, price):
				self.title = title
				self.price = price
		
		def print_info(self):
				print(f&#x27;Title: {self.title}&#x27;)
				print(f&#x27;Price: {self.price}&#x27;)

# роман наследует свойства и методы книги
class Roman(Book):
		def __init__(self, title, price, type):
				super().__init__(title, price)
				# дополняем конструктор Book новым атрибутом
				self.type = type
		
		# дополняем родительский метод print_info()
		def print_info(self):
				super().print_info()
				print(f&#x27;Type: {self.type}&#x27;)</code></pre></details></li></ul><ul id="670a3114-d134-4851-9f70-6d06337fcbd6" class="toggle"><li><details open=""><summary>6. Тестирование кода. Классы исключений. Исключения в Python.<mark class="highlight-default"> Группы исключений. </mark>Объявление, отслеживание, тестирование.</summary><h3 id="b8c8fb49-20c9-4eb3-87b9-62cd06d679d1" class=""><span style="border-bottom:0.05em solid">Тестирование кода</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="3d99fad8-c8a7-404d-b266-a9e7ff278aef"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Тестирование кода</strong></span> — один из этапов разработки ПО перед его выпуском, в котором идёт различная проверка ПО:<br/>- отдельных его модулей (юнит или модульное тестирование)<br/>- нескольких модулей вместе (интеграционное тестирование)<br/>- критически важных функций перед выпуском новой версии (дымовое)<br/>- и другие<br/><br/>Часто используют автоматические тесты (автотесты) для сокращения времени тестирования и упрощения процесса. Самым популярным фреймворком для них является <br/><code>pytest</code>. </div></figure><h3 id="3766f759-1086-465d-910a-81f454c7e2a9" class=""><span style="border-bottom:0.05em solid">Классы исключений. Исключения в Python</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="ed11bb06-043d-40f7-9d44-dae6992071ed"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Класс исключения</strong></span> — класс, экземпляр которого будет определённым типом исключения. Обязан напрямую или косвенно (через дополнительные классы) наследоваться от класса <code>BaseException</code><strong><br/><br/><br/></strong>Хорошие практики:<ul id="8fb00820-eb96-47f9-ad10-50476acf9868" class="bulleted-list"><li style="list-style-type:disc">выносить все классы исключений в отдельный файл</li></ul><ul id="55b4fe3e-fa0d-4172-a98d-a02a4b0988bb" class="bulleted-list"><li style="list-style-type:disc">давать классам исключений имена, оканчивающиеся на “Error”</li></ul></div></figure><p id="608dc4f5-47f4-4067-8c93-1666c0b28680" class="">Виды исключений:</p><ul id="667ecaa1-9ac0-491a-9ccd-5e8a36930c78" class="bulleted-list"><li style="list-style-type:disc">системные исключения — их обработку лучше не делать (или чётко понимать для чего делать)<ul id="6ad7f833-ceb2-49a0-a977-a2230e688639" class="bulleted-list"><li style="list-style-type:circle"><code>SystemExit</code> – создаётся функцией sys.exit()</li></ul><ul id="04f7ebc4-bfc9-4d2b-810b-1e9921d1b31e" class="bulleted-list"><li style="list-style-type:circle"><code>KeyboardInterrupt</code> – создаётся при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C)</li></ul><ul id="55ca2104-f4a4-4d3b-bd97-97e1fb83a75c" class="bulleted-list"><li style="list-style-type:circle"><code>GeneratorExit</code> — создаётся при вызове метода .close() генератора</li></ul></li></ul><ul id="b7901204-8dc0-4640-bc39-120dc6e7d308" class="bulleted-list"><li style="list-style-type:disc">обыкновенные исключения (<code>Exception</code> и дочерние от него) — их обработку можно и часто даже нужно делать<ul id="2db16118-56fb-4465-a918-a3d741274e40" class="bulleted-list"><li style="list-style-type:circle">существует много готовых исключений (<code>ValueError</code>, <code>TypeError</code> и т.д.)</li></ul><ul id="a5264b4b-ad92-49ac-95f3-343001579fad" class="bulleted-list"><li style="list-style-type:circle">можно создать свой класс исключения для более точного описания произошедшей ситуации</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d442d84e-b962-4c6b-be1b-f57506f5b525" class="code"><code class="language-Python"># свой класс исключения
class CustomError(Exception):
		def __init__(self, text=&quot;Unknown error&quot;):
				super().__init__(text)

# вызов своего исключения
raise CustomError()  # __main__.CustomError: Unknown error
raise CustomError(&#x27;Testing&#x27;)  # __main__.CustomError: Testing</code></pre></li></ul><h3 id="564c8835-a36b-453e-9f99-523d594c8b61" class=""><span style="border-bottom:0.05em solid">Группы исключений</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="c5258875-2900-4cb1-abe5-b004c121e03a"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Группа исключений (появилась в Python 3.11)</strong></span> — группа нескольких различных видов исключений. Это может быть полезно при:<br/>- одновременных сбоях параллельных задач<br/>- ошибке в коде-обёртке (например, декораторе)<br/>- множестве ошибок в сложном вычислении<br/></div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="04858c48-ab56-42d8-ba14-aae3ffbc40a4" class="code"><code class="language-Python">try:
		# группа с описанием &quot;eg&quot; и 4 ошибками
		raise ExceptionGroup(&#x27;eg&#x27;,
				[ValueError(1), TypeError(2), OSError(3), OSError(4)])
# с обычными except оператор завершается после нахождения совпадения
# с except* можно обработать несколько исключений из группы, 
# но каждое из них обработается только один раз
except* TypeError as e:
		print(f&#x27;caught {type(e)} with nested {e.exceptions}&#x27;)
# каждый except* выполнится только один раз и обработает все
# подходящие исключения в группе
except* OSError as e:
		print(f&#x27;caught {type(e)} with nested {e.exceptions}&#x27;)

# caught &lt;class &#x27;ExceptionGroup&#x27;&gt; with nested (TypeError(2),)
# caught &lt;class &#x27;ExceptionGroup&#x27;&gt; with nested (OSError(3), OSError(4))
# одна необработанная ошибка вызвала исключение
#   + Exception Group Traceback (most recent call last):
#   |   File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
#   | ExceptionGroup: eg
#   +-+---------------- 1 ----------------
#     | ValueError: 1
#     +-----------------------------------


# группы исключений могут быть вложенные
raise ExceptionGroup(&#x27;eg&#x27;, [
		ValueError(1), TypeError(2), OSError(3), OSError(4),
		ExceptionGroup(&#x27;eg2&#x27;, [
				ValueError(5), TypeError(6), OSError(7)
		])
])</code></pre><h3 id="b0929af6-28cb-444c-8ca0-cce5bc03b441" class=""><span style="border-bottom:0.05em solid">Объявление, отслеживание, тестирование</span></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ec13f4f2-6664-4370-bf59-fcc9a471522d" class="code"><code class="language-Python"># объявление своего класса исключений
class CustomError(Exception):
		def __init__(self, text=&quot;Unknown error&quot;):
				super().__init__(text)

# вызов готового и своего исключения
raise ZeroDivisionError(&#x27;Division by zero, dude&#x27;)
raise CustomError(&#x27;Testing&#x27;)  # __main__.CustomError: Testing

# отслеживание исключений
try:
		# если в процессе выполнения блока кода
		print(2 / 0)
# появится исключение ZeroDivisionError, то выполнится код
# иначе код продолжит выполняться как обычно
except ZeroDivisionError:
		print(0)

# тестирование исключений через декоратор pytest
# если при выполнении теста-функции 
# не выйдет ошибка ZeroDivisionError - тест провалится
@pytest.mark.xfail(raises=ZeroDivisionError)
def test_zerodivision():
		print(2 / 0)

# тестирование исключений через контекстный менеджер (with)
def test_zerodivision():
		# если при выполнении кода внутри него
		# не выйдет ошибка - тест провалится
		with pytest.raises(ZeroDivisionError):
				print(2 / 0)

# тестирование исключений через try/except
# работает через отслеживаение исключений
def test_zerodivision():
		try:
				print(2 / 0)
		except ZeroDivisionError:
				print(&#x27;Right! ZeroDivisionError raises&#x27;)
		else:
				raise AssertationError(&#x27;ZeroDivisionError was not raises&#x27;)</code></pre></details></li></ul><ul id="99950052-409a-4e97-9ff3-91d0bc6fec0b" class="toggle"><li><details open=""><summary>7. Абстрактные классы, абстрактные методы. <mark class="highlight-default">Статические, магические методы и методы класса.</mark></summary><h3 id="03bc9991-6bcb-4d12-80d4-c817a981fc22" class=""><span style="border-bottom:0.05em solid">Абстрактные классы и методы</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d3805434-4227-471b-a2e2-9197cbd6a15f"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Абстрактный класс</strong></span> — класс, который:<br/>- можно наследовать<br/>- запрещает создавать от него объекты<br/>- содержит абстрактные методы<br/><br/><br/><span style="border-bottom:0.05em solid"><strong>Абстрактный метод</strong></span><strong> </strong>— метод, который:<br/>- объявлен в абстрактном классе<br/>- не имеет реализацию (пустой метод)<br/>- обязывает реализовать его в дочернем классе (иначе будет ошибка)<br/></div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a7a10aa9-51c5-47fe-b3a5-126f09d2f2d0" class="code"><code class="language-Python">from abc import ABC, abstractmethod

# абстрактный класс
class Animal(ABC):
		# абстрактный метод
		@abstractmethod
		def sound(self):
				pass

class Fish(Animal):
		# реализация абстрактного метода в дочернем классе
		def sound(self):
				return &#x27;Буль-буль&#x27;

class Cat(Animal):
		# реализация абстрактного метода в дочернем классе
		def sound(self):
				return &#x27;Мяу-мяу&#x27;</code></pre><h3 id="d2bb85b6-d80f-4b53-844e-a30c0b8f3d97" class=""><span style="border-bottom:0.05em solid">Виды методов в классах</span></h3><ul id="c8e5b0cb-5644-4af9-bf4c-0881e238d06c" class="bulleted-list"><li style="list-style-type:disc"><em>магический (dunder)</em> — метод, не предназначенный для вызова внутри или вне класса и запускаемый автоматически при определённом действии. Его название начинается и заканчивается “__”<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="36f3e5f4-9d14-4ca0-ba47-577f44905ae3" class="code"><code class="language-Python"># существует очень много магических методов, здесь далеко не все
class Car:
		# метод-конструктор, вызывается при создании объекта
		# также есть метод-деструктор __del__ (при удалении объекта)
		def __init__(self, speed, strangth):
				self.speed, self.strangth = speed, strangth

		# методы, вызываемые при преобразовании типов
		# __str__, __int__, __float__, __complex__ и т.п.
		def __str__(self):
				return f&#x27;Car speed={self.speed} and strangth={self.strangth}&#x27;

		# методы, вызываемые при использовании операторов сравнения
		# __eq__ (==), __ne__ (!=),
		# __le__ (&lt;=), __ge__ (&gt;=), __lt__ (&lt;), __gt__ (&gt;)
		def __eq__(self, other):
				return type(self) == type(other)

		# методы, вызываемые при использовании математических операторов
		# __add__ (+), __sub__ (-), __mul__ (*), __truediv__ (/) и т.п.
		def __add__(self, other):
				return Car(self.speed + other.speed, 
									 self.strangth + other.strangth)</code></pre></li></ul><ul id="c404bb41-c298-47ef-80f6-ed0a7b6ef380" class="bulleted-list"><li style="list-style-type:disc"><em>статический</em> — метод, не имеющий доступ к атрибутам и методам класса/объекта<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="951f12b9-9200-4476-85bb-a3d1f8e7ac0f" class="code"><code class="language-Python">class Greeting:
		message = &#x27;Good morning&#x27;
		def __init__(self, name):
				self.name = name
	
		# независимая функция
		# помещают в класс для удобства (например, совпадает тематика)
		# не требует класс или экземпляр в качестве аргумента
		@staticmethod
		def greet(city):
				print(f&#x27;Hello, {city}!&#x27;)
				# AttributeError
				# нет доступа к атрибутам и методам класса или экземпляра
				print(self.message, self.name)


# можно вызвать из экземпляра
my_greeting = Greeting(&#x27;Vasya&#x27;)
my_greeting.greet(&#x27;Moscow&#x27;)  # Hello, Moscow!
# можно вызвать из класса, не создавая экземпляр
Greeting.greet()     # Hello, Moscow!</code></pre></li></ul><ul id="354a65d3-17f7-43dd-bc59-259cab8a4c40" class="bulleted-list"><li style="list-style-type:disc"><em>метод класса</em> —<strong> </strong>метод, имеющий доступ только к атрибутам и методам класса<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="fe47ee8d-02be-4268-b063-87921c0d8a1b" class="code"><code class="language-Python">class Greeting:
		message = &#x27;Good morning!&#x27;
		def __init__(self, name):
				self.name = name
	
		# требует первым аргументом класс (cls)
		@classmethod
		def greet(cls):
				# есть доступ к атрибутам класса
				print(cls.message)
				# AttributeError, нет доступа к атрибутам и методам экземпляра
				print(self.name)


# можно вызвать из экземпляра
my_greeting = Greeting(&#x27;Vasya&#x27;)
my_greeting.greet()  # Good morning!
# можно вызвать из класса, не создавая экземпляр
Greeting.greet()     # Good morning!</code></pre></li></ul><ul id="2032c5c7-0ecb-4b97-9df0-7f086eb47b12" class="bulleted-list"><li style="list-style-type:disc"><em>метод экземпляра</em> — метод, имеющий доступ ко всем атрибутам и методам<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ad9f1001-62ed-4e82-9b72-ca2d1f10ef17" class="code"><code class="language-Python">class Greeting:
		message = &#x27;Good morning&#x27;
		def __init__(self, name):
				self.name = name
	
		def greet(self):
				# есть доступ к атрибутам и методам класса и экземпляра
				print(f&#x27;{self.message}, {self.name}!&#x27;)


# можно вызвать только из экземпляра
my_greeting = Greeting(&#x27;Vasya&#x27;)
my_greeting.greet()  # Good morning, Vasya!</code></pre></li></ul></details></li></ul><ul id="6a5177b8-8741-45f3-bc2d-5b6d60084cc1" class="toggle"><li><details open=""><summary>8. Pattern matching (match case).</summary><p id="921f3206-8828-4a68-af78-d61377953ae8" class="">Во многих языках программирования есть отдельная форма управления потока — способ взять значение и элегантно сопоставить его с одним из множества возможных шаблонов. В C и C++ эта функция реализована конструкцией <code>switch/case</code>. А в Python — конструкцией <code>match/case</code> (match pattern), появившейся только в Python 3.10, несмотря на популярность и простоту языка.</p><p id="2058e918-f4eb-4d84-8618-31012fc7e327" class="">Оператор match/case:</p><ul id="ce1ac959-dd0b-4213-8626-ace7d06e7686" class="bulleted-list"><li style="list-style-type:disc">позволяет избавиться от громоздких цепочек if/elif/else</li></ul><ul id="7f02cfea-3d0a-47d6-8817-9aa5abf04006" class="bulleted-list"><li style="list-style-type:disc">делает код более читаемым и менее повторяемым</li></ul><ul id="9d85bf83-7c2f-44e7-8dd2-d433347946cf" class="bulleted-list"><li style="list-style-type:disc">работает по той же схеме, что и switch/case: проверяет объект на соответствие одному или нескольким шаблонам и, если совпадение найдено, выполняет действие</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0ef064fa-fe70-4019-a681-68370ab1c1f0" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all"># сопоставление по шаблонам идёт сверху вниз
match command:
		# если шаблон совпал, то выполнятся действие и match/case завершается
		# иначе проверяется следующий шаблон
		case &quot;open&quot;:
				open()
		case &quot;save&quot;:
				save()
		# шаблон с альтернативными вариантами (ИЛИ)
    case &quot;quit&quot; | &quot;close&quot;:
        quit()
		# шаблон с началом и концом
    case &quot;reset&quot;, &quot;settings&quot; | &quot;configuration&quot;:
        reset()
		case &quot;reset&quot;, *something:
				raise ValueError(f&quot;You can&#x27;t reset {something}&quot;)
		# если ни один шаблон не совпал, можно использовать шаблон &#x27;_&#x27;,
		# который перехватывает любое значение,
		# поэтому ставить его нужно в самый конец
    case _:
        print (f&quot;Unknown command &#x27;{command}&#x27;&quot;)

# эквивалентный код с if/elif/else, выглядящий громоздко
# &#x27;command ==&#x27; повторяется несколько раз
if command == &quot;open&quot;:
		open()
elif command == &quot;save&quot;:
		save()
elif command == &quot;quit&quot; or command == &quot;close&quot;:
		quit()
elif command.split(&quot; &quot;, 1) == [&quot;reset&quot;, &quot;settings&quot;] or 
			command.split(&quot; &quot;, 1) == [&quot;reset&quot;, &quot;configuration&quot;]:
		reset()
elif command.startswith(&quot;reset&quot;):
		raise ValueError(f&quot;You can&#x27;t reset {command.split(&quot; &quot;, 1)[-1]}&quot;)
else:
		print(f&quot;Unknown command &#x27;{command}&#x27;&quot;)

# также match/case можно использовать для нормализации структуры 
# (приведения к общему виду)
def normalise_colour_info(colour):
    match colour:
        case (int(r), int(g), int(b)):
            name = &quot;&quot;
            a = 0
        case (int(r), int(g), int(b), int(a)):
            name = &quot;&quot;
        case (str(name), (int(r), int(g), int(b))):
            a = 0
        case (str(name), (int(r), int(g), int(b), int(a))):
            pass
        case _:
            raise ValueError(&quot;Unknown colour info.&quot;)
    return (name, (r, g, b, a))</code></pre></details></li></ul><ul id="962ab344-8cb0-45b2-9dc4-15020cf58c32" class="toggle"><li><details open=""><summary>9. Декорирование классов.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e6169eb1-7345-4fdf-9523-6d4a815039d4"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Декоратор</strong></span> — класс/функция, которая принимает в качестве аргумента оригинальный класс/функцию и дополняет его поведение<br/>Декоратор-функция возвращает замыкание<br/></div></figure><p id="bfcf9541-38a4-4c57-87ae-726371b1a273" class="">Декорировать класс можно 2 способами:</p><ul id="6562ce55-676a-4b48-87d1-a8fc093dcaaf" class="bulleted-list"><li style="list-style-type:disc">функцией<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cb9d283a-02ee-42a9-ad47-1757bcbb2ac8" class="code"><code class="language-Python"># декорирование без проброса аргумента
def add_str_dunder(class_: type) -&gt; type:
		def str_method(self) -&gt; str:
				attrs = [f&#x27;{key}: {value}&#x27; 
								 for key, value in self.__dict__.items()]
				return &#x27;, &#x27;.join(attrs)
		setattr(class_, &#x27;__str__&#x27;, str_method)
		return class_

# декорирование с пробросом аргумента max_age
def add_check_age(max_age: int) -&gt; Callable:
		def wrapper(class_: type) -&gt; type:
				def check_age(self) -&gt; bool:
						return self.age &lt;= max_age
				setattr(class_, &#x27;check_age&#x27;, check_age)
				return class_
		return wrapper

@add_check_age(25)
@add_str_dunder
class Person:
		def __init__(self, name: str, age: int) -&gt; None:
				self.name, self.age = name, age</code></pre></li></ul><ul id="5794692b-6b66-46a6-8e65-e90ae0f5e0f3" class="bulleted-list"><li style="list-style-type:disc">классом<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a310041f-e304-414b-9f7d-f614a616dac7" class="code"><code class="language-Python"># декорирование без проброса аргумента
class StrDunderModifier:
		def __init__(self, class_: type) -&gt; None:
				self.class_ = class_

		def __call__(self, *args, **kwargs) -&gt; type:
				def str_method(self) -&gt; str:
						attrs = [f&#x27;{key}: {value}&#x27; 
										 for key, value in self.__dict__.items()]
						return &#x27;, &#x27;.join(attrs)
				setattr(self.class_, &#x27;__str__&#x27;, str_method)
				return self.class_(*args, **kwargs)

@StrDunderModifier
class Person:
		def __init__(self, name: str, age: int) -&gt; None:
				self.name, self.age = name, age</code></pre></li></ul></details></li></ul><ul id="10c866ea-dd4e-4dcb-8a3d-27b740696c20" class="toggle"><li><details open=""><summary>10. Метапрограммирование, type, метаклассы.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="611fdc98-7b4c-4f5c-9bdd-de00a149247a"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Метапрограммирование</strong></span> — создание программ, которые создают другие программы или меняют себя при выполнении<br/><br/><span style="border-bottom:0.05em solid"><strong>Метакласс</strong></span> — класс, экземплярами которого являются другие классы. То есть это класс, который создаёт другие классы.<br/>Создать свой метакласс можно с помощью создания класса, который наследуется от класса <br/><code>type</code> и переопределяет метод <code>__new__</code><br/><br/><br/><span style="border-bottom:0.05em solid"><strong>type</strong></span> — метакласс для всех классов в Python<br/>Все классы в Python являются наследниками класса <br/><code>object</code>, но также они являются экземплярами метакласса <code>type</code>. То есть <code>object</code> — родитель, а <code>type</code> — создатель.</div></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8f1e0b42-b09a-4acd-bf07-67bddae94371" class="code"><code class="language-Python"># все классы в Python типа type, в том числе и сам type
age = 35
print(age.__class__)  # &lt;class &#x27;int&#x27;&gt;
print(age.__class__.__class__)  # &lt;class &#x27;type&#x27;&gt;</code></pre><p id="13781dfa-84d3-4ba8-8b74-e530c2ad6604" class=""><code>type</code> может быть:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e8b8f20e-9fdb-40be-a3bd-3c528c9f9235" class="code"><code class="language-Python"># функцией, возвращающей тип объекта, при передаче одного аргумента
print(type(4))  # &lt;class &#x27;int&#x27;&gt;
print(type(&#x27;Albert&#x27;))  # &lt;class &#x27;str&#x27;&gt;
print(type(type))  # &lt;class &#x27;type&#x27;&gt;

# метаклассом при передаче трёх аргументов
class Human:
		def __init__(self, name: str, age: int) -&gt; None:
				self.name, self.age = name, age

def student_str(self) -&gt; str:
		return f&#x27;Student {self.name} {self.age} y.o.&#x27;
# аргументы: название типа, родительские классы, словарь атрибутов и методов
Student = type(&#x27;Student&#x27;, (Human,), 
							 {&#x27;college&#x27;: &#x27;Sirius&#x27;, &#x27;__str__&#x27;: student_str})
vanya = Student(&#x27;Ivan&#x27;, 18)
print(type(Student))  # &lt;class &#x27;type&#x27;&gt;
print(vanya)  # Student Ivan 18 y.o.</code></pre></details></li></ul><ul id="dd15e736-40ab-43ab-9e85-5b6752e86428" class="toggle"><li><details open=""><summary>11. Порождающие паттерны. Абстрактная фабрика. Фабричный метод.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="859fd43c-576b-4316-8589-0ce6afd46ae0"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Паттерн или шаблон проектирования</strong></span> — проверенная архитектурная конструкция для решения определённой частовозникающей проблемы<br/><br/><span style="border-bottom:0.05em solid"><strong>Порождающие паттерны</strong></span> — паттерны, отвечающие за создание объектов и позволяющие сделать систему независимой от типов самих объектов и способа создания<br/><br/>К порождающим паттернам относятся:<br/>- фабрика (simple factory)<br/>- фабричный метод (factory method)<br/>- абстрактная фабрика (abstract factory)<br/>- строитель (builder)<br/>- прототип (prototype)<br/>- синглтон (singleton)<br/></div></figure><h1 id="26902624-6c1d-454f-8f73-9b220b681e69" class=""><span style="border-bottom:0.05em solid">Абстрактная фабрика (Abstract factory)</span></h1><div id="0ddf4a96-6acc-4214-b6fd-ab5c5488850c" class="column-list"><div id="d77ed28d-e659-4a16-a983-9dcbf3a5287a" style="width:43.75%" class="column"><figure id="5889f422-8251-41c5-b63a-c18cad9e21d0" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%206.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%206.png"/></a></figure></div><div id="b38567fb-4732-4e09-9b98-0af8da4ca30e" style="width:56.25%" class="column"><p id="1ac3bf70-1e87-489f-b6a2-959b35e139c6" class="">Порождающий паттерн, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.</p><p id="94f593e2-615f-40ac-b0b2-d6fa7861dbf1" class="">
</p></div></div><h3 id="7fb891e8-32a9-4b9d-b121-e261ad3cf1ab" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="a8185581-8563-4168-aa51-9be1bba0814a" class="column-list"><div id="df132009-5b33-47e3-87c1-1d34001d3d36" style="width:50%" class="column"><p id="54e6ad7e-f9a3-4917-889b-a4708332bbc4" class=""><mark class="highlight-teal"><strong>+</strong></mark> реализует принцип открытости/закрытости (O в SOLID)</p><p id="d4b4feef-d330-4fe4-8bbc-d05478b3d765" class=""><mark class="highlight-teal"><strong>+</strong></mark> гарантирует сочетаемость создаваемых продуктов</p><p id="cf345607-d427-4517-bd06-6882a84c9c94" class=""><mark class="highlight-teal"><strong>+</strong></mark><strong> </strong>упрощает добавление новых продуктов в программу</p><p id="0aa270b7-7750-4903-9fd6-dc05797f9e60" class=""><mark class="highlight-teal"><strong>+</strong></mark> избавляет клиентский код от привязки к конкретным классам продуктов</p><p id="2745f528-c8d0-4f3f-b38d-b1be3f5a2887" class=""><mark class="highlight-teal"><strong>+</strong></mark> выделяет код производства продуктов в одно место, упрощая поддержку кода</p></div><div id="73f3dd1a-2b44-4526-b652-54b127e0f3b3" style="width:50%" class="column"><p id="4cdb6f51-67a8-4a59-a52a-ec7c59086f6b" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>усложняет код программы из-за введения дополнительных классов</p><p id="2b7e3ce8-67b6-4682-8683-e587e0f4956d" class=""><mark class="highlight-red"><strong>-</strong></mark> требует наличия всех типов продуктов в каждой вариации</p><p id="38038076-4482-4033-bf41-bb5a488a4e16" class="">
</p></div></div><h3 id="4103467f-f24a-471b-b948-9e1c0ed7febf" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="bfa9298d-dbbb-45cf-9e92-44276251eb2f"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Симулятор мебельного магазина содержит семейство зависимых продуктов (Кресло, Диван и Столик) и несколько вариаций этого семейства (Ар-деко, Викторианский и Модерн)</div></figure><div id="836b1a73-3005-4054-beff-7e4a5eeca318" class="column-list"><div id="09160b2d-1965-4389-96ec-060d3958d8b3" style="width:43.75%" class="column"><figure id="19b85e0b-9179-43a5-b245-f02566273f13" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%207.png"><img style="width:840px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%207.png"/></a></figure><figure id="f11ef44a-e6e3-4eed-a4ae-f7bb8ade2709" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%208.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%208.png"/></a></figure></div><div id="126dbce6-09ab-43fc-9927-a3deb3ab954a" style="width:56.25%" class="column"><p id="b778a5c5-8409-4afe-b05e-818077486c8b" class="">Нужен способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства.</p><p id="a0f37c3a-56b7-4d1b-88b7-6b8244278acc" class="">Кроме того, нужно не вносить изменения в существующий код при добавлении новых продуктов или семейcтв в программу, чтобы постоянно не менять его.</p></div></div><h3 id="36ba02a1-214e-4c55-b25f-7eef5ae27a2b" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="5cb828bc-387c-421d-a378-3c2febe05cf6" class="column-list"><div id="9f118d50-3f41-4e28-85bb-8e3cd4492205" style="width:43.75%" class="column"><figure id="c8859bdf-e670-49c9-89c6-4cd67776b99f" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%209.png"><img style="width:840px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%209.png"/></a></figure><figure id="8574176e-4692-4fb8-a72e-e8c41a104434" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2010.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2010.png"/></a></figure><figure id="ca38d287-7940-487a-96b9-1f1e00333457" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2011.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2011.png"/></a></figure></div><div id="1e281c43-c144-4f6a-af1a-1c4fd1d2c48a" style="width:56.25%" class="column"><ul id="95a877a6-6a77-4270-b67e-951bb5d25c19" class="bulleted-list"><li style="list-style-type:disc">выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Например, все вариации кресел получат общий интерфейс Кресло</li></ul><ul id="a1e5a921-6715-48c8-9f0d-9ba880408f0c" class="bulleted-list"><li style="list-style-type:disc">создать абстрактную фабрику — общий интерфейс, который содержит методы создания всех продуктов семейства, которые должны возвращать абстрактные типы продуктов</li></ul><ul id="80141e44-ccd5-47c3-9152-9222d873f0ba" class="bulleted-list"><li style="list-style-type:disc">создать фабрику для каждой вариации семейства продуктов, реализовав абстрактную фабрику</li></ul><ul id="fe05c636-6aad-459e-bfe7-7acdb474a22f" class="bulleted-list"><li style="list-style-type:disc">клиентский код должен работать с фабриками и продуктами только через их общие интерфейсы</li></ul><p id="1d948f35-bf49-4488-a6d9-0d90266ffe41" class="">
</p></div></div><h3 id="c8510d21-239d-4c50-90bd-5c86c27f083c" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="2c95b06a-d731-4a43-a86e-44a460b6496c" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2012.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2012.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a2371173-c62a-447b-ada7-7ea022de7aa1" class="code"><code class="language-Python">from abc import ABC, abstractmethod
# также нужно создать интерфейсы для каждого типа продукта
# и классы самих конкретных продуктов

# абстрактная фабрика для создания различной мебели
class FurnitureFactory(ABC):
		@abstractmethod
		def create_chair() -&gt; Chair:
				pass

		@abstractmethod
		def create_table() -&gt; Table:
				pass

		@abstractmethod
		def create_sofa() -&gt; Sofa:
				pass

# конкретная фабрика, создающая современную мебель
class ModernFurnitureFactory(FurnitureFactory):
		def create_chair() -&gt; Chair:
				return ModernChair()

		def create_table() -&gt; Table:
				return ModernTable()

		def create_sofa() -&gt; Sofa:
				return ModernSofa()

# конкретная фабрика, создающая викторианскую мебель
class VictorianFurnitureFactory(FurnitureFactory):
		def create_chair() -&gt; Chair:
				return VictorianChair()

		def create_table() -&gt; Table:
				return VictorianTable()

		def create_sofa() -&gt; Sofa:
				return VictorianSofa()

# код клиента
furn_type = input(&quot;Введите тип мебели, который вы хотите: &quot;)
if furn_type == &quot;modern&quot;:
		factory = ModernFurnitureFactory()
elif furn_type == &quot;victorian&quot;:
		factory = VictorianFurnitureFactory()
chair, table, sofa = (
		factory.create_chair(), factory.create_table(), factory.create_sofa())
print(f&quot;Ваш набор мебели: {chair}, {table}, {sofa}&quot;)</code></pre><h1 id="c5b22540-d975-49c6-8aeb-e4ab8cfa77b2" class=""><span style="border-bottom:0.05em solid">Фабричный метод (Factory method)</span></h1><div id="caca7cee-35c7-43c2-9e78-2a48be772c99" class="column-list"><div id="9d802572-1621-4fdf-ad61-b717991f9896" style="width:43.75%" class="column"><figure id="9c3b4f42-0a16-4785-b35b-a717f4bbc8a1" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2013.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2013.png"/></a></figure></div><div id="c5619d7c-4046-4966-a480-9cd6e4cbe2ba" style="width:56.25%" class="column"><p id="b184013a-6367-427b-a0cb-ff1ea88bf1d9" class="">Порождающий паттерн, который определяет общий интерфейс для создания объектов в родительском классе, позволяя подклассам изменять тип создаваемых объектов.</p></div></div><h3 id="a3672099-9a4a-49d3-b2d1-7d21cf022e13" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="edb66986-5055-486e-b3d6-440379f9ed30" class="column-list"><div id="5d54a881-c6dc-43ca-86e6-6b0ff7d9e19c" style="width:50%" class="column"><p id="ee9dd6cc-2ab6-4c92-a776-ba1ee32101e7" class=""><mark class="highlight-teal"><strong>+</strong></mark> реализует принцип открытости/закрытости (O в SOLID)</p><p id="1fc4d1c9-9eba-4a97-a88c-002415892774" class=""><mark class="highlight-teal"><strong>+</strong></mark><strong> </strong>упрощает добавление новых продуктов в программу</p><p id="754eb536-0d2c-4248-8916-087aff57897f" class=""><mark class="highlight-teal"><strong>+</strong></mark> избавляет класс от привязки к конкретным классам продуктов</p><p id="7eb4c143-ab53-43f9-a79a-6f90bd41d20c" class=""><mark class="highlight-teal"><strong>+</strong></mark> выделяет код производства продуктов в одно место, упрощая поддержку кода</p><p id="310f42d1-49ab-4336-a12d-b7d865ff7e21" class="">
</p></div><div id="bbe3877b-dee7-42ec-bc33-a428bb47a6f5" style="width:50%" class="column"><p id="5e9f0d7c-17f1-422b-b1f7-2af1cd566a76" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.</p></div></div><h3 id="7ff890dd-7c2d-4162-a6c1-f0246cd9179b" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="80a0b67d-d22f-4566-97b9-51999cb227bb"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">В программе управления грузовыми перевозками есть управление только перевозками на автомобилях, код работает только с объектами класса Грузовик.</div></figure><div id="c66e4a4c-f95d-451d-9b07-abef84b9c0c6" class="column-list"><div id="044cbf41-c8d1-435b-a6bb-d4935b67e126" style="width:43.75%" class="column"><figure id="ac23a01b-3901-4a54-9295-c846ae9f2223" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2014.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2014.png"/></a></figure></div><div id="02ac3045-f332-4f61-a406-bf4f52b26e08" style="width:56.25%" class="column"><p id="d8245f76-841d-4405-9506-6207c15ecee1" class="">Чтобы добавить морскую перевозку придётся перелопатить почти всю программу, так как она привязана к классу Грузовик. При добавлении следующего вида перевозок возникнет та же проблема.</p></div></div><h3 id="f9e265ed-e7a7-4adb-9376-87a3d907ac4f" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="ab796283-09bb-4aca-8ce1-779d04845c70" class="column-list"><div id="582659e1-6654-499c-bea7-ca6d9ade3fea" style="width:43.75%" class="column"><figure id="650bdcbf-c074-4fb7-8dff-a82cf9cebbc5" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2015.png"><img style="width:1240px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2015.png"/></a></figure><figure id="9ebb7e08-efe1-422d-a4ec-908bdc2c4504" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2016.png"><img style="width:980px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2016.png"/></a></figure><figure id="d5caaa9c-338f-474f-b9e0-89d2771f7335" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2017.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2017.png"/></a></figure></div><div id="0c53ed5f-7a0b-4673-914e-693b497493c2" style="width:56.25%" class="column"><ul id="353784f7-19e5-4137-a875-4d2502bbb562" class="bulleted-list"><li style="list-style-type:disc">создавать объекты не напрямую, используя оператор <code>__new__</code>, а через вызов особого фабричного метода (он тоже будет создавать объекты через <code>__new__</code>, но по-особому)</li></ul><ul id="0d80a0d7-f764-4b16-a382-01a95bb54bbe" class="bulleted-list"><li style="list-style-type:disc">можно переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта</li></ul><ul id="6c533065-db3c-41be-9ada-c628b2d60d18" class="bulleted-list"><li style="list-style-type:disc">все возвращаемые объекты должны иметь общий интерфейс</li></ul><p id="3b6c611d-9635-42f1-8160-826de4e4717b" class="">
</p></div></div><h3 id="d1bb6081-eeef-4daf-bfc5-9b712d1a5ad1" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="803c5d5b-0d2d-4e3f-b317-774f7c16ef54" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2018.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2018.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8fd9aea9-d4fc-4321-9d15-1d9ec48969d9" class="code"><code class="language-Python">from abc import ABC, abstractmethod


class Logistic(ABC):
    &quot;&quot;&quot;
    Класс Создатель объявляет фабричный метод, 
		который должен возвращать объект класса Транспорт. 
		Подклассы Создателя предоставляют реализацию этого метода.
    &quot;&quot;&quot;
    @abstractmethod
    def create_transport(self) -&gt; Transport:
        &quot;&quot;&quot;
        Создатель может также обеспечить 
				реализацию фабричного метода по умолчанию.
        &quot;&quot;&quot;
        pass

    def plan_delivery(self) -&gt; str:
        &quot;&quot;&quot;
        Несмотря на название, основная обязанность Создателя 
				не заключается в создании транспорта. Обычно он содержит
        некоторую базовую бизнес-логику, которая основана 
				на объектах Транспортах, возвращаемых фабричным методом. 
				Подклассы могут косвенно изменять эту бизнес-логику, 
				переопределяя фабричный метод и возвращая из него другой
        тип продукта.
        &quot;&quot;&quot;
        # Вызываем фабричный метод, чтобы получить объект-транспорт.
        transport = self.create_transport()
        # Далее, работаем с этим транспортом.
        result = transport.deliver()
        return result

&quot;&quot;&quot;
Конкретные Создатели переопределяют фабричный метод для того, 
чтобы изменить тип результирующего продукта.
&quot;&quot;&quot;
class RoadLogistic(Logistic):
    &quot;&quot;&quot;
    Cигнатура метода по-прежнему использует тип абстрактного продукта, 
		хотя фактически из метода возвращается конкретный продукт. 
		Таким образом, Создатель может оставаться независимым 
		от конкретных классов продуктов.
    &quot;&quot;&quot;
    def create_transport(self) -&gt; Transport:
        return Truck()

class SeaLogistic(Logistic):
    def create_transport(self) -&gt; Transport:
        return Ship()

class Transport(ABC):
    &quot;&quot;&quot;
    Интерфейс Транспорта объявляет операции, 
		которые должны выполнять все конкретные транспорты.
    &quot;&quot;&quot;
    @abstractmethod
    def deliver(self) -&gt; str:
        pass

&quot;&quot;&quot;
Конкретные Транспорты предоставляют различные реализации интерфейса.
&quot;&quot;&quot;
class Truck(Transport):
    def deliver(self) -&gt; str:
        return &quot;Delivering by road..&quot;

class Ship(Transport):
    def deliver(self) -&gt; str:
        return &quot;Delivering by sea..&quot;

def client_code(logistic: Logistic) -&gt; None:
    &quot;&quot;&quot;
    Клиентский код работает с экземпляром конкретного создателя, 
		хотя и через его базовый интерфейс. 
		Пока клиент продолжает работать с создателем через базовый интерфейс, 
		можно передать ему любой подкласс создателя.
    &quot;&quot;&quot;
    print(f&quot;Client: I&#x27;m not aware of the creator&#x27;s class, &quot;
					f&quot;but it still works.\n&quot;
          f&quot;{logistic.plan_delivery()}&quot;, end=&quot;&quot;)


if __name__ == &quot;__main__&quot;:
    print(&quot;App: Launched with the road logistic.&quot;)
    client_code(RoadLogistic())
    print(&quot;App: Launched with the sea logistic.&quot;)
    client_code(SeaLogistic())</code></pre></details></li></ul><ul id="217ba47a-ad62-469c-aadd-9e723813bd7e" class="toggle"><li><details open=""><summary>12. Порождающие паттерны. Строитель. Прототип. Синглтон.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="17846601-e87b-4148-b116-cf47e4a552b1"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Паттерн или шаблон проектирования</strong></span> — проверенная архитектурная конструкция для решения определённой частовозникающей проблемы<br/><br/><span style="border-bottom:0.05em solid"><strong>Порождающие паттерны</strong></span> — паттерны, отвечающие за создание объектов и позволяющие сделать систему независимой от типов самих объектов и способа создания<br/><br/>К порождающим паттернам относятся:<br/>- фабрика (simple factory)<br/>- фабричный метод (factory method)<br/>- абстрактная фабрика (abstract factory)<br/>- строитель (builder)<br/>- прототип (prototype)<br/>- синглтон (singleton)<br/></div></figure><h1 id="a4a7548e-5a94-449e-afaf-9087131700a7" class=""><span style="border-bottom:0.05em solid">Строитель (Builder)</span></h1><div id="26e6ba13-140f-4e63-838f-44edaa133c4d" class="column-list"><div id="7aa04fde-8f78-432c-a790-cb2a20a78e4d" style="width:43.75%" class="column"><figure id="f01fd6e2-9076-4eb8-9554-197f34f001f6" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2019.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2019.png"/></a></figure></div><div id="6b9c3775-5e73-4710-bdd0-b24408a58051" style="width:56.25%" class="column"><p id="a5f7d5a4-6299-4e55-8d32-29c27e23c314" class="">Порождающий паттерн, который позволяет создавать сложные объекты поэтапно.<br/><br/>С помощью комбинаций этапов можно создавать совершенно разнообразные объекты.<br/></p><p id="3341caa7-5268-49fa-9628-5de822efe7c6" class="">
</p></div></div><h3 id="47cef8ab-c6fb-4892-8fde-213b2e9e47cd" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="f637fb55-a6ff-493a-af83-5bb0659cafbb" class="column-list"><div id="1c07f3d0-998a-44d6-adcd-d185710bc380" style="width:50%" class="column"><p id="08ab3ae5-7536-48b3-a705-2d29316372a8" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет создавать продукты пошагово</p><p id="c750e22e-a316-4697-8df0-9996b83a53f7" class=""><mark class="highlight-teal"><strong>+</strong></mark> изолирует сложный код сборки продукта от основного</p><p id="6e33ba35-876a-41a3-9c40-d5f3df1f6710" class=""><mark class="highlight-teal"><strong>+</strong></mark><strong> </strong>позволяет использовать один и тот же код для создания различных продуктов</p></div><div id="cef8994e-f699-4540-ade7-7f84fea6c6f8" style="width:50%" class="column"><p id="dfcb6d58-c2e9-4d22-9893-de91ae5c4ff4" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>усложняет код программы из-за введения дополнительных классов</p><p id="bb88c7fe-e9bd-4538-9c31-1c53738096ef" class=""><mark class="highlight-red"><strong>-</strong></mark> клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения результата</p></div></div><h3 id="1f072e07-7baa-4ba1-b1a5-14f3fef0a4fa" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="8df70e7f-ae17-4b76-a3d0-a4773f7947fa"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">В сложных объектах нужно кропотливо инициализировать множество полей и вложенных объектов. Обычно код инициализации спрятан внутри монструозного конструктора с множеством параметров. </div></figure><div id="caf629e9-585b-440b-bd3b-208eb8350e61" class="column-list"><div id="bd94a335-b6af-4d68-aa27-e1114c00f78c" style="width:43.75%" class="column"><figure id="0ae39579-f81b-4e74-9258-0fc8b81e0046" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2020.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2020.png"/></a></figure><figure id="7bd23d22-4373-4f76-b04a-2d0036fe0315" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2021.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2021.png"/></a></figure></div><div id="69cde3ac-252e-421e-bb04-b710c74bec3b" style="width:56.25%" class="column"><p id="65d19a0e-0fdd-43c4-90d4-af1bb2f81124" class="">Если у сложного объекта есть несколько видов, то для каждой комбинации атрибутов придётся создавать новый класс, у которого изменено только несколько из них (повторяющийся код).</p><p id="e9e139f4-653d-432f-a188-08f6aeb264cf" class="">Вместо создания классов можно сделать гигантский конструктор с кучей параметров, но большая часть из них будут простаивать, а вызов будет выглядеть очень длинно.</p></div></div><h3 id="d7139c50-36d5-4076-99f5-ceb5aefa2c99" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="9e84d8a9-b6ef-4e52-bd0d-c169c08aff51" class="column-list"><div id="bde2f283-7416-42ec-8ce5-8dfcd271c482" style="width:43.75%" class="column"><figure id="fb5b99f3-6de5-4f9c-9eb7-37a66986eb57" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2022.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2022.png"/></a></figure><figure id="8b258919-4600-468a-8ecd-af50c99463c7" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2023.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2023.png"/></a></figure><figure id="531ed600-0832-4ae3-9473-49810b691a61" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2024.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2024.png"/></a></figure></div><div id="56912399-299f-46b7-aa52-7335520577ea" style="width:56.25%" class="column"><ul id="571a22ea-4e82-45d1-becb-e621f1bf10f7" class="bulleted-list"><li style="list-style-type:disc">вынести конструирование объекта за пределы класса и поручить его отдельным объектам, которые называются строителями</li></ul><ul id="cf4887ab-64b2-43bc-97de-ae9a93963970" class="bulleted-list"><li style="list-style-type:disc">разбить процесс конструирование объекта на отдельные этапы, чтобы вызывая нужные из них создавать объект с определённой конфигурацией</li></ul><ul id="156363e7-8667-4e4e-9b5f-e9edb1c568e1" class="bulleted-list"><li style="list-style-type:disc">если этап отличается для разных вариаций, то можно создать несколько классов строителей, выполняющих одни и те же шаги по-разному.</li></ul><ul id="e28ae400-e736-4b96-81fd-f7405fd738b3" class="bulleted-list"><li style="list-style-type:disc">при желании выделить вызов методов строителя в отдельный класс, называемый директором</li></ul><p id="5adceea8-c007-400c-bb35-0b4396b81d9b" class="">
</p></div></div><h3 id="86b4518a-12fe-4386-ac9f-c3fe7094dec5" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="b881a59a-6c2e-4b39-a488-3385adf01adf" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2025.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2025.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0915573f-01f7-4801-a0e2-f2a009e8807f" class="code"><code class="language-Python">from typing import Self

# так не стоит делать, так как огромный конструктор
class House:
    def __init__(self, walls, roof, has_pool, has_garden, has_garage):
        self.walls = walls
        self.roof = roof
        self.has_pool = has_pool
        self.has_garden = has_garden
        self.has_garage = has_garage

# так тоже, так как много классов с небольшим изменением атрибутов
class House(ABC):
    def __init__(self, walls, roof):
        self.walls = walls
        self.roof = roof

class HouseWithGarage(House):
    def __init__(self, walls, roof, garage):
        super().__init__(walls, roof)
        self.garage = garage

class HouseWithPool(House):
    def __init__(self, walls, roof, pool):
        super().__init__(walls, roof)
        self.pool = pool

# правильное решение
# можно дополнительно создать директора, который будет запускать шаги, 
# а также различных строителей
class House:
		pass

class HouseBuilder:
    def __init__(self):
        &quot;&quot;&quot;
        Новый экземпляр строителя должен содержать пустой объект продукта,
        который используется в дальнейшей сборке.
        &quot;&quot;&quot;
        self._house = House()

    @property
    def house(self):
        &quot;&quot;&quot;
        Как правило, после возвращения сконструированного продукта
        строитель сразу готов производить новый, сбрасывая старое
        состояние.
        &quot;&quot;&quot;
				_current_house = self._house
        self.reset()
        return _current_house

    def reset(self):
        self._house = House()

    def build_walls(self, walls: list[Wall]) -&gt; Self:
        self._house.walls = walls
        return self

    def build_roof(self, roof: Roof) -&gt; Self:
        self._house.roof = roof
        return self

    def build_pool(self, pool: SwimmingPool) -&gt; Self:
        self._house.pool = pool
        return self


# код клиента, запуск строителя
builder = HouseBuilder()
my_roof, my_walls = Roof(material=&quot;brick&quot;), [Wall(color=&quot;#000000&quot;) * 4]
# в строителях часто практикуется подход &quot;цепочка методов&quot;,
# когда можно вызывать по несколько методов за раз,
# получая при этом обратно экземпляр строителя
my_house = builder.build_roof(my_roof).build_walls(my_walls).house</code></pre><h1 id="dc98a96c-3e03-414c-a4f4-5885501ff0f6" class=""><span style="border-bottom:0.05em solid">Прототип (Prototype)</span></h1><div id="c04f2940-7c8e-4891-8bed-5975d6b3a378" class="column-list"><div id="f71b9099-bef5-49c6-95ea-ed38c0d90c63" style="width:43.75%" class="column"><figure id="e3e0c6b1-9af5-4fe5-9d1b-70061b8ed84b" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2026.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2026.png"/></a></figure></div><div id="9f3880c7-f2ba-43b2-9d03-24ff9b47ee7a" style="width:56.25%" class="column"><p id="8c10b385-393f-48e7-b200-9503a53cd86e" class="">Порождающий паттерн, который позволяет копировать объекты, не вдаваясь в подробности их реализации.</p><p id="01f247b6-4c3b-4a61-89d7-67c107a911f4" class="">
</p></div></div><h3 id="eb8d07f9-0583-48fc-883d-7bbf02889864" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="d0e21358-7f03-4c11-bffd-f14b7cee4133" class="column-list"><div id="66a4cce8-7328-4f01-8a20-9203a9ac5329" style="width:50%" class="column"><p id="f08fcf12-a57d-4907-bc1e-0d232cad82a8" class=""><mark class="highlight-teal"><strong>+</strong></mark> ускоряет создание объектов</p><p id="1e5e7ede-6473-4c33-a876-564452a99344" class=""><mark class="highlight-teal"><strong>+</strong></mark><strong> </strong>меньше повторяющегося кода инициализации объекта</p><p id="8a3f2a83-b491-425d-9182-b42bae86e503" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет клонировать объекты, не привязываясь к их конкретным классам</p><p id="ad4abd57-741d-4611-a36f-92a3e7931afb" class=""><mark class="highlight-teal"><strong>+</strong></mark> альтернатива созданию подклассов для конструирования сложных объектов</p></div><div id="c2bf3b10-c7fb-4961-9a0d-98beb33f2867" style="width:50%" class="column"><p id="782a1615-ade6-4d49-898f-7db274a9c402" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>сложно клонировать составные объекты, имеющие ссылки на другие объекты</p></div></div><h3 id="81d8d506-9510-4bec-99a3-ac8faa8ccec4" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="2ff0a601-e552-431f-b71d-055ef2595a6e"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Самый простой способ скопировать объект — создать пустой объект того же класса, а затем поочерёдно скопировать значения атрибутов из старого объекта в новый. Но не каждый объект удастся скопировать таким образом.</div></figure><div id="fb636ae3-bc7a-498e-adcc-a09535e55305" class="column-list"><div id="1b60dfc7-a16c-4eef-8e0a-6fe1bb4cc0d0" style="width:43.75%" class="column"><figure id="41cf8901-325e-4202-b6be-924b30621573" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2027.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2027.png"/></a></figure></div><div id="2bd18ae4-6288-41fd-9951-e03f7e363afa" style="width:56.25%" class="column"><p id="fc27b8fc-3c0c-4716-a2bf-5dd409e18124" class="">Проблемой могут стать приватные атрибуты объекта, недоступные вне класса. <br/>Или зависимость копирующей программы от класса объекта, ведь чтобы перебрать все поля нужно привязаться к классу.<br/></p></div></div><h3 id="8342377a-96de-4196-8226-002fdd26b398" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="7a1401aa-8556-45f7-b2b7-e6ea5d5e8469" class="column-list"><div id="379d0927-963f-4d74-a2a6-1a9abb0baa0b" style="width:43.75%" class="column"><figure id="d0256038-c401-4375-a729-bf792ae8f7ce" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2028.png"><img style="width:687px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2028.png"/></a></figure><figure id="b43d77ac-36ee-4058-ac93-8e1110c5830d" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2029.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2029.png"/></a></figure></div><div id="cd481af2-f69b-4a85-a695-015f085fc960" style="width:56.25%" class="column"><ul id="2b7fcb85-886f-43a9-9883-50746821e50c" class="bulleted-list"><li style="list-style-type:disc">поручить создание копий самим копируемым объектам через введение общего интерфейса (часто имеющего только один метод <code>clone</code>)</li></ul><ul id="81012168-0978-4f69-adea-29bc0053a87e" class="bulleted-list"><li style="list-style-type:disc">метод <code>clone</code> будет создавать новый объект текущего класса и копировать в него значения всех полей (в том числе и приватных) собственного объекта</li></ul><ul id="d5380e87-de69-4ae7-a93b-438e41435b55" class="bulleted-list"><li style="list-style-type:disc">в программах с тысячами конфигураций прототипы (объекты, которые копируют) могут служить альтернативой подклассам, в таком случае прототипы заготавливаются на этапе инициализации</li></ul></div></div><h3 id="88249122-aa67-4a67-8379-381d634242a8" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="99eacc06-7b16-471b-be90-749759be0f8e" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2030.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2030.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4408fe7b-605a-4db9-9602-3d129e21ee7a" class="code"><code class="language-Python">from copy import deepcopy
from typing import Self

&quot;&quot;&quot;
паттерн Прототип реализован в базовой библиотеке Python 
посредством модуля copy, а точнее его функции deepcopy,
которая копирует все атрибуты объекта
P.S. deepcopy в отличие от функции copy копирует
сами дочерние элементы объекта или списка, а не ссылки на них
&quot;&quot;&quot;
# миксин (родительских класс для добавления возможностей) прототипа
class PrototypeMixin:
		# обычная копия объекта
		def prototype(self) -&gt; Self:
				return deepcopy(self)

		# копия с изменением параметров
		def prototype_parametrize(self, **kwargs) -&gt; Self:
        copy = deepcopy(self)
        for attr, value in kwargs.items():
            setattr(copy, attr, value)
        return copy

# в Person появятся методы prototype() и prototype_parametrize() из миксина
class Person(PrototypeMixin):
		def __init__(self, name: str, age: int, achievements: list[str]):
				self.name = name
				self.age = age
				self.achievements = achievements

albert = Person(&#x27;Albert&#x27;, 27, 
								[&#x27;works in sirius (debatable)&#x27;, &#x27;cool guy&#x27;, &#x27;etc&#x27;])

# вместо ahmed = Person(&#x27;Ahmed&#x27;, 27, [&#x27;cool guy&#x27;, &#x27;etc&#x27;])
# первый вариант
ahmed = albert.prototype()
ahmed.name = &#x27;Ahmed&#x27;
ahmed.achievements.remove(&#x27;works in sirius (debatable)&#x27;)

# второй вариант
ahmed = albert.prototype_parametrize(name=&#x27;Ahmed&#x27;, 
																		 achievements=[&#x27;cool guy&#x27;, &#x27;etc&#x27;])

print(albert.achievements)
# [&#x27;works in sirius (debatable)&#x27;, &#x27;cool guy&#x27;, &#x27;etc&#x27;]
print(ahmed.achievements)
# [&#x27;cool guy&#x27;, &#x27;etc&#x27;]</code></pre><h1 id="a62e5f9a-375d-44ee-89f3-2e8edc8ed38a" class=""><span style="border-bottom:0.05em solid">Синглтон (Singleton)</span></h1><div id="c0020b60-3031-4c6f-81e7-942b5001d28d" class="column-list"><div id="d3357019-b65b-46d6-af2a-60686b398c76" style="width:43.75%" class="column"><figure id="24497933-9ab4-42ea-acc4-4b18c7fc40a1" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2031.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2031.png"/></a></figure></div><div id="febd9591-ba5d-4ac7-9b2e-c874e1cb6858" style="width:56.25%" class="column"><p id="65bdd280-24df-4891-a7ad-2bd871fe11a3" class="">Порождающий паттерн, который гарантирует, что у класса есть только один экземпляр и предоставляет к нему глобальную точку доступа (возможность обратиться из любой части программы, не зная о его создании).</p></div></div><h3 id="8f70312d-408f-453b-9f6f-4fdcefe3e238" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="c3de7604-2fba-4d74-a2cd-92b85219b0ce" class="column-list"><div id="3138f7cb-c3a0-479c-a709-1235a3f318a2" style="width:50%" class="column"><p id="a4c9027e-69f9-4777-95b0-57e4b6712a22" class=""><mark class="highlight-teal"><strong>+</strong></mark><strong> </strong>предоставляет к нему глобальную точку доступа</p><p id="f493e4ba-4fd3-4ff2-9a3e-188a2db5bf66" class=""><mark class="highlight-teal"><strong>+</strong></mark> гарантирует наличие единственного экземпляра класса</p><p id="0c3bf554-bbb2-4d5f-bc8b-d8ddc44b04fd" class=""><mark class="highlight-teal"><strong>+</strong></mark> реализует отложенную инициализацию объекта (экземпляр будет создан только при первом запросе на него)</p></div><div id="eab06396-c55a-4b02-b604-b8b1559eae4b" style="width:50%" class="column"><p id="fe85b945-3b7a-4539-9815-0361513b9276" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>маскирует плохой дизайн</p><p id="6b437351-4614-4b52-b67f-86f626f83dc1" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>нарушает принцип единственной ответственности класса (S в SOLID)</p><p id="d1492230-617a-4696-a375-0cd5061844b0" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>требует постоянного создания Mock-объектов при юнит-тестировании</p><p id="20d6c690-e1c2-43d8-96ff-497c7556094f" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>проблемы многопоточности (проблемы при одновременном обращении нескольких потоков)</p></div></div><h3 id="8dbb19a2-0d66-439c-b984-6a5ae5b9dab2" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="5a38fcde-a88c-4eb2-8f02-c4d3e59aa429"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Решает 2 проблемы, нарушая принцип единственной ответственности класса</div></figure><div id="82103dc7-01d6-40fa-997a-9ef9053ab1b0" class="column-list"><div id="bc5cc1cf-2a10-4dcd-86b4-d7f9c3b60166" style="width:43.75%" class="column"><figure id="effc91cd-ec8d-47e4-936c-bdf52832953f" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2032.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2032.png"/></a></figure></div><div id="82333393-f240-40a9-a212-6439d018513e" style="width:56.25%" class="column"><ol type="1" id="48d13a00-9484-4aff-935c-e46722b2378e" class="numbered-list" start="1"><li>Иметь единственный объект, например, для доступа к базе данных</li></ol><ol type="1" id="6223c432-4a9e-4c39-a94c-dc3bea641588" class="numbered-list" start="2"><li>Иметь глобальную точку доступа</li></ol></div></div><h3 id="1b12a6be-96af-4838-bd56-8fcdaa60a28a" class=""><strong>Решение</strong></h3><ul id="b869ffbb-55c1-4981-9b8a-7b8c267d6b5e" class="bulleted-list"><li style="list-style-type:disc">скрыть конструктор по умолчанию и создать публичный статический метод, который будет контролировать жизненный цикл объекта</li></ul><h3 id="41f083d4-0fff-4196-966b-9306e42c4971" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="8ebea522-d96c-4fdc-8a70-1ea43f4a494a" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2033.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2033.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cfa64036-d3a6-44a1-ab19-75a8cece1b72" class="code"><code class="language-Python">class Singleton:
		_instance = None

		# контролирующий метод
		def __new__(cls, *args, **kwargs):
				if cls._instance is None:
						cls._instance = super().__new__(cls)
				return cls._instance

# теперь у Person всегда будет один экземпляр
class Person(Singleton):
		def __init__(self, name: str):
				self.name = name

# проверяем возвращает ли один и тот же объект
# синглтон при создании 2 объектов
print(Singleton() is Singleton())  # True
print(Person(&#x27;Vasya&#x27;) is Person(&#x27;Petya&#x27;))  # True
# у экземпляра Person name=Petya (заменяется)</code></pre></details></li></ul><ul id="bde435e7-f32c-45ab-bc7a-fd7adbed8a13" class="toggle"><li><details open=""><summary>13. Структурные паттерны. Адаптер, мост, фасад.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="68e04f52-aa33-4759-b6ef-b43f6e0c1743"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Паттерн или шаблон проектирования</strong></span> — проверенная архитектурная конструкция для решения определённой частовозникающей проблемы<br/><br/><span style="border-bottom:0.05em solid"><strong>Структурные паттерны</strong></span> — паттерны, рассматривающие образование более крупных структур из классов и объектов<br/><br/>К структурным паттернам относятся:<br/>- адаптер (adapter)<br/>- мост (bridge)<br/>- фасад (facade)<br/>- декоратор (decorator)<br/>- компоновщик (composite)<br/>- заместитель (proxy)<br/>- приспособленец (flyweight)<br/></div></figure><h1 id="60b26ed6-82cb-4f12-a353-fd3003009980" class=""><span style="border-bottom:0.05em solid">Адаптер (Adapter)</span></h1><div id="1c67d442-8eaa-4be2-b07c-9d0eba22c58b" class="column-list"><div id="bc5031ef-9ced-4359-bb1e-c82340387ca9" style="width:43.75%" class="column"><figure id="88eff8e3-4497-4e62-a356-bf1ab8db23e4" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2034.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2034.png"/></a></figure></div><div id="f17ab580-14c5-411e-ae8b-8fb8ef62b99b" style="width:56.25%" class="column"><p id="a72e947e-6116-4c3b-b7e0-5ae5decbe7bf" class="">Структурный паттерн, который позволяет объектам с несовместимыми интерфейсами работать вместе.</p></div></div><h3 id="b53f25d8-85ed-4f83-a35a-1ea13b7ed915" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="b0e96e53-3bee-4deb-ba0e-8ea871eaf8ff" class="column-list"><div id="27be0027-085b-4a3a-8494-82ec654e5cf6" style="width:50%" class="column"><p id="b9cced52-1e97-43ef-8c4e-a0e267fd5b3e" class=""><mark class="highlight-teal"><strong>+</strong></mark> отделяет и скрывает от клиента подробности преобразования различных интерфейсов</p></div><div id="496721ee-51e0-45db-a79b-24c16563e9e7" style="width:50%" class="column"><p id="d15b8751-9224-41f3-880a-0904546a0434" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>усложняет код программы из-за введения дополнительных классов</p></div></div><h3 id="29dd80f9-8b0a-4c26-85ec-e08e6b8b8895" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="3f9ba097-53d7-46aa-b8c7-909ff146d4b6"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Приложение может принимать данные из источников в формате XML и рисовать красивые графики. Но сторонняя библиотека аналитики поддерживает только JSON, несовместимый с приложением. </div></figure><div id="0e99cc9e-0da3-491c-b3ff-eb3397ece9d3" class="column-list"><div id="bc7c4c7b-6b5c-4946-aaba-47828fa18abc" style="width:43.75%" class="column"><figure id="9964e75b-e0ad-4254-8b73-3d8727665954" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2035.png"><img style="width:1060px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2035.png"/></a></figure></div><div id="dab75a3d-3c73-4e20-91cd-9f2360658615" style="width:56.25%" class="column"><p id="d5beebf5-b2ac-45e3-9630-6a18c998c48d" class="">Можно переписать библиотеку, чтобы она поддерживала XML, но:<br/>- это может нарушить работу существующего кода, который зависит от библиотеки<br/>- может не быть доступа к исходному коду <br/></p></div></div><h3 id="f7dae0a7-2a0e-4b52-a5a1-7b4770bae83f" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="3d2a71a3-53ac-46b4-bbb6-a14c108e449f" class="column-list"><div id="94a86d87-cd7b-4906-82e6-6e3070d38c1c" style="width:43.75%" class="column"><figure id="e92b9ac4-f170-4985-8a6b-9df7c836352f" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2036.png"><img style="width:1060px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2036.png"/></a></figure><figure id="f199b35e-d0c8-4b95-b91d-1df744b84bf8" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2037.png"><img style="width:1067px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2037.png"/></a></figure></div><div id="9d7ac1e0-263e-426a-a3d2-c706c1f07c0f" style="width:56.25%" class="column"><ul id="ee7c1ead-08e6-4dd5-9a53-857f05fef8a0" class="bulleted-list"><li style="list-style-type:disc">создать объект-переводчик (адаптер), который трансформирует интерфейс или данные одного объекта в понятный вид для другого</li></ul><ul id="bdf4bdf1-bbf3-4ca3-82a4-93290be0c87d" class="bulleted-list"><li style="list-style-type:disc">адаптер оборачивает один из объектов, другой объект не знает о наличии первого</li></ul><ul id="1e436367-1012-4b95-bede-d39256987b90" class="bulleted-list"><li style="list-style-type:disc">иногда возможно создать даже двухсторонний адаптер, который работал бы в обе стороны</li></ul></div></div><h3 id="9d6ed689-88ab-4111-b30d-a7a0fde6b01c" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="49b8c1d5-1d95-4ddb-913c-15627797daf9" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2038.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2038.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2e9cb4fc-9d62-4f78-8720-293537593981" class="code"><code class="language-Python"># Client Interface
class Target:
    &quot;&quot;&quot;
    Целевой класс объявляет интерфейс, 
		с которым может работать клиентский код.
    &quot;&quot;&quot;
    def request(self) -&gt; str:
        return &quot;Target: The default target&#x27;s behavior.&quot;

# Service
class Adaptee:
    &quot;&quot;&quot;
    Адаптируемый класс содержит некоторое полезное поведение, 
		но его интерфейс несовместим с существующим клиентским кодом. 
		Адаптируемый класс нуждается в некоторой доработке, 
		прежде чем клиентский код сможет его использовать.
    &quot;&quot;&quot;
    def specific_request(self) -&gt; str:
        return &quot;.eetpadA eht fo roivaheb laicepS&quot;

class Adapter(Target, Adaptee):
    &quot;&quot;&quot;
    Адаптер делает интерфейс Адаптируемого класса совместимым с целевым
    интерфейсом благодаря множественному наследованию.
    &quot;&quot;&quot;
    def request(self) -&gt; str:
        return f&quot;Adapter: (TRANSLATED) {self.specific_request()[::-1]}&quot;

def client_code(target: Target) -&gt; None:
    &quot;&quot;&quot;
    Клиентский код поддерживает все классы, использующие интерфейс Target.
    &quot;&quot;&quot;
    print(target.request(), end=&quot;&quot;)

if __name__ == &quot;__main__&quot;:
    print(&quot;Client: I can work just fine with the Target objects:&quot;)
    target = Target()
    client_code(target)
		# Target: The default target&#x27;s behavior.

    adaptee = Adaptee()
    print(&quot;Client: The Adaptee class has a weird interface. &quot;
          &quot;See, I don&#x27;t understand it:&quot;)
    print(f&quot;Adaptee: {adaptee.specific_request()}&quot;, end=&quot;\n\n&quot;)
		# Adaptee: .eetpadA eht fo roivaheb laicepS

    print(&quot;Client: But I can work with it via the Adapter:&quot;)
    adapter = Adapter()
    client_code(adapter)
		# Adapter: (TRANSLATED) Special behavior of the Adaptee.</code></pre><h1 id="692d9851-96cf-4e03-82ef-12d0e10caab2" class=""><span style="border-bottom:0.05em solid">Мост (Bridge)</span></h1><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="82297da7-9459-4e0b-afa9-87d4cec59aba"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Мост</strong></span> проектируют <mark class="highlight-red"><strong>изначально</strong></mark>, чтобы развивать большие части приложения независимо друг от друга<br/><br/><span style="border-bottom:0.05em solid"><strong>Адаптер</strong></span> применяется <mark class="highlight-red"><strong>на месте</strong></mark>, чтобы заставить работать несовместимые между собой классы</div></figure><div id="b907b254-8525-4d4d-b764-e85e2a32dd6d" class="column-list"><div id="3599d0be-7b11-4e3b-afc4-44f22f6275fa" style="width:43.75%" class="column"><figure id="a7e25aee-1f83-441d-af63-2050ef489e59" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2039.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2039.png"/></a></figure></div><div id="21f6e09a-7d79-4f8b-be48-201f4581dbe1" style="width:56.25%" class="column"><p id="4664e806-d263-443c-b1de-c6ef5d0b7f4b" class="">Структурный паттерн, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.</p></div></div><h3 id="37f98fce-8e59-4cc6-a50d-959ed19de798" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="eae192ab-fbfb-4907-bfd6-2d9e94b71f70" class="column-list"><div id="409f2625-bfe5-428d-86d0-3cc3690b7fbc" style="width:50%" class="column"><p id="6dad70da-276e-4ad2-a44e-3c00807c6820" class=""><mark class="highlight-teal"><strong>+</strong></mark> реализует принцип открытости-закрытости (O в SOLID)</p><p id="828b8e18-c5a6-45d5-bb54-1a21e767c50c" class=""><mark class="highlight-teal"><strong>+</strong></mark> скрывает лишние или опасные детали реализации от клиентского кода</p><p id="fd7e1682-b459-418d-b1db-01e7d57de9af" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет строить платформо-независимые программы (отделяет абстракцию и платформу-реализацию)</p></div><div id="913b6ecf-da73-4378-9025-bcb7d7b1b414" style="width:50%" class="column"><p id="9da27d34-f09b-4294-888b-aa5b20339f9e" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>усложняет код программы из-за введения дополнительных классов</p></div></div><h3 id="eb3c7199-fcc3-4ffa-9f22-30bc32403468" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a07086c3-8770-4a26-ac42-37300839c0a5"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Есть класс геометрических фигур, который имеет подклассы Круг и Квадрат. <br/>При расширении характеристик фигур добавили цвета, Красный и Синий. <br/>Чтобы всё объединить придётся создать 4 подкласса: СинийКвадрат, СинийКруг, КрасныйКвадрат и КрасныйКруг<br/></div></figure><div id="073fd6b7-cce7-486d-b43d-51e26fba86c0" class="column-list"><div id="c8efc185-5ff8-4802-9477-f1c11429d89a" style="width:43.75%" class="column"><figure id="c001200c-cf23-4326-99b2-72f757d0a5a3" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2040.png"><img style="width:960px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2040.png"/></a></figure></div><div id="99b8399b-b0bc-4037-85df-2194643722d3" style="width:56.25%" class="column"><p id="90263e71-e43b-41e0-8509-056752203da5" class="">При добавлении новых видов цветов и фигур количество комбинаций будет очень быстро расти.<br/><br/>Это будет приводить к повторению кода и тяжёлой поддержке.<br/></p></div></div><h3 id="1afdac8c-6eec-4faa-b8a0-bbd9ab5a8295" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="04d24800-4daf-4750-af2c-b46779017639" class="column-list"><div id="5859f2df-2feb-4f12-a07d-4f788b7c6da9" style="width:43.75%" class="column"><figure id="06947d97-6432-4d29-9d93-386970e42728" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2041.png"><img style="width:920px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2041.png"/></a></figure><figure id="8c7b37e0-0493-41d6-bffe-950e9e6baa06" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2042.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2042.png"/></a></figure><figure id="21fb2dc0-6c0e-4b11-8dbc-6a4bb685619d" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2043.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2043.png"/></a></figure></div><div id="8fdccb88-dc06-49fb-aa91-912516631ed5" style="width:56.25%" class="column"><ul id="a31b986a-9cff-4e46-ab6e-e98a65bfd970" class="bulleted-list"><li style="list-style-type:disc">заменить наследование агрегацией или композицией, разделив класс на отдельные иерархии (например, фигуры и цвета)</li></ul><ul id="4c388db1-9cff-4409-b5b3-21d5cada1e1c" class="bulleted-list"><li style="list-style-type:disc">в объекте одной иерархии добавить ссылку на объект другой иерархии</li></ul><ul id="b8ac4e20-e409-482b-9edd-c108bf579537" class="bulleted-list"><li style="list-style-type:disc">разделить абстракцию (образный слой управления) и реализацию, абстракция будет отдавать работу одному из объектов взаимозаменяемых реализаций</li></ul><ul id="069071a6-89dd-4405-8051-a1efe2c7a6be" class="bulleted-list"><li style="list-style-type:disc">изменять отдельно абстракцию и реализацию</li></ul></div></div><h3 id="bcafcea6-7031-4714-b203-b0d059f37a1e" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="0b7c6bf0-1dda-415f-bcaf-9cce1ccfe067" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2044.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2044.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5ef54b66-91d8-436a-b990-9e41e6a6b384" class="code"><code class="language-Python">from abc import ABC, abstractmethod

# Remote в структуре
class Abstraction:
    &quot;&quot;&quot;
    Абстракция устанавливает интерфейс для «управляющей» части 
		двух иерархий классов. Она содержит ссылку на объект 
		из иерархии Реализации и передаёт ему всю настоящую работу.
    &quot;&quot;&quot;
    def __init__(self, implementation: Implementation) -&gt; None:
        self.implementation = implementation

    def operation(self) -&gt; str:
        return (f&quot;Abstraction: Base operation with:\n&quot;
                f&quot;{self.implementation.operation_implementation()}&quot;)

# AdvancedRemote в структуре
class ExtendedAbstraction(Abstraction):
    &quot;&quot;&quot;
    Можно расширить Абстракцию без изменения классов Реализации.
    &quot;&quot;&quot;
    def operation(self) -&gt; str:
        return (f&quot;ExtendedAbstraction: Extended operation with:\n&quot;
                f&quot;{self.implementation.operation_implementation()}&quot;)

# Device в структуре
class Implementation(ABC):
    &quot;&quot;&quot;
    Реализация устанавливает интерфейс для всех классов реализации. 
		Он не должен соответствовать интерфейсу Абстракции. 
		На практике оба интерфейса могут быть совершенно разными. 
		Как правило, интерфейс Реализации предоставляет только
		примитивные операции, в то время как Абстракция определяет 
		операции более высокого уровня, основанные на этих примитивах.
    &quot;&quot;&quot;
    @abstractmethod
    def operation_implementation(self) -&gt; str:
        pass

&quot;&quot;&quot;
Каждая конкретная реализация соответствует определённой платформе
и реализует интерфейс реализации с использованием API этой платформы.
&quot;&quot;&quot;
# Radio и TV в структуре
class ConcreteImplementationA(Implementation):
    def operation_implementation(self) -&gt; str:
        return &quot;ConcreteImplementationA: Here&#x27;s the result on the platform A.&quot;

class ConcreteImplementationB(Implementation):
    def operation_implementation(self) -&gt; str:
        return &quot;ConcreteImplementationB: Here&#x27;s the result on the platform B.&quot;

def client_code(abstraction: Abstraction) -&gt; None:
    &quot;&quot;&quot;
    За исключением этапа инициализации, когда объект Абстракции связывается с
    определённым объектом Реализации, клиентский код должен зависеть только от
    класса Абстракции. Таким образом, клиентский код может поддерживать любую
    комбинацию абстракции и реализации.
    &quot;&quot;&quot;
    print(abstraction.operation(), end=&quot;&quot;)

if __name__ == &quot;__main__&quot;:
    &quot;&quot;&quot;
    Клиентский код должен работать с любой предварительно
		сконфигурированной комбинацией абстракции и реализации.
    &quot;&quot;&quot;
    implementation = ConcreteImplementationA()
    abstraction = Abstraction(implementation)
    client_code(abstraction) 
		# Abstraction: Base operation with:
		# ConcreteImplementationA: Here&#x27;s the result on the platform A.
    implementation = ConcreteImplementationB()
    abstraction = ExtendedAbstraction(implementation)
    client_code(abstraction)
		# ExtendedAbstraction: Extended operation with:
		# ConcreteImplementationB: Here&#x27;s the result on the platform B.</code></pre><h1 id="3cdfff2f-7819-4f23-ab11-2bb7b25cdf04" class=""><span style="border-bottom:0.05em solid">Фасад (Facade)</span></h1><div id="7c00ef04-c37b-48d3-ba1b-d8f091b11649" class="column-list"><div id="fc59a832-c9d5-41d7-91e3-30ad5d688ef8" style="width:43.75%" class="column"><figure id="c24bfd79-630a-43d4-9319-d6129275144b" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2045.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2045.png"/></a></figure></div><div id="bbd75b03-910e-436e-8f84-cc6a81cf8dd7" style="width:56.25%" class="column"><p id="1d143e9e-eba4-4bdd-8a59-1ceaeae4101a" class="">Структурный паттерн, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку. </p></div></div><h3 id="79991eb8-1ca6-42c8-828c-3099503b5cd5" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="38c8fbf7-ccdc-4132-b6cd-188b129d7116" class="column-list"><div id="1cd727b7-ab34-4bb7-b7c9-a492a8503710" style="width:50%" class="column"><p id="2c667ebb-a1fd-48b0-ae86-3925d8d6f562" class=""><mark class="highlight-teal"><strong>+</strong></mark> изолирует клиентов от компонентов сложной подсистемы</p><p id="bc90f93b-0067-49d8-ba61-5377062b3f8f" class="">
</p></div><div id="35f8548f-4a25-441b-bd38-7e18be5781e6" style="width:50%" class="column"><p id="37edf9b6-90ea-4cad-924c-bee4e4d1812a" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>фасад рискует стать божественным объектом (объектом, который хранит и делает “слишком много”), привязанным ко всем классам программы</p></div></div><h3 id="9b67ed15-e9f8-41e0-b5f1-b32e1c6d0a48" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="2b629b29-d9f7-4457-9908-fe6dec301902"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Коду приходится работать с большим количеством объектов какой-то сложной библиотеки или фреймворка. В результате логика классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.</div></figure><h3 id="b627f6d8-bc16-402a-a84b-6277735822f1" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="90f51b7a-9838-48e9-8c4c-bfb4197b5ab5" class="column-list"><div id="c2e5e216-f075-4a1b-ab32-3653c2aae5cf" style="width:43.75%" class="column"><figure id="ef66b551-60b5-4fb3-ac71-688d8387059b" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2046.png"><img style="width:980px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2046.png"/></a></figure></div><div id="186f4bf3-813d-487a-8352-44f6e6176b9b" style="width:56.25%" class="column"><ul id="b63ebbfa-23fe-48d7-8739-dc8d54038393" class="bulleted-list"><li style="list-style-type:disc">создание простого интерфейса для работы со сложной подсистемой</li></ul><ul id="b14657e8-95e9-481b-863a-f060eeba96d1" class="bulleted-list"><li style="list-style-type:disc">предоставить клиенту только те фичи, которые ему нужны, и скрыть остальные</li></ul></div></div><h3 id="b5a1a412-64c6-45b8-958a-b1b4c2992fc9" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="422ee3df-515c-409e-820b-4876327ee625" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2047.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2047.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="412be666-0f1b-4778-883d-412e5fed04dc" class="code"><code class="language-Python">class Facade:
    &quot;&quot;&quot;
    Класс Фасада предоставляет простой интерфейс для сложной логики 
		одной или нескольких подсистем. Фасад передаёт запросы клиентов 
		соответствующим объектам внутри подсистемы. 
		Фасад также отвечает за управление их жизненным циклом. 
		Все это защищает клиента от нежелательной сложности подсистемы.
    &quot;&quot;&quot;
    def __init__(self, subsystem1: Subsystem1, subsystem2: Subsystem2):
        &quot;&quot;&quot;
        В зависимости от потребностей приложения можно 
				предоставить Фасаду существующие объекты подсистемы или 
				заставить Фасад создать их самостоятельно.
        &quot;&quot;&quot;
        self._subsystem1 = subsystem1 or Subsystem1()
        self._subsystem2 = subsystem2 or Subsystem2()

    def operation(self) -&gt; str:
        &quot;&quot;&quot;
        Методы Фасада удобны для быстрого доступа 
				к сложной функциональности подсистем. 
				Однако клиенты получают только часть возможностей подсистемы.
        &quot;&quot;&quot;
        results = []
        results.append(&quot;Facade initializes subsystems:&quot;)
        results.append(self._subsystem1.operation1())
        results.append(self._subsystem2.operation1())
        results.append(&quot;Facade orders subsystems to perform the action:&quot;)
        results.append(self._subsystem1.operation_n())
        results.append(self._subsystem2.operation_z())
        return &quot;\n&quot;.join(results)


class Subsystem1:
    &quot;&quot;&quot;
    Подсистема может принимать запросы либо от фасада, 
		либо от клиента напрямую. В любом случае, для Подсистемы Фасад 
		– это ещё один клиент, и он не является частью Подсистемы.
    &quot;&quot;&quot;
    def operation1(self) -&gt; str:
        return &quot;Subsystem1: Ready!&quot;

    def operation_n(self) -&gt; str:
        return &quot;Subsystem1: Go!&quot;


class Subsystem2:
    &quot;&quot;&quot;
    Некоторые фасады могут работать с разными подсистемами одновременно.
    &quot;&quot;&quot;
    def operation1(self) -&gt; str:
        return &quot;Subsystem2: Get ready!&quot;

    def operation_z(self) -&gt; str:
        return &quot;Subsystem2: Fire!&quot;


def client_code(facade: Facade) -&gt; None:
    &quot;&quot;&quot;
    Клиентский код работает со сложными подсистемами через простой интерфейс,
    предоставляемый Фасадом. 
		Когда фасад управляет жизненным циклом подсистемы,
    клиент может даже не знать о существовании подсистемы. 
		Такой подход позволяет держать сложность под контролем.
    &quot;&quot;&quot;
    print(facade.operation(), end=&quot;&quot;)


if __name__ == &quot;__main__&quot;:
    # В клиентском коде могут быть уже созданы некоторые объекты подсистемы. 
		# В этом случае может оказаться целесообразным 
		# инициализировать Фасад с этими объектами вместо того,
		# чтобы позволить Фасаду создавать новые экземпляры.
    subsystem1 = Subsystem1()
    subsystem2 = Subsystem2()
    facade = Facade(subsystem1, subsystem2)
    client_code(facade)
		# Facade initializes subsystems:
		# Subsystem1: Ready!
		# Subsystem2: Get ready!
		# Facade orders subsystems to perform the action:
		# Subsystem1: Go!
		# Subsystem2: Fire!</code></pre></details></li></ul><ul id="ce99afb4-2415-4285-8f02-7bff49021db7" class="toggle"><li><details open=""><summary>14. Структурные паттерны. Декоратор, компоновщик.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="601058bf-fe18-4498-976b-41e979ff40a4"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Паттерн или шаблон проектирования</strong></span> — проверенная архитектурная конструкция для решения определённой частовозникающей проблемы<br/><br/><span style="border-bottom:0.05em solid"><strong>Структурные паттерны</strong></span> — паттерны, рассматривающие образование более крупных структур из классов и объектов<br/><br/>К структурным паттернам относятся:<br/>- адаптер (adapter)<br/>- мост (bridge)<br/>- фасад (facade)<br/>- декоратор (decorator)<br/>- компоновщик (composite)<br/>- заместитель (proxy)<br/>- приспособленец (flyweight)<br/></div></figure><h1 id="7dceca0a-fc9e-4351-80b7-415bee9a08bd" class=""><span style="border-bottom:0.05em solid">Декоратор (Decorator)</span></h1><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="7410fd39-01b1-434c-9af6-d14903bb6060"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Заместитель</strong></span> сам <strong><mark class="highlight-red">контролирует</mark></strong> жизнь сервисного объекта<br/><br/><span style="border-bottom:0.05em solid"><strong>Декоратор</strong></span> <strong><mark class="highlight-red">контролируется</mark></strong> клиентом</div></figure><div id="0dec58e3-5764-49eb-aea0-216569623b6b" class="column-list"><div id="eb143c07-4af6-4ec9-aa15-dbf0bb6b9a31" style="width:43.75%" class="column"><figure id="4b262cdb-c93a-4524-9ff3-9b8ff9e582ff" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2048.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2048.png"/></a></figure></div><div id="a178e999-b0c0-4692-b0ff-7415d5b3deb4" style="width:56.25%" class="column"><p id="ec4f9a90-5fff-4b46-a0be-16fcc506d424" class="">Структурный паттерн, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».</p></div></div><h3 id="82c5aad7-9159-4001-9b05-68e625e871a5" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="4bbd4c15-670d-476b-8b19-869e06e46068" class="column-list"><div id="477cc137-f497-40e0-9b64-2bb84479b464" style="width:50%" class="column"><p id="006c6b88-7b59-4fad-bf7d-67b32f06dcc6" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет добавлять обязанности на лету</p><p id="cbbb96ce-972f-4404-9a7d-6bd546472fcd" class=""><mark class="highlight-teal"><strong>+</strong></mark> большая гибкость, чем у наследования</p><p id="8b1145e3-9f91-429c-babf-313aed36c02f" class=""><mark class="highlight-teal"><strong>+</strong></mark> можно добавлять несколько новых обязанностей сразу</p><p id="24edf6ac-06e4-4712-9095-3de2a49e1cd8" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни</p></div><div id="ce785c60-1662-4c8c-962b-3625a776b402" style="width:50%" class="column"><p id="4dcce513-0764-4578-91a0-93d2be3a9687" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>обилие крошечных классов</p><p id="49c4a687-22d4-450e-91e2-5187084bcc19" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>трудно конфигурировать многократно обёрнутые объекты</p></div></div><h3 id="ee5694e6-32fd-4bdd-9e33-2183d68cd977" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="70208ff9-c384-40fa-9529-5f8eea3487ba"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Библиотеку оповещений можно подключить к разнообразным программам, чтобы с помощью метода <code>send</code> основного класса <code>Nofitier</code> рассылать администраторам указанное сообщение по электронной почте.</div></figure><div id="14ed8c6b-df69-4a2a-bc9b-a666c33aa6ba" class="column-list"><div id="6c7e658a-1326-40b4-a653-9936e094a01d" style="width:43.75%" class="column"><figure id="d59de49b-a0cd-4f03-b62a-7c9d5fe470ce" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2049.png"><img style="width:1080px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2049.png"/></a></figure><figure id="7238cda3-34bf-4126-b931-5e8ffcb02334" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2050.png"><img style="width:880px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2050.png"/></a></figure><figure id="41343f7c-f89c-4600-8a63-d5e5af0cf4ba" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2051.png"><img style="width:1260px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2051.png"/></a></figure></div><div id="863e0588-3785-482c-aa2a-100fbe345f6c" style="width:56.25%" class="column"><p id="a1710a2c-269f-4c14-bda1-97bd534ab71f" class="">Email-оповещений оказалось мало, нужно добавить уведомления в SMS, Facebook и Slack. </p><p id="df166140-e29d-4246-88d8-75fb2782a347" class="">Можно добавить каждый из этих типов оповещений в программу в виде отдельных классов, унаследовав их от базового <code>Notifier</code>. Сейчас можно выбрать только один тип оповещения. </p><p id="af190b5a-e2af-4cde-add7-b78ead1b7912" class="">Если для создания комбинаций сделать ещё подклассы, то код сильно раздуется. </p><p id="77ad5c10-01bb-4cb0-83e6-f8b33260deaf" class="">Если использовать наследование, то не получится изменить поведение существующего объекта, а также не получится наследовать поведение нескольких классов одновременно.</p></div></div><h3 id="7d0e6ad6-3aad-40b2-a4a8-3cf832a96a72" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="5aed3703-e57c-4448-8da9-dabbe4071454" class="column-list"><div id="0bcd3bf3-078c-4a90-adca-e22ff50f2022" style="width:43.75%" class="column"><figure id="694f78c8-cbfe-41d0-866f-5e73839ad99a" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2052.png"><img style="width:1100px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2052.png"/></a></figure><figure id="a695b2bf-29eb-41b2-9b15-2ba31fe07cd0" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2053.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2053.png"/></a></figure><figure id="8aaf1462-20a1-46ae-a86b-bd104d21a69f" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2054.png"><img style="width:600px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2054.png"/></a></figure><figure id="03bccb17-b922-4313-beed-df52f4af14d1" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2055.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2055.png"/></a></figure></div><div id="8062331f-c7f4-4bc5-9729-13e0b2a033c0" style="width:56.25%" class="column"><ul id="6013234e-55f1-49f5-a53e-1dbbca0fe414" class="bulleted-list"><li style="list-style-type:disc">поместить целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё</li></ul><ul id="9d3e162c-6c44-4658-a747-d776e5cd591b" class="bulleted-list"><li style="list-style-type:disc">оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым</li></ul><ul id="90a6553f-0d7e-490c-94cb-b93c0bd8ac0a" class="bulleted-list"><li style="list-style-type:disc">можно использовать несколько разных обёрток одновременно</li></ul></div></div><h3 id="be943819-218a-454c-865d-47dd02978240" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="86f4e98d-041f-4e4b-bfec-7b5884840d93" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2056.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2056.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f3251f6f-9d82-41e1-a67b-fdaa372af6ce" class="code"><code class="language-Python"># в Python декораторы существуют по умолчанию (см. билет 9)
# здесь реализация декоратора вручную
from abc import ABC, abstractmethod

class Component(ABC):
    &quot;&quot;&quot;
    Базовый интерфейс Компонента определяет поведение, 
		которое изменяется декораторами.
    &quot;&quot;&quot;
		@abstractmethod
    def operation(self) -&gt; str:
        pass

class ConcreteComponent(Component):
    &quot;&quot;&quot;
    Конкретные Компоненты предоставляют реализации поведения по умолчанию. 
		Может быть несколько вариаций этих классов.
    &quot;&quot;&quot;
    def operation(self) -&gt; str:
        return &quot;ConcreteComponent&quot;

class Decorator(Component):
    &quot;&quot;&quot;
    Базовый класс Декоратора следует тому же интерфейсу других компонентов. 
		Основная цель этого класса - определить интерфейс обёртки для всех
		конкретных декораторов. 
		Реализация кода обёртки по умолчанию может включать в себя 
		поле для хранения завёрнутого компонента и средства его инициализации.
    &quot;&quot;&quot;
    _component: Component = None

    def __init__(self, component: Component) -&gt; None:
        self._component = component

    @property
    def component(self) -&gt; Component:
        &quot;&quot;&quot;
        Декоратор передаёт всю работу обёрнутому компоненту.
        &quot;&quot;&quot;
        return self._component

    def operation(self) -&gt; str:
        return self._component.operation()

class ConcreteDecoratorA(Decorator):
    &quot;&quot;&quot;
    Конкретные Декораторы вызывают обёрнутый объект 
		и изменяют его результат некоторым образом.
    &quot;&quot;&quot;
    def operation(self) -&gt; str:
        &quot;&quot;&quot;
        Декораторы могут вызывать родительскую реализацию операции, 
				вместо того, чтобы вызвать обёрнутый объект напрямую. 
				Такой подход упрощает расширение классов декораторов.
        &quot;&quot;&quot;
        return f&quot;ConcreteDecoratorA({self.component.operation()})&quot;

class ConcreteDecoratorB(Decorator):
    &quot;&quot;&quot;
    Декораторы могут выполнять своё поведение до или после вызова обёрнутого
    объекта.
    &quot;&quot;&quot;
    def operation(self) -&gt; str:
        return f&quot;ConcreteDecoratorB({self.component.operation()})&quot;

def client_code(component: Component) -&gt; None:
    &quot;&quot;&quot;
    Клиентский код работает со всеми объектами, 
		используя интерфейс Компонента.
    Таким образом, он остаётся независимым от конкретных классов компонентов, 
		с которыми работает.
    &quot;&quot;&quot;
    print(f&quot;RESULT: {component.operation()}&quot;, end=&quot;&quot;)

if __name__ == &quot;__main__&quot;:
    # клиентский код может поддерживать как простые компоненты...
    simple = ConcreteComponent()
    print(&quot;Client: I&#x27;ve got a simple component:&quot;)
    client_code(simple)

    # ...так и декорированные
    # декораторы могут обёртывать не только простые
    # компоненты, но и другие декораторы.
    decorator1 = ConcreteDecoratorA(simple)
    decorator2 = ConcreteDecoratorB(decorator1)
    print(&quot;Client: Now I&#x27;ve got a decorated component:&quot;)
    client_code(decorator2)</code></pre><h1 id="89a09a79-2346-4548-9a9a-71b1ea2b0e11" class=""><span style="border-bottom:0.05em solid">Компоновщик (Composite)</span></h1><div id="0ea03d90-7890-47c0-b729-7272aec63858" class="column-list"><div id="73a3ec1b-cf05-4567-9377-513bf6d12281" style="width:43.75%" class="column"><figure id="ba3f8e9b-235b-4501-9634-11e3177f949f" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2057.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2057.png"/></a></figure></div><div id="5361ab76-ae79-41ff-99d0-bee70c6a12b5" style="width:56.25%" class="column"><p id="8dac982f-383c-49d5-a8c9-f2b5289ba2a8" class="">Структурный паттерн, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.</p></div></div><h3 id="8e0ef69a-3913-4a86-a44a-128bb011f270" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="40cab44e-2af2-4a95-ae28-93dadb508773" class="column-list"><div id="f2aa5f15-f2fa-44df-939c-16c5bd3a7cf3" style="width:50%" class="column"><p id="b6b4d9f2-8435-4503-82f3-5b3963541a7f" class=""><mark class="highlight-teal"><strong>+</strong></mark> облегчает добавление новых видов компонентов</p><p id="3601bf80-b61d-42f1-95ee-5d09896ec4ea" class=""><mark class="highlight-teal"><strong>+</strong></mark> упрощает архитектуру клиента при работе со сложным деревом компонентов</p></div><div id="f703b89f-967f-4b0c-a284-4b1433d4b189" style="width:50%" class="column"><p id="25480173-f9f1-44ba-97f4-9f3f6a01c4e8" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>создаёт слишком общий дизайн классов</p></div></div><h3 id="49fa2814-e6f0-490a-963b-f859e4354530" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6267dcb8-6861-444b-902e-2abdb6a0fab5"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Программа состоит из заказов. Заказ может содержать как продукты, так и коробки. Коробки в свою очередь могут содержать продукты и другие коробки, которые могут содержать продукты и коробки и так далее. Нужно узнать цену всего заказа.</div></figure><div id="fe99ce26-bb62-48d5-a388-99e2810e7f8c" class="column-list"><div id="ab4a2b80-19c8-4910-b891-086b382133b4" style="width:43.75%" class="column"><figure id="80bfb637-689e-4eca-9fab-8a8a75b24ac8" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2058.png"><img style="width:740px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2058.png"/></a></figure></div><div id="7b16d7c2-82ab-44c2-b232-c073d092cba0" style="width:56.25%" class="column"><p id="14dad550-f4d9-4ba3-aca5-09750175cef0" class="">Если решать задачу в лоб, то придётся открыть все коробки заказа, перебрать все продукты и посчитать их суммарную стоимость. </p><p id="8c65242b-186b-4dc0-b901-c3f0d86f508c" class="">
</p><p id="9b92b622-57f7-4458-a5fe-fd35425ef668" class="">Но типы коробок, их содержимое и уровень вложенности коробок могут быть неизвестны, что усложняет задачу. </p></div></div><h3 id="9213dc93-07ad-4830-b087-15275d23244c" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="8c625d20-43df-4fea-bf4c-319f7f5f221f" class="column-list"><div id="3f8e2645-6dea-4a9c-891a-916b889ab86c" style="width:43.75%" class="column"><figure id="28ee3475-6254-4a82-8258-962be3ff6b9c" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2059.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2059.png"/></a></figure><figure id="4fef1c76-8542-4288-b9dd-c439f8c4e6e6" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2060.png"><img style="width:560px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2060.png"/></a></figure></div><div id="2686f685-be94-4b9b-94f2-c60f03b7bce0" style="width:56.25%" class="column"><ul id="b241771c-426c-4a45-adbf-a3c350d0e8e9" class="bulleted-list"><li style="list-style-type:disc">рассматривать продукт и коробку через единый интерфейс с общим методом получения стоимости: продукт вернёт свою цену, а коробка — спросит цену у предметов в ней и вернёт сумму</li></ul><ul id="55d93a3d-74cb-4b75-a306-92133a0589fb" class="bulleted-list"><li style="list-style-type:disc">клиенту ничего не нужно знать о структуре заказов, нужно только вызывать метод получения цены и получить результат</li></ul><p id="17e165fb-0405-484c-b97c-f7c7367f3901" class="">
</p></div></div><h3 id="752e7828-b698-461c-891b-9e3e7fc27127" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="17696be1-de18-4bee-b6b3-f335f33a876d" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2061.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2061.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="592264e2-f1fb-4390-a5c0-5eb92a7a5cec" class="code"><code class="language-Python">from abc import ABC, abstractmethod
from typing import List


class Component(ABC):
    &quot;&quot;&quot;
    Базовый класс Компонент объявляет общие операции 
		как для простых, так и для сложных объектов структуры.
    &quot;&quot;&quot;
    @property
    def parent(self) -&gt; Component:
        return self._parent

    @parent.setter
    def parent(self, parent: Component):
        &quot;&quot;&quot;
        При необходимости базовый Компонент может объявить интерфейс для
        установки и получения родителя компонента в древовидной структуре. 
				Он также может предоставить некоторую реализацию 
				по умолчанию для этих методов.
        &quot;&quot;&quot;
        self._parent = parent

    &quot;&quot;&quot;
    В некоторых случаях целесообразно определить 
		операции управления потомками прямо в базовом классе Компонент. 
		Таким образом, не нужно будет предоставлять конкретные классы 
		компонентов клиентскому коду, даже во время сборки дерева объектов. 
		Недостаток такого подхода в том, что эти методы
    будут пустыми для компонентов уровня листа.
    &quot;&quot;&quot;
    def add(self, component: Component) -&gt; None:
        pass

    def remove(self, component: Component) -&gt; None:
        pass

    def is_composite(self) -&gt; bool:
        &quot;&quot;&quot;
        Можно предоставить метод, который позволит клиентскому коду понять,
        может ли компонент иметь вложенные объекты.
        &quot;&quot;&quot;
        return False

    @abstractmethod
    def operation(self) -&gt; str:
        &quot;&quot;&quot;
        Базовый Компонент может сам реализовать некоторое поведение 
				по умолчанию или поручить это конкретным классам, 
				объявив абстрактным метод, содержащий поведение.
        &quot;&quot;&quot;
        pass


class Leaf(Component):
    &quot;&quot;&quot;
    Класс Лист представляет собой конечные объекты структуры. 
		Лист не может иметь вложенных компонентов.
    Обычно объекты Листьев выполняют фактическую работу, тогда как объекты
    Контейнера лишь передают работу своим подкомпонентам.
    &quot;&quot;&quot;
    def operation(self) -&gt; str:
        return &quot;Leaf&quot;


class Composite(Component):
    &quot;&quot;&quot;
    Класс Контейнер содержит сложные компоненты, 
		которые могут иметь вложенные компоненты. 
		Обычно объекты Контейнеры передают фактическую работу своим
    детям, а затем «суммируют» результат.
    &quot;&quot;&quot;
    def __init__(self) -&gt; None:
        self._children: List[Component] = []

    &quot;&quot;&quot;
    Объект контейнера может как добавлять компоненты в свой список вложенных
    компонентов, так и удалять их, как простые, так и сложные.
    &quot;&quot;&quot;
    def add(self, component: Component) -&gt; None:
        self._children.append(component)
        component.parent = self

    def remove(self, component: Component) -&gt; None:
        self._children.remove(component)
        component.parent = None

    def is_composite(self) -&gt; bool:
        return True

    def operation(self) -&gt; str:
        &quot;&quot;&quot;
        Контейнер выполняет свою основную логику особым образом. 
				Он проходит рекурсивно через всех своих детей, 
				собирая и суммируя их результаты.
        Поскольку потомки контейнера передают эти вызовы своим потомкам 
				и так далее, в результате обходится всё дерево объектов.
        &quot;&quot;&quot;
        results = []
        for child in self._children:
            results.append(child.operation())
        return f&quot;Branch({&#x27;+&#x27;.join(results)})&quot;


def client_code(component: Component) -&gt; None:
    &quot;&quot;&quot;
    Клиентский код работает со всеми компонентами через базовый интерфейс.
    &quot;&quot;&quot;
    print(f&quot;RESULT: {component.operation()}&quot;, end=&quot;&quot;)


def client_code2(component1: Component, component2: Component) -&gt; None:
    &quot;&quot;&quot;
    Благодаря тому, что операции управления потомками объявлены 
		в базовом классе Компонента, клиентский код может работать 
		как с простыми, так и со сложными компонентами, 
		вне зависимости от их конкретных классов.
    &quot;&quot;&quot;
    if component1.is_composite():
        component1.add(component2)
    print(f&quot;RESULT: {component1.operation()}&quot;, end=&quot;&quot;)


if __name__ == &quot;__main__&quot;:
    # Таким образом, клиентский код может поддерживать 
		# простые компоненты-листья...
    simple = Leaf()
    print(&quot;Client: I&#x27;ve got a simple component:&quot;)
    client_code(simple)
		# RESULT: Leaf

    # ...а также сложные контейнеры.
    tree = Composite()
    branch1 = Composite()
    branch1.add(Leaf())
    branch1.add(Leaf())
    branch2 = Composite()
    branch2.add(Leaf())
    tree.add(branch1)
    tree.add(branch2)

    print(&quot;Client: Now I&#x27;ve got a composite tree:&quot;)
    client_code(tree)
		# RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))

    print(&quot;Client: I don&#x27;t need to check the components &quot;
					&quot;classes even when managing the tree:&quot;)
    client_code2(tree, simple)
		# RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)</code></pre></details></li></ul><ul id="0dc45322-bfea-4e45-8f03-3cb95c1d5eda" class="toggle"><li><details open=""><summary>15. Структурные паттерны. Фасад. Заместитель. Приспособленец🤮 (Легковес👍).</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="4c36d011-a6d6-4c92-b157-389ff9df07c2"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Паттерн или шаблон проектирования</strong></span> — проверенная архитектурная конструкция для решения определённой частовозникающей проблемы<br/><br/><span style="border-bottom:0.05em solid"><strong>Структурные паттерны</strong></span> — паттерны, рассматривающие образование более крупных структур из классов и объектов<br/><br/>К структурным паттернам относятся:<br/>- адаптер (adapter)<br/>- мост (bridge)<br/>- фасад (facade)<br/>- декоратор (decorator)<br/>- компоновщик (composite)<br/>- заместитель (proxy)<br/>- приспособленец (flyweight)<br/></div></figure><h1 id="a5989c87-e56c-4167-bac0-6ccd194bca66" class=""><span style="border-bottom:0.05em solid">Фасад</span></h1><p id="7fddc73d-9536-4ecf-a236-ee7e0f6faf0d" class="">См. билет 13.</p><h1 id="7b6b2e71-e40a-4bd9-9c01-e58997872738" class=""><span style="border-bottom:0.05em solid">Заместитель (Proxy)</span></h1><div id="d6b5fc58-6f01-4747-8057-b326888285e3" class="column-list"><div id="069f1a8b-1a28-4092-bf92-80fc4d301c48" style="width:43.75%" class="column"><figure id="7fef305e-09fe-4e34-9bd4-56c48d660edf" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2062.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2062.png"/></a></figure></div><div id="bf86341f-c4e4-40d8-a4d8-c3383e5e69b9" style="width:56.25%" class="column"><p id="6ff7dfad-45fe-4076-bbf9-2536467155a2" class="">Структурный паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.</p></div></div><h3 id="dd0aba48-cb0e-4288-93d4-c01cf6edc2f4" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="13c1565d-9e68-411d-807e-81abd4638c54" class="column-list"><div id="ae4c1ba4-eb1d-43e9-bfd5-bdfd7203168d" style="width:50%" class="column"><p id="01e7d036-7137-41c4-9239-6e563c288b72" class=""><mark class="highlight-teal"><strong>+</strong></mark> может работать, даже если сервисный объект ещё не создан</p><p id="6096007f-975c-49dd-897b-338c729e742b" class=""><mark class="highlight-teal"><strong>+</strong></mark> может контролировать жизненный цикл сервисного объекта</p><p id="c17420db-e46b-4427-af19-f5c23095ded9" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет контролировать сервисный объект незаметно для клиента</p></div><div id="d2a668e6-899b-4322-82d6-2f759596ec2c" style="width:50%" class="column"><p id="780c486c-f881-4acc-a4b2-b5b96ebee5ba" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>увеличивает время отклика от сервиса</p><p id="503fe3ec-85ef-4ac2-87ae-0fcecffc0473" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>усложняет код программы из-за введения дополнительных классов</p></div></div><h3 id="2c82bde0-8d8c-4daa-a4bf-ebf11445cfd1" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="3b571d58-6693-4668-bad8-7bcec8a6d604"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Есть внешний ресурсоёмкий объект, который нужен не все время, а изредка.</div></figure><div id="b37e102a-64c2-4f9a-a040-c2faba044ffa" class="column-list"><div id="1ac23401-6355-4bbf-9cb8-870e35f1a5f3" style="width:43.75%" class="column"><figure id="173164b9-4041-4974-9caa-d5d4b5dcf2d2" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2063.png"><img style="width:1020px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2063.png"/></a></figure></div><div id="d335a2e8-bf10-4308-96d1-f1c5f81843c3" style="width:56.25%" class="column"><p id="e29997af-3fee-4449-91cb-38e57d4d8dd0" class="">Можно создавать объект не в самом начале программы, а только когда он кому-то понадобится (использовать отложенную инициализацию). Но, вероятно, это привело бы к множественному дублированию кода.</p><p id="2b22a0de-7786-4e06-8be2-9537e766b3bb" class="">В идеале этот код поместить прямо в сервисный класс, но это не всегда возможно. Например, код класса может находиться в закрытой сторонней библиотеке.</p></div></div><h3 id="42ae2263-68ee-4956-951d-25dfbed747ff" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="6f54e6c7-a46a-4ad7-a48e-8636964ccbf9" class="column-list"><div id="0bb7b449-4b1b-48ab-8fa1-ac6c1dcb664a" style="width:43.75%" class="column"><figure id="baa92ea3-9e30-4cc8-a21a-6e9d56d8d062" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2064.png"><img style="width:1020px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2064.png"/></a></figure><figure id="84106c34-b8ee-4b3b-8dcd-bddd9be4f895" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2065.png"><img style="width:1080px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2065.png"/></a></figure></div><div id="9741a2e1-ab0f-42a1-8f7a-bf2b2551428c" style="width:56.25%" class="column"><ul id="60b9add4-54a7-4fa7-8291-ba886c64bdc0" class="bulleted-list"><li style="list-style-type:disc">создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный сервисный объект</li></ul><ul id="6ea83d72-9201-4567-b526-16f5e25036b0" class="bulleted-list"><li style="list-style-type:disc">при получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта и переадресовывал бы ему всю реальную работу.</li></ul><ul id="5643cd1e-1b40-42ac-ba04-4ce0884408df" class="bulleted-list"><li style="list-style-type:disc">поместить в класс-дублёр промежуточную логику, которая выполнялась бы до или после вызовов методов</li></ul></div></div><h3 id="9f307795-1319-4625-ac73-a796c2232344" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="6805c0db-0d48-4e02-a1d3-ecced15852b2" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2066.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2066.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4de3402a-b675-49a0-b621-44159023d744" class="code"><code class="language-Python">from abc import ABC, abstractmethod

# ServiceInterface
class Subject(ABC):
    &quot;&quot;&quot;
    Интерфейс Субъекта объявляет общие операции как для Реального Субъекта, 
		так и для Заместителя. Пока клиент работает с Реальным Субъектом, 
		используя этот интерфейс, можно передать ему 
		заместителя вместо реального субъекта.
    &quot;&quot;&quot;
    @abstractmethod
    def request(self) -&gt; None:
        pass

# Service
class RealSubject(Subject):
    &quot;&quot;&quot;
    Реальный Субъект содержит некоторую базовую бизнес-логику. 
		Как правило, Реальные Субъекты способны выполнять некоторую 
		полезную работу, которая может быть очень медленной или точной,
		например, коррекция входных данных. 
		Заместитель может решить эти задачи без каких-либо изменений в коде
    Реального Субъекта.
    &quot;&quot;&quot;
    def request(self) -&gt; None:
        print(&quot;RealSubject: Handling request.&quot;)


class Proxy(Subject):
    &quot;&quot;&quot;
    Интерфейс Заместителя идентичен интерфейсу Реального Субъекта.
    &quot;&quot;&quot;
    def __init__(self, real_subject: RealSubject) -&gt; None:
        self._real_subject = real_subject

    def request(self) -&gt; None:
        &quot;&quot;&quot;
        Наиболее распространёнными областями применения паттерна Заместитель
        являются ленивая загрузка, кэширование, контроль доступа, ведение
        журнала и т.д. 
				Заместитель может выполнить одну из этих задач, а затем,
        в зависимости от результата, передать выполнение 
				одноимённому методу в связанном объекте класса Реального Субъекта.
        &quot;&quot;&quot;
        if self.check_access():
            self._real_subject.request()
            self.log_access()

    def check_access(self) -&gt; bool:
        print(&quot;Proxy: Checking access prior to firing a real request.&quot;)
        return True

    def log_access(self) -&gt; None:
        print(&quot;Proxy: Logging the time of request.&quot;, end=&quot;&quot;)


def client_code(subject: Subject) -&gt; None:
    &quot;&quot;&quot;
    Клиентский код должен работать со всеми объектами 
		(как с реальными, так и заместителями) через интерфейс Субъекта, 
		чтобы поддерживать как реальные субъекты, так и заместителей. 
		В реальной жизни, однако, клиенты в основном работают 
		с реальными субъектами напрямую. В этом случае, для более простой
    реализации паттерна, можно расширить заместителя из класса реального
    субъекта.
    &quot;&quot;&quot;
    subject.request()


if __name__ == &quot;__main__&quot;:
    print(&quot;Client: Executing the client code with a real subject:&quot;)
    real_subject = RealSubject()
    client_code(real_subject)
    print(&quot;Client: Executing the same client code with a proxy:&quot;)
    proxy = Proxy(real_subject)
    client_code(proxy)</code></pre><h1 id="a89f3301-ba4b-4326-9f53-5b7c7589f867" class=""><span style="border-bottom:0.05em solid">Легковес (Flyweight)</span></h1><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="dee0bb59-43b5-40f7-ac5d-c4726e89b1f4"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%">Паттерн был упрощён Тенигиным А.А.</div></figure><div id="911ce63b-969e-473f-8e73-b85048e81228" class="column-list"><div id="0752da29-6e6a-473c-b3c9-3a71d553bb0d" style="width:43.75%" class="column"><figure id="443b71d1-75b6-4897-ace0-5be37d590bde" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2067.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2067.png"/></a></figure></div><div id="366b36dd-4781-4b71-98d4-d4a2435e67f9" style="width:56.25%" class="column"><p id="5ba48209-3b7a-4577-9985-a002be5b7a11" class="">Структурный паттерн, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.</p></div></div><h3 id="43a605a7-57ab-4d0d-a4d6-f5295db2b968" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="30e35af3-01b8-4664-aee1-f5df48ee681c" class="column-list"><div id="4d3c2732-be51-431c-96ed-d64cb03fc942" style="width:50%" class="column"><p id="1398578e-bd06-4fc0-bf18-6ee7f7bde82c" class=""><mark class="highlight-teal"><strong>+</strong></mark> экономит оперативную память</p><p id="fead6af6-940d-49d6-b9b2-f499f3892605" class="">
</p></div><div id="b9983cb4-6b65-4aaf-9c00-fa498accb4e7" style="width:50%" class="column"><p id="c5143ab8-37f9-432a-be30-73fdc362d7e2" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>расходует процессорное время на поиск</p><p id="21e70b08-43cb-4135-b9a1-ce851d6fca8a" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>усложняет код программы из-за введения дополнительных классов</p></div></div><h3 id="ad58dc78-c86d-4162-84c4-99927f387951" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a579ee72-10a8-492c-a44e-e98f287f2b91"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">В игре игроки пинают разнообразные мячи. Фишка игры — у мячей могут быть разные цвета, вес, суперсила.<br/>Но на слабых ПК игра вылетает через пару минут из-за недостатка оперативной памяти, ведь каждый мяч занимает немало места.<br/></div></figure><h3 id="d60a56ba-af39-4dec-ba50-10850083e0a6" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><ul id="f7dc4d4a-bc41-4c0b-8fff-28efe0cfab36" class="bulleted-list"><li style="list-style-type:disc">если объект с такими свойствами уже существует, то вернуть его вместо создания нового (не создавать новый мяч, а отдать существующий)</li></ul><ul id="7041acf9-c529-4d5f-b1e0-9bb1a4ce2877" class="bulleted-list"><li style="list-style-type:disc">если объекта с такими свойствами не существует, то создать его</li></ul><h3 id="f62adc02-d4fc-4877-aa6d-88fad906504a" class=""><span style="border-bottom:0.05em solid">Код</span></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c246e0a4-8c40-40fd-bfcb-ba372f579252" class="code"><code class="language-Python"># создаём миксин (родительский класс для добавления возможностей)
class FlyweightMixin:
		_memo = {}
		
		def __new__(cls, *args, **kwargs):
				# переводим все атрибуты в строку и хешируем её
				# для использования в виде ключа
				args_ = &quot;&quot;.join(str(arg) for arg in args)
				kwargs_ = &quot;&quot;.join(f&quot;{key}:{value}&quot; for key, value in kwargs.items())
				key = hash((cls, args_, kwargs_))
				# если объект с такими свойствами (таким хешем) отсутствует,
				# то создаём его
				if not cls._memo.get(key):
						cls._memo[key] = super().__new__(cls)
				# всегда возвращаем объект: созданный или существующий
				return cls._memo[key]

class Ball(FlyweightMixin):
		def __init__(self, color: str, size: int):
				self.color, self.size = color, size</code></pre></details></li></ul><ul id="df8c2f88-54b7-4f85-b720-6e7650ef4b22" class="toggle"><li><details open=""><summary>16. Поведенческие паттерны. Цепочка ответственности. Команда.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="44ecc06e-5b1b-4e71-be14-590e00c3976a"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Паттерн или шаблон проектирования</strong></span> — проверенная архитектурная конструкция для решения определённой частовозникающей проблемы<br/><br/><span style="border-bottom:0.05em solid"><strong>Поведенческие паттерны</strong></span> — паттерны, определяющие способы и алгоритмы совместной работы различных классов и объектов<br/><br/>К поведенческим паттернам относятся:<br/>- цепочка обязанностей (chain of responsibility)<br/>- команда (command)<br/>- итератор (iterator)<br/>- хранитель (memento)<br/>- наблюдатель (observer)<br/>- шаблонный метод (template method)<br/>- состояние (state)<br/>- стратегия (strategy)<br/>- посетитель (visitor)<br/></div></figure><h1 id="3af112ac-4b98-4cc1-a4d4-e3b1c3fad7fd" class=""><span style="border-bottom:0.05em solid">Цепочка обязанностей (Chain of responsibility)</span></h1><div id="79dca533-c2fd-4ba3-a944-efd507c20662" class="column-list"><div id="d3c82478-160b-4abc-8edb-ba2c6435d4f9" style="width:43.75%" class="column"><figure id="8212fd68-adc3-4543-aa99-0bff61c7a39d" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2068.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2068.png"/></a></figure></div><div id="d315bcf5-e67b-40ef-8dac-70665ec4feb4" style="width:56.25%" class="column"><p id="5da2d87d-b91a-4212-8662-9e5c8f597295" class="">Поведенческий паттерн, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.</p></div></div><h3 id="f4892c9f-4a4e-465d-a72a-420be7436569" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="eba9d21d-941a-4a54-a779-1c8ea649cc73" class="column-list"><div id="82ed2828-845a-4675-b05e-cf368312d887" style="width:50%" class="column"><p id="85db2aa8-2d26-45b2-b4f0-70cc57b6e9ef" class=""><mark class="highlight-teal"><strong>+</strong></mark> уменьшает зависимость между клиентами и обработчиками</p><p id="0ed44a01-879d-49bb-9b81-f20afdae2b23" class=""><mark class="highlight-teal"><strong>+</strong></mark> реализует принципы открытости-закрытости и единственной ответственности (S, O в SOLID)</p></div><div id="3b82483d-5138-4065-90cd-89df77aa05cf" style="width:50%" class="column"><p id="0f3341ef-b0f9-4cb0-adca-beb7c7f7c100" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>запрос может остаться никем не обработанным</p></div></div><h3 id="9f046efd-d1d3-4b5f-9b91-30744ecb96e5" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="83c2205c-6928-4028-bdf3-30da79e5b851"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">В системе приёма онлайн-заказов нужно сделать ограничения:<br/>- только авторизованные пользователи могут создавать заказы<br/>- только администраторы имеют полный доступ к заказам<br/>Самый лучший вариант — выполнять проверки последовательно. <br/></div></figure><div id="b8496a92-b0cc-42a1-a5f9-96afd076a4e0" class="column-list"><div id="77863ee6-8801-4aa0-a3d8-b4a87406101c" style="width:43.75%" class="column"><figure id="397f0db5-652b-42ef-b678-38d90afab45b" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2069.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2069.png"/></a></figure><figure id="c6d844bd-9416-4ffd-8ccc-727a300421e7" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2070.png"><img style="width:1220px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2070.png"/></a></figure></div><div id="7a53d50f-ef5a-4b6f-8019-6ea9710060c0" style="width:56.25%" class="column"><p id="c2ac3ce0-ca43-4935-9258-2657cb422300" class="">При обновлении системы неизбежно будут добавляться новые проверки, клубок будет становиться больше. </p><p id="eb77caba-1b2f-4139-8a93-5f5c7c2ee238" class="">
</p><p id="32c0ddb8-b51b-41c3-b518-152aa159b73a" class="">При изменении одного проверки придётся трогать код всех остальных, а для применения проверок к другим ресурсам код придётся дублировать. Такую систему сложно поддерживать.</p></div></div><h3 id="e530eff2-5496-42a4-90f3-0ca1185db229" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="bf13be26-5756-445c-b8dd-d4b630fab015" class="column-list"><div id="f5a4592c-cb4f-4472-b003-eb97a87eea07" style="width:43.75%" class="column"><figure id="834f8e55-35a4-4f19-ad94-ad6b9e4cbf52" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2071.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2071.png"/></a></figure><figure id="efdc65ae-963a-41dc-b544-0a8edac709b7" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2072.png"><img style="width:1040px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2072.png"/></a></figure><figure id="df4457d0-489c-4356-93c2-ee28dabfed4b" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2073.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2073.png"/></a></figure></div><div id="cb33ec6f-f396-451a-9a10-251c2dd91b34" style="width:56.25%" class="column"><ul id="cf48f4ff-d1aa-4931-b06c-4bf545010a2f" class="bulleted-list"><li style="list-style-type:disc">переместить каждую проверку в отдельный класс с единственным методом выполнения, данные проверки будут передаваться как аргументы</li></ul><ul id="04775104-c73b-4865-80b0-b060cdae5bcd" class="bulleted-list"><li style="list-style-type:disc">связать объекты обработчиков в одну цепь, где каждый из них будет иметь ссылку на следующий обработчик в цепи</li></ul><ul id="1883838d-4f36-473b-98ba-9f13110a320d" class="bulleted-list"><li style="list-style-type:disc">при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке</li></ul><ul id="6bb4f886-fe05-4cb5-822b-ac6b14a47068" class="bulleted-list"><li style="list-style-type:disc">можно быть уверенным, что объект обработается всеми обработчиками в успешном случае, но один из них может не передать запрос дальше</li></ul></div></div><h3 id="2062094d-0b40-4413-98b1-4b66826cc270" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="06abb1f0-4a60-4359-8a1b-434a5c4a5b50" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2074.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2074.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e38a9584-8f66-43c6-93bf-044b3789f1d5" class="code"><code class="language-Python">from abc import ABC, abstractmethod
from typing import Any, Optional, TypeVar

class Handler(ABC):
    &quot;&quot;&quot;
    Интерфейс Обработчика объявляет метод построения цепочки обработчиков. 
		Он также объявляет метод для выполнения запроса.
    &quot;&quot;&quot;
    @abstractmethod
    def set_next(self, handler: &quot;Handler&quot;) -&gt; &quot;Handler&quot;:
        pass

    @abstractmethod
    def handle(self, request) -&gt; Optional[str]:
        pass

# или BaseHandler
class AbstractHandler(Handler):
    &quot;&quot;&quot;
    Поведение цепочки по умолчанию может быть реализовано 
		внутри базового класса обработчика.
    &quot;&quot;&quot;
    _next_handler: Handler = None

    def set_next(self, handler: Handler) -&gt; Handler:
        self._next_handler = handler
        # возврат обработчика отсюда позволит 
				# связать обработчики простым способом:
        # monkey.set_next(squirrel).set_next(dog)
        return handler

    @abstractmethod
    def handle(self, request: Any) -&gt; str:
        if self._next_handler:
            return self._next_handler.handle(request)
        return None

&quot;&quot;&quot;
Все Конкретные Обработчики либо обрабатывают запрос, либо передают его
следующему обработчику в цепочке.
&quot;&quot;&quot;
class MonkeyHandler(AbstractHandler):
    def handle(self, request: Any) -&gt; str:
        if request == &quot;Banana&quot;:
            return f&quot;Monkey: I&#x27;ll eat the {request}&quot;
        return super().handle(request)

class SquirrelHandler(AbstractHandler):
    def handle(self, request: Any) -&gt; str:
        if request == &quot;Nut&quot;:
            return f&quot;Squirrel: I&#x27;ll eat the {request}&quot;
        return super().handle(request)

class DogHandler(AbstractHandler):
    def handle(self, request: Any) -&gt; str:
        if request == &quot;MeatBall&quot;:
            return f&quot;Dog: I&#x27;ll eat the {request}&quot;
        return super().handle(request)

def client_code(handler: Handler) -&gt; None:
    &quot;&quot;&quot;
    Обычно клиентский код приспособлен для работы с единственным обработчиком. 
		В большинстве случаев клиенту даже неизвестно, 
		что этот обработчик является частью цепочки.
    &quot;&quot;&quot;
    for food in [&quot;Nut&quot;, &quot;Banana&quot;, &quot;Cup of coffee&quot;]:
        print(f&quot;\nClient: Who wants a {food}?&quot;)
        result = handler.handle(food)
        if result:
            print(f&quot;  {result}&quot;, end=&quot;&quot;)
        else:
            print(f&quot;  {food} was left untouched.&quot;, end=&quot;&quot;)


if __name__ == &quot;__main__&quot;:
    monkey = MonkeyHandler()
    squirrel = SquirrelHandler()
    dog = DogHandler()
    monkey.set_next(squirrel).set_next(dog)

    # Клиент должен иметь возможность отправлять запрос любому обработчику, 
		# а не только первому в цепочке.
    print(&quot;Chain: Monkey &gt; Squirrel &gt; Dog&quot;)
    client_code(monkey)
    print(&quot;Subchain: Squirrel &gt; Dog&quot;)
    client_code(squirrel)</code></pre><h1 id="9f582fcf-5c85-4f16-b164-9bad66860715" class=""><span style="border-bottom:0.05em solid">Команда (Command)</span></h1><div id="093ebdc5-cd11-4b2f-a500-3f9e25f87de4" class="column-list"><div id="65253170-9548-4728-9670-dd30a526fa9c" style="width:43.75%" class="column"><figure id="6886cfe2-7f84-45ff-978f-6e94e068a1f4" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2075.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2075.png"/></a></figure></div><div id="ab4f96c7-656b-47ec-833e-cb6c59d92fe2" style="width:56.25%" class="column"><p id="776fd4bf-7a38-4d90-9c3f-21a471bb7319" class="">Поведенческий паттерн, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.</p><p id="d7d601b2-74ad-45be-b1f2-1f398dc98906" class="">
</p></div></div><h3 id="cb153aa6-1b18-48fa-a0eb-77837a0ff25f" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="93367e87-fd2c-47bd-8f0e-cee8ac5e53c0" class="column-list"><div id="7706e1fb-d7ce-4ed2-a26a-3974c0f13239" style="width:50%" class="column"><p id="33c31de2-94c8-4a2f-94a9-687afeca5d6f" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет собирать сложные команды из простых</p><p id="f0c21df7-26dc-43b6-b5fd-b33a7fc6c72c" class=""><mark class="highlight-teal"><strong>+</strong></mark> реализует принцип открытости-закрытости (O в SOLID)</p><p id="a4c09b38-58ab-4124-9436-0c2da07ea017" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет реализовать простую отмену и повтор операций, а также отложенный запуск операций</p><p id="58033604-1217-4174-abe9-fe0fc4310125" class=""><mark class="highlight-teal"><strong>+</strong></mark> убирает прямую зависимость между объектами, вызывающими и выполняющими операции</p></div><div id="a19545ec-06e0-4ae1-9382-8ae173b2705d" style="width:50%" class="column"><p id="e060009f-cede-4563-a1dc-8ba2e99ed192" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>усложняет код программы из-за введения множества дополнительных классов</p></div></div><h3 id="bd5ee351-9379-4bd4-b9df-f3b9f40d9645" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1694ee4a-9c9f-47a2-b0e9-29d2981387a4"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Есть класс красивых кнопок, который будет использоваться для всех кнопок приложения. Все они выглядят схоже, но делают совершенно разные вещи. Возникает вопрос: Куда поместить код обработчиков кликов по ним?</div></figure><div id="8069350b-737d-413f-92ba-73a79451e937" class="column-list"><div id="5f7d96ac-ac6e-4b14-9df0-9d981af0328f" style="width:43.75%" class="column"><figure id="cf64b875-ab51-4f41-954e-482bb0b44c52" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2076.png"><img style="width:460px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2076.png"/></a></figure><figure id="a7a35a86-19da-40c8-89cb-061e33940694" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2077.png"><img style="width:800px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2077.png"/></a></figure><figure id="3900fcf7-b56b-48a7-8247-4c048ddc75a9" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2078.png"><img style="width:960px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2078.png"/></a></figure></div><div id="df9faac7-bae9-47d3-94ce-6858ffb5a941" style="width:56.25%" class="column"><p id="41d005c0-6e38-4e2b-a1a3-ffb844dbf8fd" class="">Самым простым решением было бы создать подклассы для каждой кнопки и переопределить в них метод действия под разные задачи. </p><p id="111cf417-5237-4990-b724-fcaea614e851" class="">Но в таком случае получается много подклассов, а также код кнопок (относящийся к графическому интерфейсу) начинает зависеть от бизнес-логики, которая часто меняется.</p><p id="8487fbba-bb37-4e0c-b1e2-07b18a8e5b7b" class="">Также некоторые операции, например, «сохранить», можно вызывать из нескольких мест: нажав кнопку на панели управления, вызвав контекстное меню или просто нажав сочетание клавиш. Когда в программе были только кнопки, код сохранения имелся только в подклассе <code>SaveButton</code>. Но теперь его придётся продублировать ещё в два класса.</p></div></div><h3 id="b2a2f383-3556-4a36-8ad9-4cd5465eb0cd" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="5be1dc2a-f6bc-4493-aa1b-d1c129f5cd41" class="column-list"><div id="128396c8-afea-499f-bd87-b4bf11333bd7" style="width:43.75%" class="column"><figure id="085860c0-c6c4-488f-937c-7b8189590fb0" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2079.png"><img style="width:940px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2079.png"/></a></figure><figure id="0b5edbd7-f8ee-4c26-a9ec-e000a0eeaefc" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2080.png"><img style="width:1100px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2080.png"/></a></figure><figure id="dca99598-8375-4eba-91ba-c1bc855a5932" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2081.png"><img style="width:880px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2081.png"/></a></figure><figure id="33fe634e-54ed-4faf-ac92-ad1e30badfd0" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2082.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2082.png"/></a></figure></div><div id="abff9b0c-167b-4668-979f-fd57e6619f31" style="width:56.25%" class="column"><ul id="2fae1b6b-2a30-4e34-a873-66d658d8d395" class="bulleted-list"><li style="list-style-type:disc">отправлять вызовы из пользовательского слоя в слой бизнес-логики не напрямую, а завернуть их в специальные классы (команды) с единственным методом, который будет осуществлять вызов</li></ul><ul id="6ad11f0d-63e8-48a9-b36e-27daec883ada" class="bulleted-list"><li style="list-style-type:disc">к объекту пользовательского интерфейса можно будет привязать объект команды, который знает кому и в каком виде  следует отправлять запросы, а также какие параметры ему нужны</li></ul><ul id="0f7b30fe-124c-41b7-9292-74e5231e6362" class="bulleted-list"><li style="list-style-type:disc">объект интерфейса в любой момент может вызвать метод команды, а тот сделает всю работу</li></ul><ul id="25cc4e07-c500-4666-94f4-93c72fa3150f" class="bulleted-list"><li style="list-style-type:disc">классы команд можно объединить под общим интерфейсом c единственным методом запуска, а значит отправители смогут работать с различными взаимозаменяемыми командами, не привязываясь к их классам</li></ul><p id="fd066013-b6fe-4a6a-9a3f-00019df8ca19" class="">
</p></div></div><h3 id="cd7a5bfe-e19d-4350-b451-5a2dc3f00b34" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="957814cb-85f4-4476-8c23-10d824c60635" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2083.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2083.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4a4ea0f8-f3f3-4d8f-af50-eebb9d1a6d40" class="code"><code class="language-Python">from abc import ABC, abstractmethod

class Command(ABC):
    &quot;&quot;&quot;
    Интерфейс Команды объявляет метод для выполнения команд.
    &quot;&quot;&quot;
    @abstractmethod
    def execute(self) -&gt; None:
        pass

class SimpleCommand(Command):
    &quot;&quot;&quot;
    Некоторые команды способны выполнять простые операции самостоятельно.
    &quot;&quot;&quot;
    def __init__(self, payload: str) -&gt; None:
        self._payload = payload

    def execute(self) -&gt; None:
        print(f&quot;SimpleCommand: See, I can do simple things like printing&quot;
              f&quot;({self._payload})&quot;)

class ComplexCommand(Command):
    &quot;&quot;&quot;
    Но есть и команды, которые передают более сложные операции другим
    объектам, называемым «получателями».
    &quot;&quot;&quot;
    def __init__(self, receiver: Receiver, a: str, b: str) -&gt; None:
        &quot;&quot;&quot;
        Сложные команды могут принимать один или несколько 
				объектов-получателей вместе с любыми данными 
				о контексте через конструктор.
        &quot;&quot;&quot;
        self._receiver = receiver
        self._a = a
        self._b = b

    def execute(self) -&gt; None:
        &quot;&quot;&quot;
        Команды могут передавать выполнение любым методам получателя.
        &quot;&quot;&quot;
        print(&quot;ComplexCommand: Complex stuff should be &quot;
							&quot;done by a receiver object&quot;, end=&quot;&quot;)
        self._receiver.do_something(self._a)
        self._receiver.do_something_else(self._b)

class Receiver:
    &quot;&quot;&quot;
    Классы Получателей содержат некую важную бизнес-логику. 
		Они умеют выполнять все виды операций, связанных с выполнением запроса. 
		Фактически, любой класс может выступать Получателем.
    &quot;&quot;&quot;
    def do_something(self, a: str) -&gt; None:
        print(f&quot;\nReceiver: Working on ({a}.)&quot;, end=&quot;&quot;)

    def do_something_else(self, b: str) -&gt; None:
        print(f&quot;\nReceiver: Also working on ({b}.)&quot;, end=&quot;&quot;)

class Invoker:
    &quot;&quot;&quot;
    Отправитель связан с одной или несколькими командами. 
		Он отправляет запрос команде.
    &quot;&quot;&quot;
    _on_start = None
    _on_finish = None

    # инициализация команд
    def set_on_start(self, command: Command):
        self._on_start = command

    def set_on_finish(self, command: Command):
        self._on_finish = command

    def do_something_important(self) -&gt; None:
        &quot;&quot;&quot;
        Отправитель не зависит от классов конкретных команд и получателей.
        Отправитель передаёт запрос получателю косвенно, выполняя команду.
        &quot;&quot;&quot;
        print(&quot;Invoker: Does anybody want something done before I begin?&quot;)
        if isinstance(self._on_start, Command):
            self._on_start.execute()
        print(&quot;Invoker: ...doing something really important...&quot;)
        print(&quot;Invoker: Does anybody want something done after I finish?&quot;)
        if isinstance(self._on_finish, Command):
            self._on_finish.execute()

if __name__ == &quot;__main__&quot;:
    &quot;&quot;&quot;
    Клиентский код может параметризовать отправителя любыми командами.
    &quot;&quot;&quot;
    invoker = Invoker()
    invoker.set_on_start(SimpleCommand(&quot;Say Hi!&quot;))
    receiver = Receiver()
    invoker.set_on_finish(ComplexCommand(
        receiver, &quot;Send email&quot;, &quot;Save report&quot;))
    invoker.do_something_important()</code></pre></details></li></ul><ul id="f77b255a-dc41-4585-add9-4d996ef6461d" class="toggle"><li><details open=""><summary>17. Поведенческие паттерны.<mark class="highlight-yellow"> </mark>Итератор. Хранитель. Наблюдатель.<mark class="highlight-yellow"> </mark>Шаблонный метод.</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="b56b0663-5d09-4d67-890e-d353c70e9f16"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Паттерн или шаблон проектирования</strong></span> — проверенная архитектурная конструкция для решения определённой частовозникающей проблемы<br/><br/><span style="border-bottom:0.05em solid"><strong>Поведенческие паттерны</strong></span> — паттерны, определяющие способы и алгоритмы совместной работы различных классов и объектов<br/><br/>К поведенческим паттернам относятся:<br/>- цепочка обязанностей (chain of responsibility)<br/>- команда (command)<br/>- итератор (iterator)<br/>- хранитель (memento)<br/>- наблюдатель (observer)<br/>- шаблонный метод (template method)<br/>- состояние (state)<br/>- стратегия (strategy)<br/>- посетитель (visitor)<br/></div></figure><h1 id="b6d9f612-d356-45c7-a64f-aeeb30dd5f89" class=""><span style="border-bottom:0.05em solid">Итератор (Iterator)</span></h1><div id="22bc82b0-3db1-449e-ad76-1d6ad90a55b9" class="column-list"><div id="052ed0e6-e4d5-4965-bb1a-6f06a2134b78" style="width:43.75%" class="column"><figure id="d26a9f18-d22d-41de-b99e-0c98a4f9bd62" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2084.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2084.png"/></a></figure></div><div id="01d0f56a-24de-4d01-9231-3e2ee2bfbbe2" style="width:56.25%" class="column"><p id="5f731236-cd88-4104-a2a8-0d5766bcaf12" class="">Поведенческий паттерн, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.</p></div></div><h3 id="4b90e833-8396-46c1-8346-0b40280ca99a" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="4a7b2956-77b7-42da-83f3-e0fd7bb4505a" class="column-list"><div id="631e5511-c888-4592-96d7-f64d23e937dd" style="width:50%" class="column"><p id="815873cf-a050-4824-a7e7-a643ba25fa55" class=""><mark class="highlight-teal"><strong>+</strong></mark> упрощает классы хранения данных</p><p id="37708a41-1fc5-46f6-9774-f74223a16fd7" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет реализовывать различные способы обхода структуры данных</p><p id="964fbced-61d3-489c-9493-43875e4dfcf6" class=""><mark class="highlight-teal"><strong>+</strong></mark> позволяет одновременно перемещаться по структуре данных в обе стороны</p></div><div id="32c8c144-a559-4a28-a061-efb8bbc2f856" style="width:50%" class="column"><p id="5810d232-3b14-426b-810b-8c03bad95209" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>не оправдан, если можно обойтись простым циклом</p></div></div><h3 id="d79e14ce-7bbd-4d6f-a39a-14bea77acbb4" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6254b571-dd02-4296-82ff-ea87ecf7441b"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Коллекции — самая распространённая структура данных, набор объектов, собранный в одну кучу по каким-то критериям. Коллекции могут быть в виде: списка, дерева, графа и других сложных структур данных. Пользователь должен иметь возможность последовательно обходить элементы коллекции.</div></figure><div id="6d4707a9-6248-4dce-a638-e9cb34483c2b" class="column-list"><div id="2a25b956-4cb0-4692-bc21-8faad88f34d8" style="width:43.75%" class="column"><figure id="a46c981a-8003-4517-9a98-79057450e9d5" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2085.png"><img style="width:980px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2085.png"/></a></figure><figure id="7d9b008c-0c58-4b23-8c4d-a41d6460d8a4" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2086.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2086.png"/></a></figure></div><div id="b0d03c29-9637-4e21-99c2-329d5a813d32" style="width:56.25%" class="column"><p id="402c981f-f37c-4858-a015-6f239cde41c1" class="">Есть много способов и алгоритмов перемещаться по коллекции. Добавляя новые в код коллекции, размывается её основная задача — эффективное хранение данных. </p><p id="309bbbf0-294c-4506-b7dd-229bb6333406" class="">Некоторые алгоритмы могут быть вовсе «заточены» под определённое приложение и смотреться дико в общем классе коллекции.</p></div></div><h3 id="7673387c-abf0-4963-9ab3-91547238555d" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="b273028d-f1fc-4688-9e71-41578bd867ad" class="column-list"><div id="42410742-cb2e-42f9-a682-70e1f808e433" style="width:43.75%" class="column"><figure id="172729cc-93fc-4acf-86e4-4eb929c8533d" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2087.png"><img style="width:800px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2087.png"/></a></figure><figure id="f31081ad-bce1-4e7e-8ee8-a12df1f2b72f" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2088.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2088.png"/></a></figure></div><div id="3d8bdcf5-db57-4de8-a5fb-5b2a7d412c2d" style="width:56.25%" class="column"><ul id="603e3150-c807-423c-a86f-11df58436be3" class="bulleted-list"><li style="list-style-type:disc">вынести поведение обхода коллекции из самой коллекции в отдельный класс</li></ul><ul id="1beff6b6-0e7b-4b11-b3b6-bd64080867f7" class="bulleted-list"><li style="list-style-type:disc">объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти</li></ul><ul id="4d93c42e-ab11-4977-b021-841f2de4ced3" class="bulleted-list"><li style="list-style-type:disc">одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом</li></ul><ul id="423e3ba8-a984-42b5-b672-0b8ce4a6bf8e" class="bulleted-list"><li style="list-style-type:disc">чтобы добавить новый способ обхода, можно создать отдельный класс итератора, не изменяя существующий код коллекции</li></ul></div></div><h3 id="07bac76b-d503-44a5-bb85-a10fe6eafd12" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="313990ab-8bde-440a-9e79-634f935366a6" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2089.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2089.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4d727871-8bc0-4353-a3dd-4e87be57ef19" class="code"><code class="language-Python"># более простой итератор, созданный не по структуре
class DownwardCounter:
    def __init__(self, start: int) -&gt; None:
				self.start = start
        self._set_current(start)

    def _set_current(self, new: int) -&gt; None:
        if not isinstance(new, int):
            raise TypeError(f&#x27;{self.__class__.__name__} &#x27;
														f&#x27;expects start to be int&#x27;)
        if new &lt; 0:
            raise ValueError(f&#x27;{self.__class__.__name__} &#x27;
														 f&#x27;expects positive start&#x27;)
        self._current = new

		# метод __iter__ должен возвращать итератор (себя в данном случае)
    def __iter__(self) -&gt; Self:
        return self

		# метод __next__ должен возвращать следующий элемент
    def __next__(self) -&gt; int:
				# бесконечный итератор, сбрасывается когда был исчерпан
        if not self._current:
						self._set_current(self.start)
            raise StopIteration
				# возвращение нового значения
        self._current -= 1
        return self._current + 1

if __name__ == &quot;__main__&quot;:
		counter = DownwardCounter(2)
		for value in counter:
		    print(value, end=&quot; &quot;)  # 2 1 StopIteration
		for value in counter:
		    print(value, end=&quot; &quot;)  # 2 1</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e2776beb-b21c-462d-af7f-e04bd3e712d3" class="code"><code class="language-Python">from collections.abc import Iterable, Iterator
from typing import Any, List

&quot;&quot;&quot;
Для создания итератора в Python есть два абстрактных класса 
из встроенного модуля collections - Iterable, Iterator. 
Нужно реализовать метод __iter__() в итерируемом объекте (списке), 
а метод __next__() - в итераторе.
&quot;&quot;&quot;
class AlphabeticalOrderIterator(Iterator):
    &quot;&quot;&quot;
    Конкретные Итераторы реализуют различные алгоритмы обхода. 
		Эти классы постоянно хранят текущее положение обхода.
		&quot;&quot;&quot;
		# хранит текущее положение обхода
		# у итератора может быть множество других полей для хранения состояния
		# особенно когда он должен работать с определённым типом коллекции
    _position: int = None

		# указывает направление обхода
    _reverse: bool = False

    def __init__(self, collection: WordsCollection, reverse: bool = False):
        self._collection = collection
        self._reverse = reverse
        self._position = -1 if reverse else 0

    def __next__(self):
        &quot;&quot;&quot;
        Метод __next __() должен вернуть следующий элемент 
				в последовательности. При достижении конца коллекции 
				и в последующих вызовах должно вызываться исключение StopIteration.
        &quot;&quot;&quot;
        try:
            value = self._collection[self._position]
            self._position += -1 if self._reverse else 1
        except IndexError:
            raise StopIteration()
        return value

class WordsCollection(Iterable):
    &quot;&quot;&quot;
    Конкретные Коллекции предоставляют один или несколько методов 
		для получения новых экземпляров итератора, 
		совместимых с классом коллекции.
    &quot;&quot;&quot;
    def __init__(self, collection: List[Any] = []) -&gt; None:
        self._collection = collection

    def __iter__(self) -&gt; AlphabeticalOrderIterator:
        &quot;&quot;&quot;
        Метод __iter__() возвращает объект итератора, 
				по умолчанию мы возвращаем итератор с сортировкой по возрастанию.
        &quot;&quot;&quot;
        return AlphabeticalOrderIterator(self._collection)

    def get_reverse_iterator(self) -&gt; AlphabeticalOrderIterator:
        return AlphabeticalOrderIterator(self._collection, True)

    def add_item(self, item: Any):
        self._collection.append(item)

if __name__ == &quot;__main__&quot;:
    # Клиентский код может знать или не знать 
		# о Конкретном Итераторе или классах Коллекций 
		# в зависимости от уровня косвенности, 
		# который нужно сохранить в программе
    collection = WordsCollection()
    collection.add_item(&quot;First&quot;)
    collection.add_item(&quot;Second&quot;)
    collection.add_item(&quot;Third&quot;)

    print(&quot;Straight traversal:&quot;)
    print(&quot; &quot;.join(collection))
		# First Second Third

    print(&quot;Reverse traversal:&quot;)
    print(&quot; &quot;.join(collection.get_reverse_iterator()))
		# Third Second First</code></pre><h1 id="d0c65139-6ef5-4cc1-9940-7367b149148f" class=""><span style="border-bottom:0.05em solid">Хранитель (Memento)</span></h1><div id="cc509e89-d794-4884-8877-c10297285d97" class="column-list"><div id="375da883-5260-4700-a6a9-b2f4f297fa20" style="width:43.75%" class="column"><figure id="ea13a7d0-3ee8-407a-9e87-96742bed0147" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2090.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2090.png"/></a></figure></div><div id="c263f4e6-e78f-4d73-a4a9-2620b293c7c4" style="width:56.25%" class="column"><p id="f2d49c60-e75f-45e0-9c43-6b3c4ad5aa2e" class="">Поведенческий паттерн, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.</p></div></div><h3 id="44b6cc63-1d29-402e-b9db-94489f98535f" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="9e7f7079-3b3e-4851-a5a0-8c75054161cb" class="column-list"><div id="da9e3676-46d2-4501-a2b6-da0c3d1eebb5" style="width:50%" class="column"><p id="4b67fe14-f695-4bca-a9e8-adee30b4e132" class=""><mark class="highlight-teal"><strong>+</strong></mark> не нарушает инкапсуляции исходного объекта</p><p id="2c206f8d-710e-405d-9aaa-2af1054f31d3" class=""><mark class="highlight-teal"><strong>+</strong></mark> упрощает структуру исходного объекта. Ему не нужно хранить историю версий своего состояния</p></div><div id="2cce08ba-aa9b-4156-a99d-a174a74042f2" style="width:50%" class="column"><p id="553c65ec-5482-413e-9279-e80aecfc0bdb" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>требует много памяти, если клиенты слишком часто создают снимки</p><p id="4863dcfb-26e9-40cd-9895-97c40d4fa7ce" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>в некоторых языках (например, PHP, Python, JavaScript) сложно гарантировать, чтобы только исходный объект имел доступ к состоянию снимка</p><p id="7c983e8d-a450-4fef-878b-d0733efea038" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>может повлечь дополнительные издержки памяти, если объекты, хранящие историю, не удаляют устаревшие снимки</p></div></div><h3 id="35c00f98-25ac-4f83-81c0-62ef8b8ffc59" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="ccb21675-6c9f-4e3e-9c53-b5052fef6a01"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Редактор текста позволяет писать текст, редактировать и форматировать его, вставлять картинки и т.п. Отличной идеей будет сделать все эти действия отменяемыми: сохранять состояние редактора перед любым действием и восстанавливать его при отмене. </div></figure><div id="0fe49169-d4c8-41e4-a40d-5d908d535db2" class="column-list"><div id="cedc6ba3-c3ee-41f7-9526-cbfdb8628726" style="width:43.75%" class="column"><figure id="c58535e6-ff8a-4cef-a464-c3059460f097" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2091.png"><img style="width:940px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2091.png"/></a></figure><figure id="f4e8bd76-469a-4582-9478-088337b03c26" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2092.png"><img style="width:660px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2092.png"/></a></figure></div><div id="91bd5e58-2bf6-4c94-89f6-32380c218706" style="width:56.25%" class="column"><p id="6f7a1adb-57a6-48c9-b15e-410ed52341ee" class="">Чтобы сделать копию состояния объекта:</p><p id="84d8df47-274b-4dc8-99a1-281195fc6028" class="">- нужно скопировать значения всех полей, которые должны быть открытыми. Но это приводит к тому, что при их изменении придётся менять код всех копирующих классов.</p><p id="530d934e-a0a6-4fd5-a074-48967c20bc3f" class="">- нужно записать значения всех этих полей в некий «контейнер». Чтобы другие объекты могли записывать и читать из него данные, придётся сделать его поля публичными. Это опять приводит к проблеме открытых полей.</p></div></div><h3 id="f50d06f0-aa19-4321-945f-d2ded78d8d1d" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="ac721f47-c97e-44ec-88ec-f19687ea1de1" class="column-list"><div id="2078f408-137e-4b18-b2ec-2ea411971ef0" style="width:43.75%" class="column"><figure id="d9e21ad2-8a99-44d9-8a48-15b03f472534" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2093.png"><img style="width:1220px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2093.png"/></a></figure></div><div id="c03b4c84-34c1-4b66-b7b9-018b43f8c5da" style="width:56.25%" class="column"><ul id="12a181d3-2478-412c-9cc0-34cc859f8ac9" class="bulleted-list"><li style="list-style-type:disc">поручить создание копии состояния самому объекту</li></ul><ul id="d5c86556-b9e6-467a-92c5-d66033f73036" class="bulleted-list"><li style="list-style-type:disc">держать копию состояния в специальном объекте-снимке с ограниченным интерфейсом (например, узнать название)</li></ul><ul id="fe80e955-5ed5-4a9c-ba76-b096ccf15652" class="bulleted-list"><li style="list-style-type:disc">снимок должен быть открыт для своего создателя, позволяя прочесть и восстановить его внутреннее состояние</li></ul><ul id="e388d9a1-1719-411f-870f-19ed8625bc90" class="bulleted-list"><li style="list-style-type:disc">создатель будет производить снимки и отдавать их для хранения другим объектам — опекунам, которые не смогут поменять снимок из-за его ограниченного интерфейса</li></ul></div></div><h3 id="d053a58c-8a4f-497a-b4d5-09d3394b9e39" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="fa64fb82-43b3-463b-992f-fdb2701d7607" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2094.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2094.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="807a9d63-d4c6-4488-8403-f11d402f0874" class="code"><code class="language-Python">from abc import ABC, abstractmethod
from datetime import datetime
from random import sample
from string import ascii_letters


class Originator:
    &quot;&quot;&quot;
    Создатель содержит некоторое важное состояние, 
		которое может со временем меняться. 
		Он также объявляет метод save сохранения состояния внутри снимка и
    метод restore восстановления состояния из него.
    &quot;&quot;&quot;
		# для удобства состояние создателя хранится внутри одной переменной
    _state = None

    def __init__(self, state: str) -&gt; None:
        self._state = state
        print(f&quot;Originator: My initial state is: {self._state}&quot;)

    def do_something(self) -&gt; None:
        &quot;&quot;&quot;
        Бизнес-логика Создателя может повлиять на его внутреннее состояние.
        Поэтому клиент должен выполнить резервное копирование состояния с
        помощью метода save перед запуском методов бизнес-логики.
        &quot;&quot;&quot;
        print(&quot;Originator: I&#x27;m doing something important.&quot;)
        self._state = self._generate_random_string(30)
        print(f&quot;Originator: and my state has changed to: {self._state}&quot;)

    @staticmethod
    def _generate_random_string(length: int = 10) -&gt; str:
        return &quot;&quot;.join(sample(ascii_letters, length))

    def save(self) -&gt; Memento:
        return ConcreteMemento(self._state)

    def restore(self, memento: Memento) -&gt; None:
        self._state = memento.get_state()
        print(f&quot;Originator: My state has changed to: {self._state}&quot;)


class Memento(ABC):
    &quot;&quot;&quot;
    Интерфейс Снимка предоставляет способ извлечения метаданных снимка, 
		таких как дата создания или название. 
		Однако он не раскрывает состояние Создателя.
    &quot;&quot;&quot;
    @abstractmethod
    def get_name(self) -&gt; str:
        pass

    @abstractmethod
    def get_date(self) -&gt; str:
        pass


class ConcreteMemento(Memento):
    def __init__(self, state: str) -&gt; None:
        self._state = state
        self._date = str(datetime.now())[:19]

    def get_state(self) -&gt; str:
        &quot;&quot;&quot;
        Создатель использует этот метод, 
				когда восстанавливает своё состояние.
        &quot;&quot;&quot;
        return self._state

    def get_name(self) -&gt; str:
        &quot;&quot;&quot;
        Остальные методы используются Опекуном для отображения метаданных.
        &quot;&quot;&quot;
        return f&quot;{self._date} / ({self._state[0:9]}...)&quot;

    def get_date(self) -&gt; str:
        return self._date


class Caretaker:
    &quot;&quot;&quot;
    Опекун не зависит от класса Конкретного Снимка. 
		Таким образом, он не имеет доступа к состоянию создателя, 
		хранящемуся внутри снимка. 
		Он работает со всеми снимками через базовый интерфейс Снимка.
    &quot;&quot;&quot;
    def __init__(self, originator: Originator) -&gt; None:
        self._mementos = []
        self._originator = originator

    def backup(self) -&gt; None:
        print(&quot;\nCaretaker: Saving Originator&#x27;s state...&quot;)
        self._mementos.append(self._originator.save())

    def undo(self) -&gt; None:
        if not len(self._mementos):
            return
        memento = self._mementos.pop()
        print(f&quot;Caretaker: Restoring state to: {memento.get_name()}&quot;)
        try:
            self._originator.restore(memento)
        except Exception:
            self.undo()

    def show_history(self) -&gt; None:
        print(&quot;Caretaker: Here&#x27;s the list of mementos:&quot;)
        for memento in self._mementos:
            print(memento.get_name())


if __name__ == &quot;__main__&quot;:
    originator = Originator(&quot;Super-duper-super-puper-super.&quot;)
    caretaker = Caretaker(originator)

    caretaker.backup()
    originator.do_something()
    caretaker.backup()
    originator.do_something()
    caretaker.backup()
    originator.do_something()

    caretaker.show_history()
    print(&quot;\nClient: Now, let&#x27;s rollback!\n&quot;)
    caretaker.undo()
    print(&quot;\nClient: Once more!\n&quot;)
    caretaker.undo()</code></pre><h1 id="0e88cbc6-5297-4d78-bcbe-c1c2a841b21f" class=""><span style="border-bottom:0.05em solid">Наблюдатель (observer)</span></h1><div id="062d6a79-d761-4f75-a786-0f67b3a99f33" class="column-list"><div id="76996589-9abe-4710-8815-3589c84f1a8c" style="width:43.75%" class="column"><figure id="13f1a60a-50be-4600-9c91-912cd0f40052" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2095.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2095.png"/></a></figure></div><div id="5ceb24f6-c56c-48a4-84ab-cde0d5102f23" style="width:56.25%" class="column"><p id="201d7359-92ea-4e89-95b7-fb9355faec9d" class="">Поведенческий паттерн, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.</p></div></div><h3 id="45f6cba7-400e-4aa9-b9ad-7c2c2e0addfc" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="12a19dc4-29b5-4c62-8815-24313f649b7a" class="column-list"><div id="3938b28d-172c-4651-93b8-4a39a21fa584" style="width:50%" class="column"><p id="cb295a30-e3aa-42f0-b9f6-8615c1efea19" class=""><mark class="highlight-teal"><strong>+</strong></mark> издатели не зависят от конкретных классов подписчиков и наоборот</p><p id="43b9e706-1dbf-463d-bedf-b7b0f154dad8" class=""><mark class="highlight-teal"><strong>+</strong></mark> можно подписывать и отписывать получателей на лету</p><p id="9fb86bc2-deee-4683-9e01-60cf1a4b6d59" class=""><mark class="highlight-teal"><strong>+</strong></mark> реализует принцип открытости-закрытости (O в SOLID)</p></div><div id="ff9eed20-03fd-4147-bf29-06f1ce7666d6" style="width:50%" class="column"><p id="5f7514cf-450c-4f47-9075-f36ab22a8fd4" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>подписчики оповещаются в случайном порядке</p></div></div><h3 id="24ce7704-4fe9-4509-a70d-660b2563a1f5" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="865156e4-94dc-4e65-9fcb-72b2c4ef24e1"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">В магазин вот-вот должны завести новый товар, который интересен покупателю. Покупатель злится, что он тратит драгоценное время пока ходит каждый день в магазин, чтобы проверить наличие товара. </div></figure><div id="b100f2a2-4321-438e-bf7b-ece55375c41c" class="column-list"><div id="85819f8e-c74e-4d12-9528-80bb9b2144c0" style="width:43.75%" class="column"><figure id="d527b857-1160-4854-b773-68b8ad631c21" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2096.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2096.png"/></a></figure></div><div id="35faafd2-332b-46d6-bb64-4a44a780b330" style="width:56.25%" class="column"><p id="6fcdf37f-93e6-4e0f-96a3-2bc2fedf66a8" class="">Магазин может разослать спам каждому своему покупателю, но многих это расстроит, так как определённый товар нужен далеко не всем.</p></div></div><h3 id="ba87da4a-faef-4b09-aadc-6b59081c3787" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="ed06e83a-15fa-4436-b128-0ba61594ca49" class="column-list"><div id="05b46249-75f7-4018-87c3-943d7822349b" style="width:43.75%" class="column"><figure id="0f5ce78b-3259-4ec0-b36a-98e07c83980a" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2097.png"><img style="width:940px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2097.png"/></a></figure><figure id="53f34160-5ac8-4da8-b9d9-5ac2fbb6618b" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2098.png"><img style="width:920px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2098.png"/></a></figure><figure id="d80ae5c7-335b-4453-b02a-cf8081aae472" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2099.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%2099.png"/></a></figure></div><div id="098cd34a-e3e7-48d5-943c-483cd811f68c" style="width:56.25%" class="column"><ul id="61968b25-edca-4c9a-9200-6723c7f039c7" class="bulleted-list"><li style="list-style-type:disc">хранить внутри объекта издателя (объекта с важным состоянием) список ссылок на объекты подписчиков (объекты, которые хотят отслеживать изменения состояния)</li></ul><ul id="cf7757c4-6c1a-4c02-a2ad-9f9916a620c5" class="bulleted-list"><li style="list-style-type:disc">издатель не должен вести список подписчиков самостоятельно, он предоставляет методы, с помощью которых подписчики могут добавлять и убирать себя из списка</li></ul><ul id="b6675d87-f11e-4dd0-a4d3-a776978b9e77" class="bulleted-list"><li style="list-style-type:disc">когда в издателе будет происходить важное изменение, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод у них</li></ul></div></div><h3 id="601b746d-1eaf-4af3-9f81-e4b9976c6efb" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="72bc3c27-806d-4579-a8e2-422d50bdd5d7" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20100.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20100.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6337d8ee-d4d4-4758-8c7f-75860a389bad" class="code"><code class="language-Python">from abc import ABC, abstractmethod
from random import randrange
from typing import List

class Subject(ABC):
    &quot;&quot;&quot;
    Интерфейс издателя объявляет набор методов для управлениями подписчиками:
		присоединение и отсоединение наблюдателя к издателю, 
		а также уведомление всех наблюдателей о событии.
    &quot;&quot;&quot;
    @abstractmethod
    def attach(self, observer: Observer) -&gt; None:
        pass

    @abstractmethod
    def detach(self, observer: Observer) -&gt; None:
        pass

    @abstractmethod
    def notify(self) -&gt; None:
        pass

class ConcreteSubject(Subject):
		# издатель владеет некоторым состоянием, необходимым всем подписчикам,
		# и оповещает наблюдателей об его изменениях
    _state: int = None
		# список подписчиков (наблюдателей), может хранится 
		# в более подробном виде (классифицироваться по типу событие и т.д.)
    _observers: List[Observer] = []

    def attach(self, observer: Observer) -&gt; None:
        print(&quot;Subject: Attached an observer.&quot;)
        self._observers.append(observer)

    def detach(self, observer: Observer) -&gt; None:
        self._observers.remove(observer)

    def notify(self) -&gt; None:
        print(&quot;Subject: Notifying observers...&quot;)
        for observer in self._observers:
            observer.update(self)

    def some_business_logic(self) -&gt; None:
        &quot;&quot;&quot;
        Обычно логика подписки – только часть того, что делает Издатель.
        Издатели часто содержат некоторую важную бизнес-логику, которая
        запускает метод уведомления всякий раз, 
				когда должно произойти что-то важное (или после этого).
        &quot;&quot;&quot;
        print(&quot;\nSubject: I&#x27;m doing something important.&quot;)
        self._state = randrange(0, 10)
        print(f&quot;Subject: My state has just changed to: {self._state}&quot;)
        self.notify()

class Observer(ABC):
    &quot;&quot;&quot;
    Интерфейс Наблюдателя объявляет метод уведомления, который издатели
    используют для оповещения своих подписчиков.
    &quot;&quot;&quot;
    @abstractmethod
    def update(self, subject: Subject) -&gt; None:
        &quot;&quot;&quot;
        Получить обновление от субъекта.
        &quot;&quot;&quot;
        pass

&quot;&quot;&quot;
Конкретные Наблюдатели реагируют на обновления, 
выпущенные Издателем, к которому они прикреплены.
&quot;&quot;&quot;
class ConcreteObserverA(Observer):
    def update(self, subject: Subject) -&gt; None:
        if subject._state &lt; 3:
            print(&quot;ConcreteObserverA: Reacted to the event&quot;)

class ConcreteObserverB(Observer):
    def update(self, subject: Subject) -&gt; None:
        if subject._state == 0 or subject._state &gt;= 2:
            print(&quot;ConcreteObserverB: Reacted to the event&quot;)

if __name__ == &quot;__main__&quot;:
    subject = ConcreteSubject()

    observer_a = ConcreteObserverA()
    subject.attach(observer_a)
    observer_b = ConcreteObserverB()
    subject.attach(observer_b)

    subject.some_business_logic()
    subject.some_business_logic()

    subject.detach(observer_a)
    subject.some_business_logic()</code></pre><h1 id="a7307caa-980d-4b53-a961-78a3180d5681" class=""><span style="border-bottom:0.05em solid">Шаблонный метод (template method)</span></h1><div id="7cdf5ce4-1da9-430c-bd84-3023c9a090b3" class="column-list"><div id="f49b328f-b14e-407e-87c1-2bfa794b8ef0" style="width:43.75%" class="column"><figure id="a3fb9594-d34d-4d07-adca-81399c1ea155" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20101.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20101.png"/></a></figure></div><div id="fe725563-dc5c-4b83-aa2a-20ad8c1ba532" style="width:56.25%" class="column"><p id="a5affb40-412b-4f0f-a8b4-2235b84b3909" class="">Поведенческий паттерн, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы, которые могут их переопределять.</p></div></div><h3 id="8553e87a-8c3d-46ba-904d-01588c7b94fe" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="fdbbd10b-7979-4ae3-b6be-2e51b28988b7" class="column-list"><div id="a1f2eaca-681c-4c5b-8567-6d8701f9a717" style="width:50%" class="column"><p id="65107f31-bfd3-47cf-b942-0335c0512198" class=""><mark class="highlight-teal"><strong>+</strong></mark> облегчает повторное использование кода</p><p id="c1f5c1e5-87d7-4266-85c6-94f876c73fb6" class="">
</p></div><div id="19dcdbec-beaa-44e7-9cfd-72932270e11c" style="width:50%" class="column"><p id="47d59f3d-5ef3-40c7-af02-082903e8d1fe" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>жёсткие ограничения скелетом существующего алгоритма</p><p id="7ba484ba-c7ff-4a06-a2a9-42f2a203a056" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>изменяя базовое поведение одного из шагов алгоритма через подкласс, можно нарушить принцип подстановки Барбары Лисков (L в SOLID)</p><p id="bd8b1c55-f829-47a8-a7df-e52868a4e85c" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>с ростом количества шагов шаблонный метод становится слишком сложно поддерживать</p></div></div><h3 id="bf26c06e-b497-49e4-beb4-f079a8865d1d" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e25420b0-d2b8-4e5e-9ec5-7428162888f4"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">В программу для дата-майнинга в офисных документах пользователи могут загружать документы различных форматов. Сначала была обработка только DOC-файлов, затем стали поддерживаться CSV-файлы, а затем и PDF.</div></figure><div id="6382eb47-aa6d-418c-b03f-570f15a8408e" class="column-list"><div id="e33f0208-8b8d-4c0b-b32b-76061293ae68" style="width:43.75%" class="column"><figure id="b5e10b8c-0b37-461d-bfb1-6c21b9041462" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20102.png"><img style="width:1240px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20102.png"/></a></figure></div><div id="f06c8c07-53f5-45e4-afe7-a9ace600929d" style="width:56.25%" class="column"><p id="f1ef70f5-bc6c-4f40-8605-e1f3145fbf2b" class="">Код всех трёх классов обработки документов содержит довольно много общего в части извлечения данных. </p><p id="a185fc0c-9a27-42df-bdd1-30eec3405f0e" class="">Также остальной код наполнен условиями, проверяющими тип обработчика перед началом работы. </p><p id="d896936b-ea71-4ad9-b61c-533cebcbe11c" class="">Всё это можно упростить, если свести классы к общему интерфейсу.</p></div></div><h3 id="a479d49a-aed3-457d-80d6-2faeadcbfab7" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="25d8752d-f2f0-47fa-a9fa-b36e1cb251cd" class="column-list"><div id="b9198e4b-bdcc-4ea3-a197-03b7fa7a9f10" style="width:43.75%" class="column"><figure id="78dcfd98-07a6-48fa-9e4d-e30a0ed7a4ff" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20103.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20103.png"/></a></figure></div><div id="132920d0-d935-4adc-b182-354ca6173cee" style="width:56.25%" class="column"><ul id="9b9bc2f1-360d-4280-bfd0-e6c20501a253" class="bulleted-list"><li style="list-style-type:disc">разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом</li></ul><ul id="b3b81cbd-4b1e-4fa1-b891-0bd71c51a75f" class="bulleted-list"><li style="list-style-type:disc">позволить подклассам менять только нужные шаги, но оставлять основную структуру алгоритма и ненужные шаги</li></ul><ul id="9b1d73ff-fd03-4f06-8e0c-6d773f8ab3e2" class="bulleted-list"><li style="list-style-type:disc">вынести общее поведение в базовый класс</li></ul></div></div><h3 id="d96d4cd6-bb02-4724-9719-3209da4d8a7d" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="f6931b00-31a9-484b-b7f0-660d40bd16e2" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20104.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20104.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8cc1d46c-0b58-4b4e-92fb-2c9cebb929c9" class="code"><code class="language-Python">from abc import ABC, abstractmethod


class AbstractClass(ABC):
    &quot;&quot;&quot;
    Абстрактный Класс определяет шаблонный метод, 
		содержащий скелет некоторого алгоритма, 
		состоящего из вызовов (обычно) абстрактных примитивных операций.
    Конкретные подклассы должны реализовать эти операции, но оставить сам
    шаблонный метод без изменений.
    &quot;&quot;&quot;
    def template_method(self) -&gt; None:
				# скелет алгоритма
        self.base_operation1()
        self.required_operations1()
        self.base_operation2()
        self.hook1()
        self.required_operations2()
        self.base_operation3()
        self.hook2()

    # эти операции уже имеют реализации
    def base_operation1(self) -&gt; None:
        print(&quot;AbstractClass says: I am doing the bulk of the work&quot;)

    def base_operation2(self) -&gt; None:
        print(&quot;AbstractClass says: &quot;
							&quot;But I let subclasses override some operations&quot;)

    def base_operation3(self) -&gt; None:
        print(&quot;AbstractClass says: &quot;
							&quot;But I am doing the bulk of the work anyway&quot;)

    # а эти должны быть реализованы в подклассах
    @abstractmethod
    def required_operations1(self) -&gt; None:
        pass

    @abstractmethod
    def required_operations2(self) -&gt; None:
        pass

    # Это «хуки». Подклассы могут переопределять их, но это не обязательно,
    # поскольку у хуков уже есть стандартная (но пустая) реализация. Хуки
    # предоставляют дополнительные точки расширения в некоторых критических
    # местах алгоритма.
    def hook1(self) -&gt; None:
        pass

    def hook2(self) -&gt; None:
        pass


class ConcreteClass1(AbstractClass):
    &quot;&quot;&quot;
    Конкретные классы должны реализовать все абстрактные операции базового
    класса. Они также могут переопределить некоторые операции с реализацией по
    умолчанию.
    &quot;&quot;&quot;
    def required_operations1(self) -&gt; None:
        print(&quot;ConcreteClass1 says: Implemented Operation1&quot;)

    def required_operations2(self) -&gt; None:
        print(&quot;ConcreteClass1 says: Implemented Operation2&quot;)


class ConcreteClass2(AbstractClass):
    &quot;&quot;&quot;
    Обычно конкретные классы переопределяют 
		только часть операций базового класса.
    &quot;&quot;&quot;
    def required_operations1(self) -&gt; None:
        print(&quot;ConcreteClass2 says: Implemented Operation1&quot;)

    def required_operations2(self) -&gt; None:
        print(&quot;ConcreteClass2 says: Implemented Operation2&quot;)

    def hook1(self) -&gt; None:
        print(&quot;ConcreteClass2 says: Overridden Hook1&quot;)


def client_code(abstract_class: AbstractClass) -&gt; None:
    &quot;&quot;&quot;
    Клиентский код вызывает шаблонный метод для выполнения алгоритма. 
		Клиентский код не должен знать конкретный класс объекта, 
		с которым работает, при условии, 
		что он работает с объектами через интерфейс их базового класса.
    &quot;&quot;&quot;
    abstract_class.template_method()

if __name__ == &quot;__main__&quot;:
    print(&quot;Same client code can work with different subclasses:&quot;)
    client_code(ConcreteClass1())
    print(&quot;Same client code can work with different subclasses:&quot;)
    client_code(ConcreteClass2())</code></pre></details></li></ul><ul id="0e6068e4-369e-493c-acdd-fa6a421ea7b2" class="toggle"><li><details open=""><summary>18. Поведенческие паттерны. <mark class="highlight-default">Состояние.</mark><mark class="highlight-yellow"> </mark>Стратегия. Посетитель. </summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="37ba226a-8dee-4ee5-9a93-2567caf9d719"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><span style="border-bottom:0.05em solid"><strong>Паттерн или шаблон проектирования</strong></span> — проверенная архитектурная конструкция для решения определённой частовозникающей проблемы<br/><br/><span style="border-bottom:0.05em solid"><strong>Поведенческие паттерны</strong></span> — паттерны, определяющие способы и алгоритмы совместной работы различных классов и объектов.<br/><br/>К поведенческим паттернам относятся:<br/>- цепочка обязанностей (chain of responsibility)<br/>- команда (command)<br/>- итератор (iterator)<br/>- хранитель (memento)<br/>- наблюдатель (observer)<br/>- шаблонный метод (template method)<br/>- состояние (state)<br/>- стратегия (strategy)<br/>- посетитель (visitor)<br/></div></figure><h1 id="be5f8da0-baab-4104-b600-064878e125c8" class=""><span style="border-bottom:0.05em solid">Состояние (State)</span></h1><div id="01377611-707f-4cc7-9cd9-f49f5a18ad28" class="column-list"><div id="c96047e3-18f0-4ebd-8882-7b78de7233ad" style="width:43.75%" class="column"><figure id="0b0e60bf-f422-4d3e-a171-e7bdc8fffd71" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20105.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20105.png"/></a></figure></div><div id="6c8bd6ad-5a53-45b8-a993-188e9477d14c" style="width:56.25%" class="column"><p id="2884971c-1cd5-4b1b-9945-f6978215afff" class="">Поведенческий паттерн, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.</p><p id="de1e43be-c1da-4403-8e49-10d0c5e00cac" class="">
</p></div></div><h3 id="eaa0c07e-ce7e-4a09-9def-daba64c61fa3" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="13a53140-d4e3-4d4b-adf7-b2385a9fe12a" class="column-list"><div id="dfc30575-d64d-4dd5-9068-0c3ae0b8c1db" style="width:50%" class="column"><p id="a504be73-0237-40d1-8655-1c569749885f" class=""><mark class="highlight-teal"><strong>+</strong></mark> упрощает код контекста</p><p id="91f74632-a768-4930-948e-b125a358d788" class=""><mark class="highlight-teal"><strong>+</strong></mark> концентрирует в одном месте код, связанный с определённым состоянием</p><p id="f151302e-4313-4323-801c-978012230ba3" class=""><mark class="highlight-teal"><strong>+</strong></mark> избавляет от множества больших условных операторов машины состояний</p><p id="75b1e0f5-adb7-44cd-b891-34ca06290561" class="">
</p></div><div id="d9d39a43-e317-4d3e-8805-0229a940d130" style="width:50%" class="column"><p id="a928f755-11a3-4422-ac03-a9ee6388b5d1" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>может неоправданно усложнить код, если состояний мало и они редко меняются</p></div></div><h3 id="cef8e8be-7ded-4a1d-9bdd-ae317b5bb344" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="0dfbd97c-fe00-414f-b7a4-fe73e6582418"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Программа может находиться в одном из нескольких заготовленных состояний, которые всё время сменяют друг друга. В них программа может по-разному реагировать на одни и те же события. Такой подход может быть применён и к отдельным объектам.</div></figure><div id="155103bb-735b-486b-8cb0-4653a6f78a68" class="column-list"><div id="e5466ff0-c716-4dbe-9ac6-e68871be6538" style="width:43.75%" class="column"><figure id="c1c2fe25-a8cf-4695-b83c-b678661874eb" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20106.png"><img style="width:640px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20106.png"/></a></figure><figure id="d5b2ba34-09f0-46fa-8670-4e116c71a7c2" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20107.png"><img style="width:1120px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20107.png"/></a></figure></div><div id="7c00d675-9f18-47ca-b354-edcd50449633" style="width:56.25%" class="column"><p id="2e418765-5422-4ee0-911d-93d0b7657f14" class="">Машину состояний часто реализуют с помощью множества условных операторов, проверяющих текущее состояние объекта и выполняющих соответствующее поведение. </p><p id="eced27a4-6ee2-4f19-9593-bab86ee5173f" class="">Основная проблема такого подхода проявится с большим количеством сложных состояний. Каждый метод будет состоять из увесистого условного оператора. Малейшее изменение логики переходов заставит перепроверить работу всех методов.</p></div></div><h3 id="a39af8c7-f5b1-4846-93ce-0b009eed0fba" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="6af6c1b5-13bf-4125-adac-22380e2cadb6" class="column-list"><div id="b87e61f3-0c06-40bf-b8d6-adeec3f2e03f" style="width:43.75%" class="column"><figure id="ef0979c4-7580-4eca-bc1c-f7bd4249d5de" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20108.png"><img style="width:980px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20108.png"/></a></figure></div><div id="6e677eb0-e927-4365-a6ac-79044d754454" style="width:56.25%" class="column"><ul id="e116443a-578c-4108-904e-77852cde2e10" class="bulleted-list"><li style="list-style-type:disc">создать отдельные классы с соответствующим поведением для каждого состояния, в котором может пребывать объект</li></ul><ul id="9c25f873-ccab-483d-8a29-5ad166dc18ff" class="bulleted-list"><li style="list-style-type:disc">первоначальный объект (контекст) будет содержать ссылку на один из объектов-состояний и передавать ему работу, зависящую от состояния</li></ul><ul id="e67d60f4-d077-4d5b-8535-56b246c1b5dc" class="bulleted-list"><li style="list-style-type:disc">состояния знают друг о друге, а значит можно делать переходы между ними</li></ul></div></div><h3 id="aff7e619-fe2a-4b83-990a-796707b13c6c" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="7f72e38d-b1f8-4b28-b20b-c929d0764675" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20109.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20109.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c77daf3e-958b-4c54-8beb-a159e68568b6" class="code"><code class="language-Python">from abc import ABC, abstractmethod

class Context:
    &quot;&quot;&quot;
    Контекст определяет интерфейс, представляющий интерес для клиентов. 
		Он также хранит ссылку на экземпляр подкласса Состояния, 
		который отображает текущее состояние Контекста.
    &quot;&quot;&quot;
		# текущее состояние контекста
    _state = None

    def __init__(self, state: State) -&gt; None:
        self.transition_to(state)

    def transition_to(self, state: State):
        &quot;&quot;&quot;
        Контекст позволяет изменять объект Состояния во время выполнения.
        &quot;&quot;&quot;
        print(f&quot;Context: Transition to {type(state).__name__}&quot;)
        self._state = state
        self._state.context = self

    # Контекст передаёт часть своего поведения текущему объекту Состояния.
    def request1(self):
        self._state.handle1()

    def request2(self):
        self._state.handle2()

class State(ABC):
    &quot;&quot;&quot;
    Базовый класс Состояния объявляет методы, 
		которые должны реализовать все Конкретные Состояния, 
		а также предоставляет обратную ссылку 
		на объект Контекст, связанный с Состоянием. 
		Эта обратная ссылка может использоваться Состояниями 
		для передачи Контекста другому Состоянию.
    &quot;&quot;&quot;
    @property
    def context(self) -&gt; Context:
        return self._context

    @context.setter
    def context(self, context: Context) -&gt; None:
        self._context = context

    @abstractmethod
    def handle1(self) -&gt; None:
        pass

    @abstractmethod
    def handle2(self) -&gt; None:
        pass

&quot;&quot;&quot;
Конкретные Состояния реализуют различные модели поведения, 
связанные с состоянием Контекста.
&quot;&quot;&quot;
class ConcreteStateA(State):
    def handle1(self) -&gt; None:
        print(&quot;ConcreteStateA handles request1.&quot;)
        print(&quot;ConcreteStateA wants to change the state of the context.&quot;)
        self.context.transition_to(ConcreteStateB())

    def handle2(self) -&gt; None:
        print(&quot;ConcreteStateA handles request2.&quot;)

class ConcreteStateB(State):
    def handle1(self) -&gt; None:
        print(&quot;ConcreteStateB handles request1.&quot;)

    def handle2(self) -&gt; None:
        print(&quot;ConcreteStateB handles request2.&quot;)
        print(&quot;ConcreteStateB wants to change the state of the context.&quot;)
        self.context.transition_to(ConcreteStateA())

if __name__ == &quot;__main__&quot;:
    context = Context(ConcreteStateA())
    context.request1()
    context.request2()</code></pre><h1 id="c795d61c-d346-4069-a433-ca78703451cd" class=""><span style="border-bottom:0.05em solid">Стратегия (Strategy)</span></h1><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d77e8b6f-bf6f-4536-bd80-1f69a2797cea"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%"></div></figure><div id="5270b4d2-a30b-4459-9dbc-7f5762446bb9" class="column-list"><div id="81b4744b-0ab2-4252-bf56-2521b7f47f58" style="width:43.75%" class="column"><figure id="69a2e048-e510-4fa2-b26b-53222f7e118f" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20110.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20110.png"/></a></figure></div><div id="ec84fd53-54e2-4448-9283-619893364573" style="width:56.25%" class="column"><p id="7f307a41-d6ef-4f9a-9d97-0db942a58561" class="">Поведенческий паттерн, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.</p></div></div><h3 id="b55478d6-7737-4752-9129-b91e7ec1b882" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="abfee00b-f49a-4f43-bb52-3138025e66b4" class="column-list"><div id="7940bb0d-a7ea-4b0f-b0ca-16113f5e398c" style="width:50%" class="column"><p id="2d7e4ce3-e571-404e-b713-5d9dd2302c2e" class=""><mark class="highlight-teal"><strong>+</strong></mark> горячая замена алгоритмов на лету</p><p id="fe6a2690-14fe-43c0-9c0d-a88fc7aebe36" class=""><mark class="highlight-teal"><strong>+</strong></mark> уход от наследования к делегированию (передаче) </p><p id="08e84a05-a12c-4d95-9482-3dafe85398ea" class=""><mark class="highlight-teal"><strong>+</strong></mark> реализация принципа открытости/закрытости (O в SOLID)</p><p id="e2e89073-6525-4443-a5df-95ba34ce87e5" class=""><mark class="highlight-teal"><strong>+</strong></mark> изоляция кода и данных алгоритмов от остальных классов</p></div><div id="daf1ed05-4dde-4a56-b36f-cb2a93b2aa07" style="width:50%" class="column"><p id="99ab3901-aa7d-4bf1-902b-f45ccf0dc654" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>усложняет программу за счёт дополнительных классов</p><p id="598cacad-fb80-4307-bd0a-05a8f4346576" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую</p></div></div><h3 id="045db24d-9e73-4ef6-9d44-7fefe30637ce" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e62f5c5e-dfbd-437a-95ca-1fb321dda3e0"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Приложение-навигатор должно показывать красивую и удобную карту. Должен работать поиск и прокладывание маршрутов. Сначала были маршруты только для машин, затем появились маршруты для пешеходов, а затем для общественного транспорта и велосипедистов.</div></figure><div id="7ec17bd4-915f-48d9-8559-0f22ca1b4514" class="column-list"><div id="15cdf36d-9561-41b5-8e21-c3323ad9d6c1" style="width:43.75%" class="column"><figure id="26583759-020a-4a65-bfd0-d1acfcd7d8df" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20111.png"><img style="width:660px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20111.png"/></a></figure></div><div id="16aecaa5-4783-4b95-82a1-0ad9a14c323a" style="width:56.25%" class="column"><p id="c5a1c33e-1160-4674-a4ed-c026455c7158" class="">С каждым новым алгоритмом код основного класса навигатора увеличивался так, что в нём стало довольно трудно ориентироваться.</p><p id="99c21456-01f1-4fb4-8134-f1dedf127e8d" class="">Любое изменение алгоритмов поиска стало затрагивать основной класс, что повысило риск сделать ошибку.</p></div></div><h3 id="ad00df44-e941-46a2-977d-acf495382c33" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="01153b4b-e56e-4fb4-8863-88fa9d8f7864" class="column-list"><div id="e2bb6c23-4160-4cc0-affc-0fa5e9019537" style="width:43.75%" class="column"><figure id="336c3c6e-4167-41b6-90b7-7e10cd6ef319" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20112.png"><img style="width:1140px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20112.png"/></a></figure><figure id="15de4926-0dc7-4927-9ecf-e42fe7ead3b2" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20113.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20113.png"/></a></figure></div><div id="47d02f65-c3ce-4e03-bbba-a4829a86ef3b" style="width:56.25%" class="column"><ul id="e77d7985-1cab-4b4f-9e3f-f52bd5d87ca3" class="bulleted-list"><li style="list-style-type:disc">создать семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы — стратегии</li></ul><ul id="d0ff7a44-d6e9-466d-961f-2379e7e8d94f" class="bulleted-list"><li style="list-style-type:disc">изначальный класс будет играть роль контекста, ссылаясь на одну из стратегий и отдавая ей выполнение работы</li></ul><ul id="0c9ffcb6-f79f-4003-bdcb-02b3a72b8b33" class="bulleted-list"><li style="list-style-type:disc">у стратегий будет общий интерфейс, чтобы изменять алгоритмы, при этом не трогая код контекста</li></ul></div></div><h3 id="17881b49-7e53-45e8-b264-569bf36181c5" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="dab795c6-0a46-47c3-869c-99959768085e" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20114.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20114.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c8ace8b0-d946-4372-bd49-47eac8a22e4f" class="code"><code class="language-Python">from abc import ABC, abstractmethod
from typing import List

class Context:
    &quot;&quot;&quot;
    Контекст определяет интерфейс, представляющий интерес для клиентов.
    &quot;&quot;&quot;
    def __init__(self, strategy: Strategy) -&gt; None:
        &quot;&quot;&quot;
        Обычно Контекст принимает стратегию через конструктор, а также
        предоставляет сеттер для её изменения во время выполнения.
        &quot;&quot;&quot;
        self._strategy = strategy

    @property
    def strategy(self) -&gt; Strategy:
        &quot;&quot;&quot;
        Контекст хранит ссылку на один из объектов Стратегии. 
				Контекст не знает конкретного класса стратегии. 
				Он должен работать со всеми стратегиями через интерфейс Стратегии.
        &quot;&quot;&quot;
        return self._strategy

    @strategy.setter
    def strategy(self, strategy: Strategy) -&gt; None:
        &quot;&quot;&quot;
        Обычно Контекст позволяет заменить объект 
				Стратегии во время выполнения.
        &quot;&quot;&quot;
        self._strategy = strategy

    def do_some_business_logic(self) -&gt; None:
        &quot;&quot;&quot;
        Вместо того, чтобы самостоятельно реализовывать множественные версии
        алгоритма, Контекст отдаёт некоторую работу объекту Стратегии.
        &quot;&quot;&quot;
        print(&quot;Context: Sorting data using the strategy &quot;
							&quot;(not sure how it&#x27;ll do it)&quot;)
        result = self._strategy.do_algorithm([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
        print(&quot;,&quot;.join(result))

class Strategy(ABC):
    &quot;&quot;&quot;
    Интерфейс Стратегии объявляет операции, 
		общие для всех поддерживаемых версий некоторого алгоритма.
    Контекст использует этот интерфейс для вызова алгоритма, 
		определённого Конкретными Стратегиями.
    &quot;&quot;&quot;
    @abstractmethod
    def do_algorithm(self, data: List):
        pass

&quot;&quot;&quot;
Конкретные Стратегии реализуют алгоритм, 
следуя базовому интерфейсу Стратегии.
Этот интерфейс делает их взаимозаменяемыми в Контексте.
&quot;&quot;&quot;
class ConcreteStrategyA(Strategy):
    def do_algorithm(self, data: List) -&gt; List:
        return sorted(data)

class ConcreteStrategyB(Strategy):
    def do_algorithm(self, data: List) -&gt; List:
        return reversed(sorted(data))

if __name__ == &quot;__main__&quot;:
    # клиентский код выбирает конкретную стратегию и передаёт её в контекст
    # клиент должен знать о различиях между стратегиями, 
		# чтобы сделать правильный выбор
    context = Context(ConcreteStrategyA())
    print(&quot;Client: Strategy is set to normal sorting.&quot;)
    context.do_some_business_logic()
    print(&quot;Client: Strategy is set to reverse sorting.&quot;)
    context.strategy = ConcreteStrategyB()
    context.do_some_business_logic()</code></pre><h1 id="b4334a9e-419b-4cf8-b0f2-2b9aa5911c13" class=""><span style="border-bottom:0.05em solid">Посетитель (Visitor)</span></h1><div id="990a8425-2c2b-4262-863e-4fb234e3d4b1" class="column-list"><div id="a158e345-8c01-48d7-9fe0-5f14dfb427ac" style="width:43.75%" class="column"><figure id="d8a93825-a8fd-4ebc-b327-c8848699a667" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20115.png"><img style="width:1280px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20115.png"/></a></figure></div><div id="45dd2fc5-190a-4117-8d42-5057c3462c4e" style="width:56.25%" class="column"><p id="6f9b7e49-20d0-470a-a5cf-2bff1291e27a" class="">Поведенческий паттерн, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.</p></div></div><h3 id="3f620662-5039-4734-8bcc-85deeda72d60" class=""><span style="border-bottom:0.05em solid">Плюсы и минусы</span></h3><div id="0454ad55-0b2a-4f8e-b725-1c7911c55efe" class="column-list"><div id="987bb6de-c855-4aef-a47e-22d417d65b7c" style="width:50%" class="column"><p id="ee07942e-7329-44d2-a9a0-e5a89c43f8c7" class=""><mark class="highlight-teal"><strong>+</strong></mark> объединяет родственные операции в одном классе</p><p id="589b0475-f98f-49f8-aec3-ba9dd1b238f6" class=""><mark class="highlight-teal"><strong>+</strong></mark> посетитель может накапливать состояние при обходе структуры элементов</p><p id="6d44955c-b46f-40af-b1e7-8a3e348345ee" class=""><mark class="highlight-teal"><strong>+</strong></mark> упрощает добавление операций, работающих со сложными структурами объектов</p></div><div id="7e155eef-0b53-4a3f-a190-eb34aae718c9" style="width:50%" class="column"><p id="2367ecce-3df1-4a19-804a-27470f21fac5" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>паттерн не оправдан, если иерархия элементов часто меняется</p><p id="d9f045ec-73ea-43ce-a9ca-8a3cb77a0ef1" class=""><mark class="highlight-red"><strong>-</strong></mark><strong> </strong>может привести к нарушению инкапсуляции элементов</p></div></div><h3 id="b7f518f4-9311-4bd5-ac4e-b8064d6d109e" class=""><span style="border-bottom:0.05em solid">Проблема</span></h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="212730f1-0fbf-4202-801c-72d36e212e83"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%">Приложение, работающее с геоданными в виде графа, должно экспортировать граф в XML. Задача решается легко, если можно редактировать классы узлов — нужно добавить метод экспорта в каждый тип узла, а затем вызвать их у узлов.</div></figure><div id="bdac862b-15c6-441a-b67c-ba7353d7f809" class="column-list"><div id="15c1a8c3-7014-40a6-8629-c4728ae2b2a8" style="width:43.75%" class="column"><figure id="694b017d-5316-4e89-afcf-1a66c838db57" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20116.png"><img style="width:1120px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20116.png"/></a></figure><figure id="0bd0f8b6-cc37-4e79-8c44-9c8112f66cc2" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20117.png"><img style="width:1000px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20117.png"/></a></figure></div><div id="62421385-17c7-4d09-9fb1-2de3d0e329c0" style="width:56.25%" class="column"><p id="159baf90-db1f-4fa8-8fa6-120cca3962a1" class="">Но системный архитектор может запретить редактировать классы узлов, так как их код стабилен и от него многое зависит.</p><p id="28e62bf8-a0fb-4386-83af-78e1abd66033" class="">Даже если получить разрешение, то чтобы через некоторое время добавить новый формат экспорта, снова придётся менять код классов.</p></div></div><h3 id="5f8ea204-a911-4133-a9b1-b4a613ba0fb3" class=""><span style="border-bottom:0.05em solid">Решение</span></h3><div id="969a174c-ade0-4ca0-9afa-25a71437117a" class="column-list"><div id="0415b64c-295b-460a-a5c6-b3f94dcdb5f9" style="width:43.75%" class="column"><figure id="f399a171-f64a-4a9a-898e-063186a16043" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20118.png"><img style="width:1200px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20118.png"/></a></figure></div><div id="c1145796-ec57-47a7-b6b3-603bbb3eb389" style="width:56.25%" class="column"><ul id="4caabb81-67d0-4283-b0e7-e3f41285b038" class="bulleted-list"><li style="list-style-type:disc">разместить новое поведение в отдельном классе, вместо того чтобы множить его сразу в нескольких классах</li></ul><ul id="845c384d-6185-4834-8378-83f338c916a6" class="bulleted-list"><li style="list-style-type:disc">объекты не будут выполнять поведение самостоятельно, объекты будут передаваться в методы посетителя, которые они сами будут вызывать</li></ul><ul id="05bce869-c73b-4c74-80c2-9d8eacecd14a" class="bulleted-list"><li style="list-style-type:disc">код поведения будет отличаться для объектов разных классов, поэтому методов у посетителя будет несколько </li></ul></div></div><h3 id="5b8d17a1-f105-4c22-956b-babfd8a004df" class=""><span style="border-bottom:0.05em solid">Структура и код</span></h3><figure id="1380fe86-46b4-4b81-bcc2-b5d1d7c8a020" class="image"><a href="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20119.png"><img style="width:432px" src="%D0%9E%D0%9E%D0%9F%20b327b853e59447b6b455e9de1dff0c58/Untitled%20119.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bb45cfff-46f1-48a3-8b7b-cc77f4d6daaf" class="code"><code class="language-Python">from abc import ABC, abstractmethod
from typing import List

# Element в структуре
class Component(ABC):
    &quot;&quot;&quot;
    Интерфейс Компонента объявляет метод accept, который в качестве аргумента
    может получать любой объект, реализующий интерфейс посетителя.
    &quot;&quot;&quot;
    @abstractmethod
    def accept(self, visitor: Visitor) -&gt; None:
        pass

class ConcreteComponentA(Component):
    &quot;&quot;&quot;
    Каждый Конкретный Компонент должен реализовать метод accept
		таким образом, чтобы он вызывал метод посетителя, 
		соответствующий классу компонента.
    &quot;&quot;&quot;
    def accept(self, visitor: Visitor) -&gt; None:
        &quot;&quot;&quot;
        Вызываем visitConcreteComponentA, что соответствует 
				названию текущего класса. Таким образом мы позволяем посетителю
				узнать, с каким классом компонента он работает.
        &quot;&quot;&quot;
        visitor.visit_concrete_component_a(self)

    def exclusive_method_of_concrete_component_a(self) -&gt; str:
        &quot;&quot;&quot;
        Конкретные Компоненты могут иметь особые методы, не объявленные в их
        базовом классе или интерфейсе. Посетитель всё же может использовать 
				эти методы, поскольку он знает о конкретном классе компонента.
        &quot;&quot;&quot;
        return &quot;A&quot;

class ConcreteComponentB(Component):
    &quot;&quot;&quot;
    То же самое здесь: visitConcreteComponentB =&gt; ConcreteComponentB
    &quot;&quot;&quot;
    def accept(self, visitor: Visitor):
        visitor.visit_concrete_component_b(self)

    def special_method_of_concrete_component_b(self) -&gt; str:
        return &quot;B&quot;

class Visitor(ABC):
    &quot;&quot;&quot;
    Интерфейс Посетителя объявляет набор методов посещения, соответствующих
    классам компонентов. Сигнатура метода посещения позволяет посетителю
    определить конкретный класс компонента, с которым он имеет дело.
    &quot;&quot;&quot;
    @abstractmethod
    def visit_concrete_component_a(self, element: ConcreteComponentA):
        pass

    @abstractmethod
    def visit_concrete_component_b(self, element: ConcreteComponentB):
        pass

&quot;&quot;&quot;
Конкретные Посетители реализуют несколько версий одного и того же алгоритма,
которые могут работать со всеми классами конкретных компонентов.
Максимальную выгоду от паттерна Посетитель вы почувствуете, 
используя его со сложной структурой объектов, такой как дерево Компоновщика. 
В этом случае было бы полезно хранить некоторое промежуточное состояние 
при выполнении методов посетителя над различными объектами структуры.
&quot;&quot;&quot;
class ConcreteVisitor1(Visitor):
    def visit_concrete_component_a(self, element) -&gt; None:
        print(f&quot;{element.exclusive_method_of_concrete_component_a()} &quot;
							f&quot;+ ConcreteVisitor1&quot;)

    def visit_concrete_component_b(self, element) -&gt; None:
        print(f&quot;{element.special_method_of_concrete_component_b()} &quot;
							f&quot;+ ConcreteVisitor1&quot;)

class ConcreteVisitor2(Visitor):
    def visit_concrete_component_a(self, element) -&gt; None:
        print(f&quot;{element.exclusive_method_of_concrete_component_a()} &quot;
							f&quot;+ ConcreteVisitor2&quot;)

    def visit_concrete_component_b(self, element) -&gt; None:
        print(f&quot;{element.special_method_of_concrete_component_b()} &quot;
							f&quot;+ ConcreteVisitor2&quot;)

def client_code(components: List[Component], visitor: Visitor) -&gt; None:
    &quot;&quot;&quot;
    Клиентский код может выполнять операции посетителя над любым набором
    элементов, не выясняя их конкретных классов. Операция принятия направляет
    вызов к соответствующей операции в объекте посетителя.
    &quot;&quot;&quot;
    for component in components:
        component.accept(visitor)

if __name__ == &quot;__main__&quot;:
    components = [ConcreteComponentA(), ConcreteComponentB()]
    print(&quot;The client code works with all visitors &quot;
					&quot;via the base Visitor interface:&quot;)
    visitor1 = ConcreteVisitor1()
    client_code(components, visitor1)

    print(&quot;It allows the same client code &quot;
					&quot;to work with different types of visitors:&quot;)
    visitor2 = ConcreteVisitor2()
    client_code(components, visitor2)</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e801652c-b2af-4715-8563-5a350a86122e"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%"><p id="090010fc-e7e5-4df2-85ba-3b5d4b948c9c" class="">В <span style="border-bottom:0.05em solid"><strong>Стратегии</strong></span> объекты ничего не знают друг о друге и никак <mark class="highlight-red"><strong>не связаны</strong></mark><br/>В <br/><span style="border-bottom:0.05em solid"><strong>Состоянии</strong></span> сами конкретные состояния <mark class="highlight-red"><strong>могут переключать</strong></mark> контекст</p></div></figure></details></li></ul><h3 id="7a603b92-485b-46de-9e83-42049dda0c76" class="">❗️Примечание</h3><p id="f195ddb8-bc46-4c28-9f86-40e7be748663" class="">Может показаться, что примеры с кодом для некоторых паттернов слишком абстрактны и по ним никак не понять суть шаблонов🙀. Но в данном случае нужно вчитываться не в код, а в <strong>комментарии</strong>. </p><p id="aa6d24e0-f51a-4dcf-9304-0d6923b9a94e" class="">Не пропускайте их, там все очень подробно расписано👹.</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>